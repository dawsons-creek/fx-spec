{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FxSpec","text":"<ul> <li> <p> Pure F# BDD Testing Framework</p> <p>Write beautiful, expressive tests with F#'s type safety and functional programming. Inspired by RSpec, built for F#.</p> </li> </ul> <p>Get Started in 5 Minutes View on GitHub</p>"},{"location":"#why-fxspec","title":"Why FxSpec?","text":"<ul> <li> <p>:material-language-fsharp:{ .lg .middle } Pure F#</p> <p>No dependencies on xUnit, NUnit, or MSTest. 100% idiomatic F# with computation expressions.</p> <p>Built by F# developers, for F# developers.</p> </li> <li> <p> Type-Safe</p> <p>Leverage F#'s type system to catch errors at compile time. Matchers are type-constrained.</p> <p>Impossible to compare incompatible types.</p> </li> <li> <p> Self-Hosting</p> <p>FxSpec tests itself using its own framework. Dogfooding ensures quality.</p> <p>If it's good enough for FxSpec, it's good enough for your project.</p> </li> <li> <p> RSpec-Inspired</p> <p>Familiar BDD syntax: <code>describe</code>, <code>it</code>, <code>expect</code>, and rich matchers.</p> <p>Coming from RSpec, Jest, or pytest? You'll feel at home.</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>module CalculatorSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet calculatorSpecs =\n    spec {\n        describe \"Calculator\" [\n            context \"when adding numbers\" [\n                it \"returns the sum\" (fun () -&gt;\n                    let result = Calculator.add 2 3\n                    expect result |&gt; to' (equal 5)\n                )\n\n                it \"handles negative numbers\" (fun () -&gt;\n                    let result = Calculator.add -1 -2\n                    expect result |&gt; to' (equal -3)\n                )\n            ]\n\n            context \"when dividing numbers\" [\n                it \"returns the quotient\" (fun () -&gt;\n                    let result = Calculator.divide 10 2\n                    expect result |&gt; to' (equal 5)\n                )\n\n                it \"handles division by zero\" (fun () -&gt;\n                    let action () = Calculator.divide 10 0\n                    expect action |&gt; to' raiseException\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#expressive-dsl","title":"Expressive DSL","text":"<p>Write tests that read like documentation. The <code>spec</code> computation expression creates an immutable test tree that's easy to understand and maintain.</p>"},{"location":"#rich-matchers","title":"Rich Matchers","text":"<p>Comprehensive matcher library for all common assertions:</p> <ul> <li>Core matchers: <code>equal</code>, <code>beNil</code>, <code>beSome</code>, <code>beTrue</code></li> <li>Collections: <code>contain</code>, <code>beEmpty</code>, <code>haveLength</code>, <code>allSatisfy</code></li> <li>Strings: <code>startWith</code>, <code>endWith</code>, <code>matchRegex</code></li> <li>Numeric: <code>beGreaterThan</code>, <code>beLessThan</code>, <code>beCloseTo</code></li> <li>Exceptions: <code>raiseException</code>, <code>raiseExceptionOfType</code></li> </ul>"},{"location":"#beautiful-output","title":"Beautiful Output","text":"<p>Tests results with Spectre.Console:</p> <ul> <li>Color-coded pass/fail indicators</li> <li>Hierarchical test structure</li> <li>Diff visualization for failures</li> <li>Performance timing</li> </ul>"},{"location":"#focused-pending-tests","title":"Focused &amp; Pending Tests","text":"<p>Development workflow features:</p> <ul> <li><code>fit</code> - Focus on specific tests</li> <li><code>fdescribe</code> - Focus on test groups</li> <li><code>xit</code> / <code>pending</code> - Skip tests temporarily</li> </ul>"},{"location":"#hooks-setup","title":"Hooks &amp; Setup","text":"<p>Lifecycle hooks for test setup and teardown:</p> <ul> <li><code>beforeEach</code> / <code>afterEach</code> - Run before/after each test</li> <li><code>beforeAll</code> / <code>afterAll</code> - Run once per group</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Type-Safe Testing</p> <p>FxSpec leverages F#'s type system to make testing safer and more maintainable. Matchers are type-constrained, computation expressions provide compile-time validation, and the test tree is immutable.</p> <p>Behavior-Driven Development</p> <p>Tests should describe behavior, not implementation. FxSpec's DSL encourages writing tests that serve as living documentation of your system's behavior.</p> <p>Functional Throughout</p> <p>Pure functions, immutable data, and functional composition. FxSpec embraces F#'s functional programming paradigm throughout its design.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p> Quick Start</p> <p>Get your first test running in 5 minutes.</p> </li> <li> <p> DSL Reference</p> <p>Learn about <code>spec</code>, <code>describe</code>, <code>it</code>, and all DSL functions.</p> </li> <li> <p> Matchers</p> <p>Explore the complete matcher library.</p> </li> <li> <p> Contributing</p> <p>Join the community and contribute to FxSpec.</p> </li> </ul>"},{"location":"#comparison","title":"Comparison","text":""},{"location":"#coming-from-xunitnunit","title":"Coming from xUnit/NUnit?","text":"<p>FxSpec uses BDD-style testing instead of attribute-based testing:</p> xUnit/NUnitFxSpec <pre><code>[&lt;Fact&gt;]\nlet ``adds two numbers`` () =\n    let result = Calculator.add 2 3\n    Assert.Equal(5, result)\n</code></pre> <pre><code>it \"adds two numbers\" (fun () -&gt;\n    let result = Calculator.add 2 3\n    expect result |&gt; to' (equal 5)\n)\n</code></pre> <p>Benefits:</p> <ul> <li>Tests read like specifications</li> <li>Better organization with <code>describe</code>/<code>context</code></li> <li>Hierarchical structure</li> <li>Richer failure messages</li> </ul>"},{"location":"#coming-from-rspecjest","title":"Coming from RSpec/Jest?","text":"<p>FxSpec's syntax will feel familiar:</p> RSpec (Ruby)FxSpec (F#)Jest (JavaScript) <pre><code>describe \"Calculator\" do\n  it \"adds numbers\" do\n    expect(2 + 2).to eq(4)\n  end\nend\n</code></pre> <pre><code>describe \"Calculator\" [\n    it \"adds numbers\" (fun () -&gt;\n        expect (2 + 2) |&gt; to' (equal 4)\n    )\n]\n</code></pre> <pre><code>describe(\"Calculator\", () =&gt; {\n  it(\"adds numbers\", () =&gt; {\n    expect(2 + 2).toBe(4)\n  })\n})\n</code></pre> <p>Key differences:</p> <ul> <li>F# uses lists <code>[]</code> instead of blocks <code>{}</code></li> <li>Matchers use F#'s pipe operator <code>|&gt;</code></li> <li>Tests are wrapped in <code>fun () -&gt;</code> for lazy evaluation</li> </ul>"},{"location":"#whats-next","title":"What's Next?","text":"<p>Ready to dive in?</p> <ol> <li>Quick Start - Install FxSpec and write your first test</li> <li>DSL API - Learn all the DSL functions</li> <li>Matchers - Explore the matcher library</li> </ol> <p>Questions or feedback? Open an issue on GitHub</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/","title":"An Architectural Blueprint for a Pure F# RSpec-Inspired BDD Framework","text":""},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#i-introduction-a-vision-for-bdd-in-f","title":"I. Introduction: A Vision for BDD in F#","text":""},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#11-the-bdd-philosophy-and-rspecs-legacy","title":"1.1. The BDD Philosophy and RSpec's Legacy","text":"<p>Behavior-Driven Development (BDD) represents a significant evolution of Test-Driven Development (TDD), shifting the focus from testing implementation details to specifying application behavior in a human-readable format.1 The primary goal of BDD is to foster collaboration between developers, quality assurance professionals, and business stakeholders by creating a shared language. This is achieved through \"executable specifications\"\u2014tests that double as living documentation for the system.1 In the landscape of BDD frameworks, Ruby's RSpec stands as a paragon of design. Its success is rooted in a Domain-Specific Language (DSL) that is not only powerful but also exceptionally expressive, making the process of writing tests both \"productive and fun\".3 RSpec's conversational syntax, structured around keywords like describe, context, and it, allows developers to articulate the behavior of their code in a clear, narrative style.4 This structure encourages a methodical approach to testing, guiding developers to consider different scenarios and states, from the \"happy path\" to edge cases and error conditions.1 RSpec's comprehensive feature set, including its flexible state management (let, subject, hooks) and extensible matcher system (expect(...).to), has established it as the definitive benchmark for BDD frameworks and serves as the primary inspiration for this architectural design.1</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#12-the-f-advantage-type-safety-meets-expressiveness","title":"1.2. The F# Advantage: Type Safety Meets Expressiveness","text":"<p>While RSpec's dynamic nature in Ruby provides great flexibility, it also carries the inherent risks of runtime errors that are common in dynamically-typed languages. An F# implementation of a BDD framework presents a compelling opportunity to merge the elegant, human-centric DSL of RSpec with the rigorous guarantees of a powerful, statically-typed functional language. F# is uniquely positioned for this endeavor due to several key features:</p> <ul> <li>Type Safety and Inference: F#'s strong, static type system can eliminate entire categories of errors at compile time. This ensures that test code, matchers, and the framework itself are more robust and correct by construction.  </li> <li>Immutability by Default: The emphasis on immutable data structures encourages writing pure, side-effect-free tests, which are easier to reason about, maintain, and execute reliably.  </li> <li>Computation Expressions: This cornerstone F# feature provides a syntactic mechanism for creating powerful, embedded DSLs.8 It allows for the creation of a testing syntax that closely mirrors RSpec's nested block structure while being backed by a well-defined, type-safe builder.10  </li> <li>Discriminated Unions and Pattern Matching: These features are ideal for modeling complex, disjoint states in a type-safe manner.13 They provide a superior foundation for building an assertion and matcher system, enabling the creation of rich, structured results that go far beyond simple boolean pass/fail checks.13</li> </ul> <p>This project's core thesis is that by leveraging these F# features, it is possible to create a testing framework that is not merely an RSpec clone, but a conceptual enhancement. The resulting framework will offer the readability and behavioral focus of RSpec while providing the compile-time safety, correctness, and composability that are hallmarks of the F# language.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#13-project-goals-and-non-goals","title":"1.3. Project Goals and Non-Goals","text":"<p>To maintain a clear focus, the goals and non-goals of this architectural design are explicitly defined. Goals:</p> <ul> <li>Purity and Independence: To design a complete, self-contained BDD framework in pure F#. The entire lifecycle of test discovery, execution, assertion, and reporting will be managed by custom F# code, without any underlying dependency on existing.NET testing frameworks such as NUnit, xUnit, MSTest, or their associated runners like VSTest.15  </li> <li>RSpec Feature Parity: The architecture will provide a clear path to implementing the full spectrum of RSpec's core features, including its nested DSL, state management hooks, fluent expect syntax, a comprehensive matcher library, and specialized spec types for different application layers.  </li> <li>Idiomatic F# Design: The implementation will prioritize functional programming principles and F# idioms. It will favor immutability, function composition, and powerful type-system features over imperative or object-oriented patterns where appropriate.  </li> <li>High-Quality Console Reporting: The test runner will produce elegant, well-structured, and highly informative output to the console, providing clear visual cues for test grouping and detailed, actionable error messages for failures.</li> </ul> <p>Non-Goals:</p> <ul> <li>Reliance on Existing.NET Test Infrastructure: The framework will not use.NET attributes like or for discovery, nor will it integrate with the dotnet test command's default execution pipeline. It will be invoked via its own command-line executable.  </li> <li>Initial Support for Parallel Execution: The initial design will focus on a robust sequential test execution model. The architecture will, however, be designed with future parallelization in mind, and this will be discussed as a potential enhancement.  </li> <li>A Full-Featured Mocking Library: While basic mocking can be achieved with F#'s object expressions, the initial scope does not include the creation of a complete mocking library equivalent to rspec-mocks. The design will be extensible to accommodate such a library in the future.</li> </ul>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#ii-architecting-the-core-dsl-with-computation-expressions","title":"II. Architecting the Core DSL with Computation Expressions","text":"<p>The foundation of an RSpec-like framework is its expressive, nested DSL. In F#, this can be elegantly achieved using Computation Expressions (CEs), which provide the syntactic flexibility to mimic RSpec's block-based structure within a statically-typed environment.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#21-deconstructing-rspecs-structure-a-tree-of-examples","title":"2.1. Deconstructing RSpec's Structure: A Tree of Examples","text":"<p>At its core, an RSpec test suite is not merely a sequence of commands but a hierarchical structure of example groups and examples.1 The describe and context keywords define nested groups, which serve to organize tests and establish shared setup, while the it keyword defines the individual, verifiable examples. This hierarchical nature lends itself perfectly to being modeled as a tree data structure. By explicitly defining the test suite as a tree, we can separate the declaration of the tests from their execution. This separation is a fundamental architectural decision that enables powerful metaprogramming, flexible execution strategies, and clear, composable code. The F# type system, particularly with Discriminated Unions, is ideal for representing this structure:</p> <p>F#</p> <p>/// Represents the outcome of a single test execution. type TestResult =</p> <p>| Pass | Fail of exn option | Skipped of reason: string</p> <p>/// A function that, when executed, produces a TestResult. type TestExecution = unit -&gt; TestResult</p> <p>/// Represents a node in the test suite tree. type TestNode =     /// A leaf node representing an individual test case.</p> <p>| Example of description: string * test: TestExecution     /// An internal node representing a group of tests.</p> <p>| Group of description: string * tests: TestNode list</p> <p>In this model, describe and context blocks correspond to Group nodes, and it blocks correspond to Example nodes. This concrete data structure is the target output of our DSL.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#22-the-spec-computation-expression-a-builder-for-test-suites","title":"2.2. The spec Computation Expression: A Builder for Test Suites","text":"<p>F# Computation Expressions are the premier tool for building embedded DSLs.8 While they are commonly associated with managing control flow for monadic types like async or option, their capabilities are far more general. For this framework, the spec computation expression will not be used for control flow but as a declarative tree builder. Its sole purpose is to construct an instance of the TestNode tree defined above. The entry point to the DSL will be an instance of a builder class:</p> <p>F#</p> <p>type SpecBuilder() =     //... builder methods...</p> <p>let spec = SpecBuilder()</p> <p>A user will then define a test suite like this:</p> <p>F#</p> <p>let myFirstSpec =     spec {         describe \"A Stack\" {             //... nested contexts and examples...         }     }</p> <p>The code inside the spec {... } block will be transformed by the compiler, using the methods on SpecBuilder, into an expression that returns a TestNode list, which can then be collected and executed by the test runner. This approach transforms what appears to be a series of imperative declarations into the construction of a single, immutable data structure. This is a non-obvious but powerful application of CEs, perfectly suited for this domain.8</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#23-implementing-the-builder-describe-it-and-nesting","title":"2.3. Implementing the Builder: describe, it, and Nesting","text":"<p>The SpecBuilder class translates the DSL syntax into the TestNode tree structure. This is achieved by implementing a specific set of methods that the F# compiler looks for when processing a computation expression.</p> <ul> <li>describe and context: These are the primary grouping constructs. They can be implemented as custom operations on the builder using the [\\&lt;CustomOperation&gt;] attribute.17 These methods will accept a description string and a nested computation expression (which itself produces a TestNode list). The method's job is to take the result of the nested block and wrap it in a Group node.  </li> <li>it: This keyword defines a leaf-node example. It maps directly to the Yield method of the computation expression. The Yield method will take the example's description and its body (a function of type unit -&gt; unit) and create an Example node. The body is wrapped in a thunk to delay its execution until the runner is ready.  </li> <li>Nesting and Sequencing: The ability to have multiple it blocks in a row or nested describe blocks is handled by the Combine method. When the compiler encounters two consecutive expressions within the CE, it passes their results to Combine. For this tree builder, the implementation of Combine is straightforward: it concatenates the two lists of TestNodes it receives. This simple mechanism, combined with the recursive nature of the custom operations, provides full support for arbitrarily deep nesting.</li> </ul> <p>The following table provides a clear mapping from the DSL syntax to the underlying builder implementation, demystifying the process for the user.</p> DSL Keyword/Construct SpecBuilder Method Role in Tree Construction spec Run Kicks off the collection process, returning the final TestNode tree. describe \"...\" CustomOperation(\"describe\") Creates a Group node, recursively processing the inner block to generate its children. context \"...\" CustomOperation(\"context\") An alias for describe, serving the same function. it \"...\" Yield Creates an Example leaf node. The body is wrapped in a thunk for later execution. (Sequential it blocks) Combine Merges multiple TestNodes into a single list for the parent Group. let! x =... Bind Binds a value for use within the spec's scope (primarily for setup). return () Return Signifies the end of a block, returning an empty list of nodes (``)."},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#24-state-management-replicating-let-subject-and-hooks","title":"2.4. State Management: Replicating let, subject, and Hooks","text":"<p>A key feature of RSpec is its sophisticated, lexically-scoped state management system, which includes let for lazy-loaded variables, subject for the primary object under test, and before/after hooks for setup and teardown.1 Replicating this behavior correctly is crucial for feature parity. The execution model required to support this is a stateful one. RSpec's state is lexically scoped; an it block can access let variables defined in any of its parent describe blocks. This implies a stack-based context that is managed by the test runner during execution. When the runner traverses the TestNode tree, it will maintain a \"scope stack.\"</p> <ol> <li>When execution enters a Group node, a new scope record is pushed onto the stack. This record contains the let definitions and before/after hooks defined within that specific group.  </li> <li>When an Example node is executed, the runner consults the entire scope stack to resolve let variables and execute all relevant hooks in the correct order (from outermost to innermost for before hooks, and the reverse for after hooks).  </li> <li>When execution leaves a Group node, its corresponding scope record is popped from the stack.</li> </ol> <p>This stateful interpreter model correctly and robustly implements RSpec's lexical scoping rules. The DSL keywords for state management are implemented as follows:</p> <ul> <li>let: To avoid cluttering the CE, this will be implemented as a helper function, let', rather than a keyword. A call like let' \"myVar\" (fun () -&gt; createExpensiveObject()) will not execute the function but will register a lazy, memoized factory in the current execution scope. The first time \"myVar\" is accessed within a test, the factory is executed, and its result is cached for the duration of that specific example run.  </li> <li>subject: This will be a custom operation, subject \\&lt;| fun () -&gt;..., which provides syntactic sugar over let' \"subject\" (fun () -&gt;...).  </li> <li>before and after: These will be custom operations that register (unit -&gt; unit) functions in the current scope. The runner will execute these functions at the appropriate times based on the scope stack.</li> </ul>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#iii-building-a-fluent-and-type-safe-assertion-system","title":"III. Building a Fluent and Type-Safe Assertion System","text":"<p>The assertion system is where the framework's correctness guarantees are enforced. This design moves beyond RSpec's dynamic matchers to a fully type-safe, functional, and highly expressive system built on core F# features.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#31-the-anatomy-of-an-expectation-expect-to-and-matchers","title":"3.1. The Anatomy of an Expectation: expect, to', and Matchers","text":"<p>RSpec's assertion syntax is famously readable: expect(value).to eq(expected).4 This fluent chain can be replicated idiomatically in F# using the pipe operator and higher-order functions: expect actual |&gt; to' (matcher expected) The components of this chain are:</p> <ul> <li>expect: A simple identity function, let expect x = x. Its purpose is purely syntactic, providing a clear and familiar starting point for an assertion.  </li> <li>to': A higher-order function that serves as the assertion engine. It takes a Matcher function and the actual value as arguments. It executes the matcher, inspects the result, and if the result is a failure, it throws a custom AssertionException to signal the test failure to the runner. The tick (') is used to avoid a name collision with the F# to keyword in for loops.  </li> <li>Matcher: A function that takes an actual value and returns a structured result indicating success or failure. For example, a simple matcher has the signature 'a -&gt; MatchResult.</li> </ul>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#32-a-type-safe-matcher-architecture-with-discriminated-unions","title":"3.2. A Type-Safe Matcher Architecture with Discriminated Unions","text":"<p>The most significant architectural improvement over RSpec's matcher system is the use of F# Discriminated Unions (DUs) to model the outcome of an assertion.13 Whereas an RSpec matcher typically returns a boolean and relies on separate methods for generating failure messages 4, this design uses a single, rich, and type-safe DU to represent the result:</p> <p>F#</p> <p>type MatchResult\\&lt;'a&gt; =</p> <p>| Pass | Fail of message: string * expected: obj option * actual: obj option</p> <p>This approach is a profound shift from a procedural to a declarative model. It provides several key advantages:</p> <ol> <li>Type Safety: The set of possible outcomes is fixed and known at compile time.  </li> <li>Rich Failure Data: A Fail case carries all the information needed to generate a high-quality error report, including a descriptive message and the expected and actual values for diffing.  </li> <li>Decoupling: The logic of a matcher is completely decoupled from the logic of failure reporting. A matcher's only job is to produce a MatchResult. The to' function's only job is to pattern match on this result and throw an exception if it's a Fail. This separation of concerns makes the entire system cleaner, more robust, and easier to extend.</li> </ol>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#33-implementation-of-core-matchers","title":"3.3. Implementation of Core Matchers","text":"<p>Implementing matchers becomes a straightforward exercise of writing functions that return a MatchResult.</p> <ul> <li> <p>equal: A generic equality matcher.   F#   let equal expected actual =       if actual = expected then           Pass       else           let msg = sprintf \"Expected value to be %A, but found %A.\" expected actual           Fail (msg, Some (box expected), Some (box actual))</p> </li> <li> <p>beNil: A matcher to check for null.   F#   let beNil actual =       if obj.ReferenceEquals(actual, null) then           Pass       else           let msg = \"Expected value to be null, but it was not.\"           Fail (msg, Some null, Some (box actual))</p> </li> <li> <p>contain: A generic collection matcher. Its type signature, let contain (expected: 'a) (actual: 'a seq), provides a compile-time guarantee that it can only be used with sequence types\u2014a level of safety RSpec cannot offer.  </p> </li> <li>raiseException: A more complex matcher for testing exceptions. It accepts a function to execute and uses a try...catch block to verify that an exception of the correct type is thrown.   F#   let raiseException\\&lt;'T when 'T :&gt; exn&gt; (f: unit -&gt; unit) =       try           f()           let msg = sprintf \"Expected an exception of type %s to be thrown, but nothing was thrown.\" (typeof\\&lt;'T&gt;.Name)           Fail (msg, Some (box typeof\\&lt;'T&gt;), None)       with</li> </ul> <p>| :? 'T -&gt; Pass | ex -&gt; let msg = sprintf \"Expected an exception of type %s, but an exception of type %s was thrown.\" (typeof\\&lt;'T&gt;.Name) (ex.GetType().Name) Fail (msg, Some (box typeof\\&lt;'T&gt;), Some (box ex.GetType())) ```</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#34-a-guide-to-authoring-custom-matchers","title":"3.4. A Guide to Authoring Custom Matchers","text":"<p>Creating custom matchers in this framework is significantly simpler than in RSpec.4 A user does not need to learn a special DSL or implement a class with multiple methods. Instead, they simply write a function that takes a value and returns a MatchResult. This purely functional approach makes custom matchers easy to write, test, and compose. The following table translates common RSpec assertions into the proposed F# DSL, illustrating the intuitive and consistent design.</p> Matcher RSpec Example F# Example F# Implementation Sketch Equality expect(a).to eq(b) `expect a &gt; to' (equal b)` Nil Check expect(a).to be_nil `expect a &gt; to' beNil` Collection expect(col).to include(item) `expect col &gt; to' (contain item)` Error expect {}.to raise_error `expect (fun () -&gt;...) &gt; to' (raiseException)` Truthiness expect(a).to be_truthy `expect a &gt; to' beTruthy`"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#iv-the-test-runner-discovery-execution-and-reporting","title":"IV. The Test Runner: Discovery, Execution, and Reporting","text":"<p>The test runner is the engine that brings the DSL to life. It is responsible for discovering the tests defined by the user, executing them in the correct order with the correct state, and reporting the results.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#41-test-discovery-via-reflection","title":"4.1. Test Discovery via Reflection","text":"<p>Test discovery will be initiated from a command-line tool. The mechanism avoids the heavy reflection used by traditional.NET test frameworks 16 by leveraging a custom attribute and the TestNode data structure. First, a custom attribute is defined to mark test suites for discovery:</p> <p>F#</p> <p>type TestsAttribute() = inherit System.Attribute()</p> <p>The discovery process is as follows:</p> <ol> <li>The runner is given the path to a test assembly (e.g., MyProject.Tests.dll).  </li> <li>It loads the assembly using System.Reflection.Assembly.LoadFrom().  </li> <li>It iterates through all exported types in the assembly via assembly.GetTypes().  </li> <li>For each type, it searches for public, static let-bound values that are of type TestNode (or TestNode list) and are decorated with the `` attribute.21</li> </ol> <p>This approach is highly efficient. Reflection is used only as a lightweight bootstrapper to locate the root nodes of the test trees. The complex structure of the test suite has already been built by the computation expression and captured by the F# type system. This minimizes reliance on slow reflection and keeps the test definitions themselves strongly typed and compiler-verified.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#42-the-execution-engine-a-stateful-tree-traversal","title":"4.2. The Execution Engine: A Stateful Tree Traversal","text":"<p>The execution engine's core is a recursive function that traverses the discovered TestNode tree while managing the stateful scope stack described in Section 2.4. The main function, executeNode(node, scopeStack), operates as follows:</p> <ol> <li>If node is a Group:    a. Create a new scope record containing the let definitions and before/after hooks defined for this group.    b. Push this new scope onto the scopeStack.    c. Recursively call executeNode for each child node in the group's tests list, collecting the results.    d. Pop the scope from the scopeStack.    e. Return a GroupResult node containing the description and the collected child results.  </li> <li>If node is an Example:    a. Execute all before hooks found on the scopeStack, from the outermost scope to the innermost.    b. Execute the example's test function (TestExecution). This execution is wrapped in a try...catch block. If the function completes without an exception, the result is Pass. If an AssertionException or any other exception is caught, the result is Fail, capturing the exception details.    c. Execute all after hooks on the scopeStack, from the innermost scope to the outermost.    d. Return an ExampleResult node containing the description and the final TestResult.</li> </ol> <p>The implementation of the let' cache is managed within the scope records. Each scope will contain a concurrent dictionary to store memoized values. When a let variable is requested, the runner checks all dictionaries on the stack (from inner to outer). If found, the cached value is returned. If not, the factory function is executed, the result is stored in the current scope's cache, and then returned.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#43-result-aggregation-and-the-cli","title":"4.3. Result Aggregation and the CLI","text":"<p>As the execution engine traverses the TestNode tree, it constructs a parallel tree of results. The final output of the execution phase is a TestResultNode tree that mirrors the original test suite structure but is annotated with the outcome of each example. This result tree is then passed to a formatter for display. The command-line interface (CLI) for the runner will be built using a library like Argu, which simplifies parsing command-line arguments in F#.22 The CLI will support essential features:</p> <ul> <li>Target Assembly: dotnet fspec \\&lt;path-to-tests.dll&gt;  </li> <li>Test Filtering: --filter \"User login\" to run only tests whose descriptions contain the given substring.  </li> <li>Output Formatting: --format documentation (default) or potentially other formats like --format json in the future.</li> </ul>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#v-implementing-rspec-equivalent-spec-types","title":"V. Implementing RSpec-Equivalent Spec Types","text":"<p>A powerful aspect of RSpec is its specialization for different layers of an application.23 The core framework designed here is extensible and can be used as a foundation for building these specialized DSLs.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#51-model-specs-testing-domain-logic","title":"5.1. Model Specs: Testing Domain Logic","text":"<p>Model specs are the most fundamental type of test, focusing on the business logic and data structures of an application.24 In an F# context, this involves testing functions, records, and discriminated unions. The core spec computation expression and the standard matcher library are perfectly suited for this purpose without any modification. Examples would include testing function composition, verifying the state transitions of a DU, or asserting the properties of an immutable record after an operation.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#52-request-specs-integration-testing-for-web-apis","title":"5.2. Request Specs: Integration Testing for Web APIs","text":"<p>Request specs are designed for integration testing of web APIs, exercising the full stack from routing and middleware down to the controller and response generation.23 To support this, a new requestSpec computation expression can be created. This RequestSpecBuilder would extend the base SpecBuilder and manage an HttpClient instance internally. For testing ASP.NET Core applications, this client would typically be created from an in-memory WebApplicationFactory, which hosts the application without needing a live network connection.29 The requestSpec builder would introduce custom operations for making HTTP requests:</p> <ul> <li>get \"/api/users\"  </li> <li>post \"/api/users\" withJson {| Name = \"Test\" |}  </li> <li>put \"/api/users/1\" withHeaders</li> </ul> <p>These operations would execute the HTTP request and store the resulting HttpResponseMessage in the execution context, making it available to subsequent assertions within an it block. Specialized matchers would also be provided for convenience:</p> <ul> <li>haveStatusCode 200  </li> <li>haveHeader \"Content-Type\" \"application/json\"  </li> <li>haveJsonBody {| Id = 1; Name = \"Test\" |}</li> </ul>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#53-system-feature-specs-high-level-user-interaction","title":"5.3. System &amp; Feature Specs: High-Level User Interaction","text":"<p>System or Feature specs are the highest level of automated tests, simulating user interaction with the application through a web browser.23 In RSpec, this is accomplished via the Capybara library. An F# equivalent would require a featureSpec computation expression that integrates with a.NET browser automation library, such as Playwright Sharp. The FeatureSpecBuilder would manage the browser instance, page context, and navigation. It would provide custom operations that mirror user actions:</p> <ul> <li>visit \"/login\"  </li> <li>fillIn \"#username\" with \"user@example.com\"  </li> <li>click \"Log In\"  </li> <li>see \"Welcome, user!\"</li> </ul> <p>Given the complexity of browser automation, this feature represents a significant extension. The core architecture, however, provides the necessary hooks (custom operations and extensible builders) to support such an integration as the framework matures.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#vi-crafting-elegant-and-informative-console-output","title":"VI. Crafting Elegant and Informative Console Output","text":"<p>The final, and arguably most important, user-facing component of a BDD framework is its output. The test results must be presented as clear, readable documentation.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#61-principles-of-effective-bdd-reporting","title":"6.1. Principles of Effective BDD Reporting","text":"<p>The primary goal of the output formatter is to reflect the nested, descriptive structure of the test suite itself. A successful run should read like a specification document, confirming the system's behavior. A failed run should immediately draw attention to the broken specification, providing all the necessary context to diagnose the issue quickly. RSpec's documentation formatter is the model for this style of reporting.3</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#62-leveraging-spectreconsole-for-rich-output","title":"6.2. Leveraging Spectre.Console for Rich Output","text":"<p>To create a modern, visually appealing, and informative console experience, this design will leverage the Spectre.Console library.33 This powerful library provides a rich API for rendering colored text, tables, trees, and other widgets, abstracting away the complexities of cross-platform terminal control. A DocumentationFormatter class will be responsible for rendering the TestResultNode tree. It will recursively traverse the tree, using Spectre.Console's markup capabilities to:</p> <ul> <li>Print Group descriptions with increasing indentation to show nesting.  </li> <li>Print Example descriptions prefixed with a colored symbol: a green checkmark ([green]\u2713[/]) for Pass and a red cross ([red]\u2717[/]) for Fail.  </li> <li>Display a summary of total, passed, and failed tests at the end of the run.</li> </ul>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#63-designing-comprehensive-failure-messages","title":"6.3. Designing Comprehensive Failure Messages","text":"<p>A failing test is not just an error; it is a critical piece of feedback. The quality of the failure message directly impacts developer productivity. While RSpec provides good basic messages 3, inspiration will be drawn from modern frameworks like Jest and FluentAssertions, which provide rich diffs and highly descriptive error reports.35 A failure message is a core feature of the framework, not an afterthought. Thanks to the MatchResult DU, the formatter has access to all the necessary data to generate an excellent report. For each failed test, the DocumentationFormatter will output:</p> <ol> <li>The full, nested description of the test, printed in red to provide context.  </li> <li>The specific failure message from the matcher (e.g., \"Expected value to be 42, but found 99.\").  </li> <li>A color-coded diff view of the expected vs. actual values, if they were provided in the Fail case. For complex objects, this could involve a side-by-side or inline diff.  </li> <li>A cleaned-up stack trace that pinpoints the exact line in the user's test file where the assertion failed, filtering out the internal noise from the test runner itself.</li> </ol> <p>This multi-part failure report provides immediate, actionable information, helping developers understand not just that a test failed, but precisely what was wrong and where.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#vii-conclusion-and-future-directions","title":"VII. Conclusion and Future Directions","text":""},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#71-summary-of-the-architectural-design","title":"7.1. Summary of the Architectural Design","text":"<p>This document has outlined a comprehensive architectural blueprint for creating a pure F# testing framework that captures the spirit and functionality of RSpec while leveraging the unique strengths of the F# language. The core of the design rests on several key decisions:</p> <ul> <li>A Computation Expression-based DSL that acts as a declarative builder for a TestNode tree, providing a type-safe foundation for the RSpec-like syntax.  </li> <li>A fluent and type-safe assertion system built on higher-order functions and Discriminated Unions, which decouples matcher logic from failure reporting and provides rich, structured data for error messages.  </li> <li>A stateful test runner that uses a scope stack to correctly implement RSpec's lexical scoping for state management constructs like let and before/after hooks.  </li> <li>A rich and informative reporting layer powered by Spectre.Console, designed to present test results as living documentation and provide detailed, actionable feedback for failures.</li> </ul> <p>This architecture achieves the primary goal of creating an elegant, powerful, and fully independent BDD framework in F#, offering a compelling alternative for developers in the.NET ecosystem.</p>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#72-future-enhancements","title":"7.2. Future Enhancements","text":"<p>The proposed architecture provides a solid foundation that can be extended in several important directions to further increase its power and utility.</p> <ul> <li>Parallel Execution: The explicit tree structure of the test suite is highly amenable to parallelization. Independent sub-trees (Group nodes with no shared, mutable state dependencies) could be dispatched to a thread pool for concurrent execution, significantly reducing the runtime of large test suites.  </li> <li>Advanced Mocking Library: A dedicated mocking library, inspired by rspec-mocks or F#'s own Foq 37, could be developed. Such a library would integrate seamlessly with the let' and subject mechanisms and leverage F# features like quotations to provide a type-safe and powerful mocking experience.  </li> <li>IDE and Editor Integration: Building a plugin for Visual Studio Code's Ionide extension 22 would dramatically improve the developer experience. This could include features like CodeLens annotations to run individual tests or groups directly from the editor, inline display of test failures, and debugging support.  </li> <li>Property-Based Testing Integration: The framework could be enhanced to seamlessly integrate FsCheck, a powerful property-based testing library for F#.16 An itProperty custom operation could be added, allowing developers to combine example-based BDD specifications with property-based tests within the same describe block, harnessing the strengths of both paradigms.</li> </ul>"},{"location":"Designing%20an%20F%23%20RSpec%20Clone/#works-cited","title":"Works cited","text":"<ol> <li>How to test with RSpec: an extensive beginners guide | by Charlie Kroon - Medium, accessed October 31, 2025, https://medium.com/@charliekroon/how-to-test-with-rspec-an-extensive-beginners-guide-886086168d2d </li> <li>pytest vs RSpec comparison of testing frameworks - Knapsack Pro, accessed October 31, 2025, https://knapsackpro.com/testing_frameworks/difference_between/pytest/vs/rspec </li> <li>RSpec: Behaviour Driven Development for Ruby, accessed October 31, 2025, https://rspec.info/ </li> <li>Classroom Lecture: Deep Dive into RSpec - DevCamp, accessed October 31, 2025, https://devcamp.com/site_blogs/classroom-lecture-deep-dive-rspec </li> <li>The basic structure (`describe`/`it`) - RSpec, accessed October 31, 2025, https://rspec.info/features/3-12/rspec-core/example-groups/basic-structure/ </li> <li>Module: RSpec::Matchers \u2014 Documentation by YARD 0.8.0, accessed October 31, 2025, https://rspec.info/documentation/2.14/rspec-expectations/RSpec/Matchers </li> <li>How I structure RSpec tests - Jake Goulding, accessed October 31, 2025, http://jakegoulding.com/presentations/rspec-structure/ </li> <li>Computation expressions: Introduction | F# for fun and profit, accessed October 31, 2025, https://fsharpforfunandprofit.com/posts/computation-expressions-intro/ </li> <li>Functional programming: Code with F# computation expressions - Pluralsight, accessed October 31, 2025, https://www.pluralsight.com/resources/blog/software-development/fsharp-computation-expressions </li> <li>Computation Expressions - F# | Microsoft Learn, accessed October 31, 2025, https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions </li> <li>Creating DSLs using F#'s Computation Expressions : r/programming - Reddit, accessed October 31, 2025, https://www.reddit.com/r/programming/comments/1e048ta/creating_dsls_using_fs_computation_expressions/ </li> <li>The 'Computation Expressions' series | F# for fun and profit, accessed October 31, 2025, https://fsharpforfunandprofit.com/series/computation-expressions/ </li> <li>Pattern Matching - F# | Microsoft Learn, accessed October 31, 2025, https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/pattern-matching </li> <li>What's new in F# 9 - F# Guide - .NET | Microsoft Learn, accessed October 31, 2025, https://learn.microsoft.com/en-us/dotnet/fsharp/whats-new/fsharp-9 </li> <li>dotnet test command - .NET CLI | Microsoft Learn, accessed October 31, 2025, https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-test </li> <li>Using F# for testing | F# for fun and profit, accessed October 31, 2025, https://fsharpforfunandprofit.com/posts/low-risk-ways-to-use-fsharp-at-work-3/ </li> <li>Creating a Lego Mindstorms DSL in F# | F# all the things, accessed October 31, 2025, https://atlemann.github.io/fsharp/2019/12/11/mindstorms-dsl.html </li> <li>Code Reading: Expectations in RSpec 3.0 - modocache.io, accessed October 31, 2025, https://modocache.io/code-reading-expectations-in-rspec-3-0 </li> <li>Create, run, and customize C# unit tests - Visual Studio (Windows) | Microsoft Learn, accessed October 31, 2025, https://learn.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2022 </li> <li>Building a Custom C# Test Runner from Scratch | by Lia Cohn ..., accessed October 31, 2025, https://medium.com/@lia.c/building-a-custom-c-test-runner-from-scratch-1f9d09ead363 </li> <li>F Sharp Programming/Reflection - Wikibooks, open books for an ..., accessed October 31, 2025, https://en.wikibooks.org/wiki/F_Sharp_Programming/Reflection </li> <li>Creating F# solutions in VSCode from scratch | F# all the things, accessed October 31, 2025, https://atlemann.github.io/fsharp/2018/02/28/fsharp-solutions-from-scratch.html </li> <li>A Deep Dive Into RSpec Tests in Ruby on Rails - AppSignal Blog, accessed October 31, 2025, https://blog.appsignal.com/2024/02/07/a-deep-dive-into-rspec-tests-in-ruby-on-rails.html </li> <li>Model specs - RSpec, accessed October 31, 2025, https://rspec.info/features/8-0/rspec-rails/model-specs/ </li> <li>RSpec model, request and system specs? : r/rails - Reddit, accessed October 31, 2025, https://www.reddit.com/r/rails/comments/ibof0z/rspec_model_request_and_system_specs/ </li> <li>RSpec-Rails, Part 1. Adding Simple Model Tests To Rails | by David Ryan Morphew, accessed October 31, 2025, https://davidrmorphew.medium.com/rspec-rails-part-1-70c90882673a </li> <li>Request specs - RSpec, accessed October 31, 2025, https://rspec.info/features/6-0/rspec-rails/request-specs/request-spec/ </li> <li>Request specs - RSpec, accessed October 31, 2025, https://rspec.info/features/7-0/rspec-rails/request-specs/ </li> <li>Integration tests in ASP.NET Core | Microsoft Learn, accessed October 31, 2025, https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-9.0 </li> <li>Feature specs - RSpec, accessed October 31, 2025, https://rspec.info/features/7-0/rspec-rails/feature-specs/feature-spec/ </li> <li>The difference between Feature Specs and Request Specs - mike.williamson, accessed October 31, 2025, https://mikewilliamson.wordpress.com/2013/06/12/the-difference-between-feature-specs-and-request-specs/ </li> <li>Feature specs - RSpec, accessed October 31, 2025, https://rspec.info/features/6-1/rspec-rails/feature-specs/ </li> <li>Spectre.Console - Welcome!, accessed October 31, 2025, https://spectreconsole.net/ </li> <li>[Presentation] FsSpectre, Spectre.Console with F# style : r/fsharp - Reddit, accessed October 31, 2025, https://www.reddit.com/r/fsharp/comments/10o85pa/presentation_fsspectre_spectreconsole_with_f_style/ </li> <li>Expect \u00b7 Jest, accessed October 31, 2025, https://archive.jestjs.io/docs/en/22.x/expect </li> <li>Sparky's Tool Tips: Fluent Assertions - DEV Community, accessed October 31, 2025, https://dev.to/sparky/these-are-a-few-of-my-favorite-tools-fluent-assertions-1a5o </li> <li>Testing and mocking your C# code with F# \u00b7 Mathias Brandewinder blog, accessed October 31, 2025, https://brandewinder.com/2013/01/27/Testing-and-mocking-your-C-sharp-code-with-F-sharp/ </li> <li>An introduction to property-based testing \u00b7 F# for Fun and Profit, accessed October 31, 2025, https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/posts/property-based-testing.html </li> <li>Writing and testing business logic in F# - Event-Driven.io, accessed October 31, 2025, https://event-driven.io/en/writing_and_testing_business_logic_in_fsharp/</li> </ol>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Get your first FxSpec test running in 5 minutes.</p>"},{"location":"quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8.0 or .NET 9.0 SDK</li> <li>F# 8.0+ (included with .NET SDK)</li> <li>Basic F# knowledge</li> </ul>"},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#step-1-create-a-test-project","title":"Step 1: Create a Test Project","text":"<p>Create a new F# console project for your tests:</p> <pre><code>dotnet new console -lang F# -n MyProject.Tests\ncd MyProject.Tests\n</code></pre>"},{"location":"quick-start/#step-2-add-fxspec-packages","title":"Step 2: Add FxSpec Packages","text":"<p>Add the FxSpec packages to your project:</p> <pre><code>dotnet add package FxSpec.Core\ndotnet add package FxSpec.Matchers\ndotnet add package FxSpec.Runner\n</code></pre> <p>Package Status</p> <p>FxSpec packages are not yet published to NuGet. For now, you'll need to build from source or reference the local projects.</p>"},{"location":"quick-start/#your-first-test","title":"Your First Test","text":""},{"location":"quick-start/#step-1-create-a-test-file","title":"Step 1: Create a Test File","text":"<p>Create a new file called <code>MyFirstSpecs.fs</code> in your test project:</p> <pre><code>module MyFirstSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet myFirstSpecs =\n    spec {\n        describe \"My First Test Suite\" [\n            it \"passes!\" (fun () -&gt;\n                expect true |&gt; to' beTrue\n            )\n\n            it \"checks equality\" (fun () -&gt;\n                let result = 2 + 2\n                expect result |&gt; to' (equal 4)\n            )\n\n            it \"works with strings\" (fun () -&gt;\n                let greeting = \"Hello, FxSpec!\"\n                expect greeting |&gt; to' (startWith \"Hello\")\n            )\n        ]\n    }\n</code></pre>"},{"location":"quick-start/#step-2-update-your-fsproj","title":"Step 2: Update Your .fsproj","text":"<p>Make sure your test file is included in the project:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;Compile Include=\"MyFirstSpecs.fs\" /&gt;\n  &lt;Compile Include=\"Program.fs\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"quick-start/#step-3-update-programfs","title":"Step 3: Update Program.fs","text":"<p>Replace the contents of <code>Program.fs</code> with:</p> <pre><code>[&lt;EntryPoint&gt;]\nlet main args =\n    // FxSpec will automatically discover tests\n    0\n</code></pre>"},{"location":"quick-start/#step-4-run-your-tests","title":"Step 4: Run Your Tests","text":"<p>Run the tests using the FxSpec runner:</p> <pre><code>dotnet build\ndotnet run\n</code></pre> <p>You should see beautiful output like this:</p> <pre><code>My First Test Suite\n  \u2713 passes! (2ms)\n  \u2713 checks equality (1ms)\n  \u2713 works with strings (1ms)\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ... \u2502 Passed \u2502 Failed \u2502 Skipped \u2502 Duration \u2502\n\u2502  3  \u2502   3    \u2502   0    \u2502    0    \u2502  0.01s   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Congratulations!</p> <p>You've just written and run your first FxSpec tests!</p>"},{"location":"quick-start/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what you just wrote:</p>"},{"location":"quick-start/#the-spec-builder","title":"The <code>spec</code> Builder","text":"<pre><code>spec {\n    // Your test definitions go here\n}\n</code></pre> <p>The <code>spec</code> computation expression is the container for all your tests. It builds an immutable test tree.</p>"},{"location":"quick-start/#the-describe-function","title":"The <code>describe</code> Function","text":"<pre><code>describe \"My First Test Suite\" [\n    // Individual tests go here\n]\n</code></pre> <p><code>describe</code> groups related tests together. You can nest multiple <code>describe</code> blocks to create a hierarchy.</p>"},{"location":"quick-start/#the-it-function","title":"The <code>it</code> Function","text":"<pre><code>it \"passes!\" (fun () -&gt;\n    expect true |&gt; to' beTrue\n)\n</code></pre> <p><code>it</code> defines an individual test case:</p> <ul> <li>First parameter: Test description (string)</li> <li>Second parameter: Test function that makes assertions</li> </ul>"},{"location":"quick-start/#the-expect-function","title":"The <code>expect</code> Function","text":"<pre><code>expect actual |&gt; to' (equal expected)\n</code></pre> <p><code>expect</code> starts an assertion:</p> <ul> <li><code>actual</code> - The value you're testing</li> <li><code>to'</code> - Applies a matcher (positive assertion)</li> <li><code>equal expected</code> - The matcher function</li> </ul>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have FxSpec running, explore more features:</p>"},{"location":"quick-start/#organize-with-context","title":"Organize with Context","text":"<p>Use <code>context</code> to add more structure:</p> <pre><code>spec {\n    describe \"Calculator\" [\n        context \"when adding positive numbers\" [\n            it \"returns the sum\" (fun () -&gt;\n                expect (2 + 3) |&gt; to' (equal 5)\n            )\n        ]\n\n        context \"when adding negative numbers\" [\n            it \"handles negatives correctly\" (fun () -&gt;\n                expect (-2 + -3) |&gt; to' (equal -5)\n            )\n        ]\n    ]\n}\n</code></pre>"},{"location":"quick-start/#use-more-matchers","title":"Use More Matchers","text":"<p>Explore the rich matcher library:</p> <pre><code>// Collections\nexpect [1; 2; 3] |&gt; to' (contain 2)\nexpect [] |&gt; to' beEmpty\nexpect [1; 2; 3] |&gt; to' (haveLength 3)\n\n// Strings\nexpect \"hello world\" |&gt; to' (endWith \"world\")\nexpect \"test@example.com\" |&gt; to' (matchRegex @\"^\\w+@\\w+\\.\\w+$\")\n\n// Numeric\nexpect 10 |&gt; to' (beGreaterThan 5)\nexpect 3.14159 |&gt; to' (beCloseTo 3.14 0.01)\n\n// Options\nexpect (Some 42) |&gt; to' (beSome 42)\nexpect None |&gt; to' beNone\n\n// Results\nexpect (Ok \"success\") |&gt; to' (beOk \"success\")\nexpect (Error \"failed\") |&gt; to' (beError \"failed\")\n</code></pre>"},{"location":"quick-start/#negative-assertions","title":"Negative Assertions","text":"<p>Use <code>notTo'</code> for negative assertions:</p> <pre><code>expect 5 |&gt; notTo' (equal 10)\nexpect \"hello\" |&gt; notTo' (startWith \"bye\")\nexpect [1; 2; 3] |&gt; notTo' beEmpty\n</code></pre>"},{"location":"quick-start/#focus-on-specific-tests","title":"Focus on Specific Tests","text":"<p>During development, focus on specific tests:</p> <pre><code>spec {\n    describe \"My Suite\" [\n        fit \"only run this test\" (fun () -&gt;  // (1)!\n            expect true |&gt; to' beTrue\n        )\n\n        it \"this test will be skipped\" (fun () -&gt;\n            expect false |&gt; to' beTrue\n        )\n    ]\n}\n</code></pre> <ol> <li><code>fit</code> (focused it) runs only this test. Use <code>fdescribe</code> to focus an entire group.</li> </ol>"},{"location":"quick-start/#skip-tests-temporarily","title":"Skip Tests Temporarily","text":"<p>Mark tests as pending:</p> <pre><code>spec {\n    describe \"My Suite\" [\n        it \"working test\" (fun () -&gt;\n            expect true |&gt; to' beTrue\n        )\n\n        xit \"not ready yet\" (fun () -&gt;  // (1)!\n            expect false |&gt; to' beTrue\n        )\n\n        pending \"TODO: implement this test\" (fun () -&gt;  // (2)!\n            ()\n        )\n    ]\n}\n</code></pre> <ol> <li><code>xit</code> (excluded it) skips this test</li> <li><code>pending</code> is an alias for <code>xit</code> that reads better for unfinished tests</li> </ol>"},{"location":"quick-start/#setup-and-teardown","title":"Setup and Teardown","text":"<p>Use hooks for test setup:</p> <pre><code>spec {\n    describe \"Database Tests\" [\n        let mutable connection = null\n\n        beforeEach (fun () -&gt;\n            connection &lt;- Database.connect()\n        )\n\n        afterEach (fun () -&gt;\n            connection.Dispose()\n        )\n\n        it \"queries the database\" (fun () -&gt;\n            let result = connection.Query(\"SELECT 1\")\n            expect result |&gt; notTo' beEmpty\n        )\n    ]\n}\n</code></pre>"},{"location":"quick-start/#testing-your-own-code","title":"Testing Your Own Code","text":"<p>Here's a complete example testing a simple calculator:</p> <pre><code>// Calculator.fs\nmodule Calculator\n\nlet add x y = x + y\nlet subtract x y = x - y\nlet multiply x y = x * y\nlet divide x y =\n    if y = 0 then\n        invalidArg (nameof y) \"Cannot divide by zero\"\n    else\n        x / y\n</code></pre> <pre><code>// CalculatorSpecs.fs\nmodule CalculatorSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet calculatorSpecs =\n    spec {\n        describe \"Calculator\" [\n            describe \"add\" [\n                it \"adds positive numbers\" (fun () -&gt;\n                    expect (Calculator.add 2 3) |&gt; to' (equal 5)\n                )\n\n                it \"adds negative numbers\" (fun () -&gt;\n                    expect (Calculator.add -1 -2) |&gt; to' (equal -3)\n                )\n\n                it \"adds mixed numbers\" (fun () -&gt;\n                    expect (Calculator.add 10 -5) |&gt; to' (equal 5)\n                )\n            ]\n\n            describe \"divide\" [\n                it \"divides evenly\" (fun () -&gt;\n                    expect (Calculator.divide 10 2) |&gt; to' (equal 5)\n                )\n\n                it \"raises exception on division by zero\" (fun () -&gt;\n                    let action () = Calculator.divide 10 0\n                    expect action |&gt; to' raiseException\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"quick-start/#running-tests","title":"Running Tests","text":""},{"location":"quick-start/#basic-run","title":"Basic Run","text":"<pre><code>dotnet run\n</code></pre>"},{"location":"quick-start/#run-specific-tests","title":"Run Specific Tests","text":"<pre><code>dotnet run -- --filter \"Calculator\"\n</code></pre>"},{"location":"quick-start/#choose-output-format","title":"Choose Output Format","text":"<pre><code># Documentation format (default, colorful)\ndotnet run -- --format documentation\n\n# Simple format (plain text)\ndotnet run -- --format simple\n</code></pre>"},{"location":"quick-start/#whats-next","title":"What's Next?","text":"<p>You now have a solid foundation in FxSpec. Continue learning:</p> <ul> <li> <p> DSL API Reference</p> <p>Complete reference for all DSL functions</p> </li> <li> <p> Core Matchers</p> <p>Learn about all available matchers</p> </li> <li> <p> Contributing</p> <p>Help improve FxSpec</p> </li> </ul>"},{"location":"quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quick-start/#tests-not-discovered","title":"Tests Not Discovered","text":"<p>Make sure your test module has the <code>[&lt;Tests&gt;]</code> attribute:</p> <pre><code>[&lt;Tests&gt;]  // Don't forget this!\nlet mySpecs = spec { ... }\n</code></pre>"},{"location":"quick-start/#compilation-errors","title":"Compilation Errors","text":"<p>Common issues:</p> <ol> <li>Missing opens: Make sure you have both <code>open FxSpec.Core</code> and <code>open FxSpec.Matchers</code></li> <li>Wrong matcher type: Matchers are type-constrained. You can't use <code>beEmpty</code> on a number, for example.</li> <li>Missing parentheses: Remember to wrap your test in <code>fun () -&gt;</code> for lazy evaluation</li> </ol>"},{"location":"quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Open an issue on GitHub</li> <li>Check existing issues for similar problems</li> <li>Read the Contributing Guide to submit bug reports</li> </ul>"},{"location":"community/contributing/","title":"Contributing to FxSpec","text":"<p>Thank you for your interest in contributing to FxSpec! This document provides guidelines and instructions for contributing.</p>"},{"location":"community/contributing/#getting-started","title":"Getting Started","text":""},{"location":"community/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8.0 or .NET 9.0 SDK</li> <li>F# 8.0+ (included with .NET SDK)</li> <li>Git</li> <li>Basic F# knowledge</li> <li>Familiarity with BDD testing concepts</li> </ul>"},{"location":"community/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li>Fork and clone the repository:</li> </ol> <pre><code>git clone https://github.com/yourorg/fx-spec.git\ncd fx-spec\n</code></pre> <ol> <li>Build the solution:</li> </ol> <pre><code>dotnet build\n</code></pre> <ol> <li>Run the tests:</li> </ol> <pre><code>./run-tests.sh\n</code></pre> <p>You should see all tests passing. FxSpec uses itself for testing (dogfooding).</p>"},{"location":"community/contributing/#building-the-project","title":"Building the Project","text":""},{"location":"community/contributing/#project-structure","title":"Project Structure","text":"<pre><code>fx-spec/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 FxSpec.Core/          # Core DSL and test tree\n\u2502   \u251c\u2500\u2500 FxSpec.Matchers/      # Assertion matchers\n\u2502   \u2514\u2500\u2500 FxSpec.Runner/        # Test discovery and execution\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 FxSpec.Core.Tests/    # Tests for Core\n\u2502   \u2514\u2500\u2500 FxSpec.Matchers.Tests/# Tests for Matchers\n\u251c\u2500\u2500 examples/                  # Example usage\n\u2514\u2500\u2500 docs/                      # Documentation\n</code></pre>"},{"location":"community/contributing/#build-commands","title":"Build Commands","text":"<pre><code># Build everything\ndotnet build\n\n# Build specific project\ndotnet build src/FxSpec.Core/FxSpec.Core.fsproj\n\n# Clean build\ndotnet clean\ndotnet build\n\n# Release build\ndotnet build -c Release\n</code></pre>"},{"location":"community/contributing/#running-tests","title":"Running Tests","text":"<p>FxSpec tests itself using its own framework.</p>"},{"location":"community/contributing/#run-all-tests","title":"Run All Tests","text":"<pre><code>./run-tests.sh\n</code></pre>"},{"location":"community/contributing/#run-specific-tests","title":"Run Specific Tests","text":"<pre><code># Filter by test description\n./run-tests.sh --filter \"SpecBuilder\"\n\n# Use simple formatter\n./run-tests.sh --format simple\n</code></pre>"},{"location":"community/contributing/#run-tests-manually","title":"Run Tests Manually","text":"<pre><code># Build and run\ndotnet build tests/FxSpec.Core.Tests/FxSpec.Core.Tests.fsproj\ndotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n  tests/FxSpec.Core.Tests/bin/Debug/net9.0/FxSpec.Core.Tests.dll\n</code></pre>"},{"location":"community/contributing/#code-style","title":"Code Style","text":""},{"location":"community/contributing/#f-conventions","title":"F# Conventions","text":"<p>FxSpec follows standard F# conventions:</p> <ul> <li>Naming:</li> <li><code>camelCase</code> for functions and values</li> <li><code>PascalCase</code> for types, modules, and DU cases</li> <li> <p>Prefix private functions with <code>private</code> keyword</p> </li> <li> <p>Code Organization:</p> </li> <li>Group related functions together</li> <li>Use <code>/// XML comments</code> for public APIs</li> <li> <p>Keep functions focused and small (prefer &lt; 25 lines)</p> </li> <li> <p>Pattern Matching:</p> </li> <li>Use <code>function</code> shorthand for single-argument pattern matching</li> <li>Match exhaustively (compiler enforces this)</li> <li>Put most common cases first</li> </ul>"},{"location":"community/contributing/#example","title":"Example","text":"<pre><code>/// Builds the full path to a test node.\nlet rec buildTestPath (path: string list) (node: TestResultNode) : (string * TestResult * TimeSpan) list =\n    match node with\n    | ExampleResult (desc, result, duration) -&gt;\n        let fullPath = (path @ [desc]) |&gt; String.concat \" &gt; \"\n        [(fullPath, result, duration)]\n    | GroupResult (desc, children) -&gt;\n        let newPath = path @ [desc]\n        children |&gt; List.collect (buildTestPath newPath)\n</code></pre>"},{"location":"community/contributing/#code-quality","title":"Code Quality","text":"<ul> <li>No compiler warnings: Code must compile without warnings</li> <li>Follow best practices:</li> <li>Prefer pure functions</li> <li>Minimize mutable state</li> <li>Use type constraints appropriately</li> <li>Avoid magic numbers (use named constants)</li> <li>Write tests: All new features must have tests</li> <li>Document public APIs: Use XML comments for all public functions</li> </ul>"},{"location":"community/contributing/#making-changes","title":"Making Changes","text":""},{"location":"community/contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n# or\ngit checkout -b fix/bug-description\n</code></pre>"},{"location":"community/contributing/#branch-naming","title":"Branch Naming","text":"<ul> <li><code>feature/</code> - New features</li> <li><code>fix/</code> - Bug fixes</li> <li><code>docs/</code> - Documentation changes</li> <li><code>refactor/</code> - Code refactoring</li> </ul>"},{"location":"community/contributing/#2-write-code","title":"2. Write Code","text":"<ul> <li>Follow F# conventions and code style</li> <li>Add tests for new functionality</li> <li>Update documentation if needed</li> </ul>"},{"location":"community/contributing/#3-write-tests","title":"3. Write Tests","text":"<p>All code changes must include tests. FxSpec tests itself:</p> <pre><code>module MyNewFeatureSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet myNewFeatureSpecs =\n    spec {\n        describe \"MyNewFeature\" [\n            it \"works as expected\" (fun () -&gt;\n                let result = MyNewFeature.doSomething()\n                expect result |&gt; to' (equal expectedValue)\n            )\n        ]\n    }\n</code></pre>"},{"location":"community/contributing/#4-run-tests","title":"4. Run Tests","text":"<pre><code>./run-tests.sh\n</code></pre> <p>All tests must pass before submitting a pull request.</p>"},{"location":"community/contributing/#5-commit-changes","title":"5. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"feat: add new feature description\"\n</code></pre>"},{"location":"community/contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commits format:</p> <pre><code>type(scope): description\n\n[optional body]\n</code></pre> <p>Types: - <code>feat:</code> - New feature - <code>fix:</code> - Bug fix - <code>docs:</code> - Documentation changes - <code>refactor:</code> - Code refactoring - <code>test:</code> - Adding or updating tests - <code>chore:</code> - Maintenance tasks</p> <p>Examples:</p> <pre><code>feat(matchers): add bePositive and beNegative matchers\nfix(runner): handle null test descriptions correctly\ndocs(quick-start): update installation instructions\nrefactor(core): simplify test tree building\n</code></pre>"},{"location":"community/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"community/contributing/#1-push-your-branch","title":"1. Push Your Branch","text":"<pre><code>git push origin feature/my-new-feature\n</code></pre>"},{"location":"community/contributing/#2-open-pull-request","title":"2. Open Pull Request","text":"<ul> <li>Go to GitHub and open a pull request</li> <li>Fill in the PR template</li> <li>Link any related issues</li> </ul>"},{"location":"community/contributing/#pr-title","title":"PR Title","text":"<p>Follow the same format as commit messages:</p> <pre><code>feat(matchers): add numeric comparison matchers\nfix(runner): prevent crash on empty test suite\n</code></pre>"},{"location":"community/contributing/#pr-description","title":"PR Description","text":"<p>Include:</p> <ul> <li>What: What changes did you make?</li> <li>Why: Why are these changes needed?</li> <li>How: How did you implement the changes?</li> <li>Testing: How did you test the changes?</li> </ul>"},{"location":"community/contributing/#example-pr-description","title":"Example PR Description","text":"<pre><code>## What\n\nAdd `bePositive`, `beNegative`, and `beZero` matchers for numeric comparisons.\n\n## Why\n\nUsers need a convenient way to test if numbers are positive, negative, or zero without writing custom matchers or using comparison operators.\n\n## How\n\n- Added three new matchers in `NumericMatchers.fs`\n- Used inline functions with generic numeric constraints\n- Leveraged `LanguagePrimitives.GenericZero`\n\n## Testing\n\n- Added comprehensive tests in `NumericMatchersSpecs.fs`\n- Tested with int, float, and decimal types\n- All 166 tests passing\n</code></pre>"},{"location":"community/contributing/#3-code-review","title":"3. Code Review","text":"<ul> <li>Address reviewer feedback</li> <li>Update code as needed</li> <li>Push changes to the same branch</li> <li>PR will update automatically</li> </ul>"},{"location":"community/contributing/#4-merge","title":"4. Merge","text":"<p>Once approved: - Squash and merge (preferred) - Merge commit (for multi-commit features) - Rebase and merge (for clean history)</p>"},{"location":"community/contributing/#areas-to-contribute","title":"Areas to Contribute","text":""},{"location":"community/contributing/#matchers","title":"Matchers","text":"<p>We always welcome new matchers! Ideas:</p> <ul> <li>DateTime matchers: <code>beToday</code>, <code>beBefore</code>, <code>beAfter</code>, <code>beInYear</code></li> <li>Async matchers: Matchers for <code>Async&lt;'T&gt;</code> and <code>Task&lt;'T&gt;</code></li> <li>File/IO matchers: <code>fileExist</code>, <code>directoryExist</code>, <code>haveExtension</code></li> <li>JSON matchers: Matchers for JSON comparison</li> </ul>"},{"location":"community/contributing/#formatters","title":"Formatters","text":"<ul> <li>Alternative output formats (JSON, JUnit XML, TAP)</li> <li>Integration with test reporting tools</li> <li>VS Code extension support</li> </ul>"},{"location":"community/contributing/#documentation","title":"Documentation","text":"<ul> <li>Tutorial content</li> <li>How-to guides</li> <li>Example projects</li> <li>Blog posts</li> </ul>"},{"location":"community/contributing/#bug-fixes","title":"Bug Fixes","text":"<p>Check open issues for bugs to fix.</p>"},{"location":"community/contributing/#documentation_1","title":"Documentation","text":""},{"location":"community/contributing/#building-documentation","title":"Building Documentation","text":"<p>Documentation uses Material for MkDocs:</p> <pre><code># Install dependencies (first time only)\nuv venv\nuv pip install mkdocs-material mkdocs-mermaid2-plugin\n\n# Serve locally\nuv run mkdocs serve\n\n# Open http://127.0.0.1:8000\n</code></pre>"},{"location":"community/contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Add practical use cases</li> <li>Follow existing structure</li> </ul> <p>Documentation structure follows the Di\u00e1taxis framework:</p> <ul> <li>Tutorials: Learning-oriented lessons</li> <li>How-To Guides: Task-oriented directions</li> <li>Reference: Information-oriented descriptions</li> <li>Explanation: Understanding-oriented discussions</li> </ul>"},{"location":"community/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"community/contributing/#test-organization","title":"Test Organization","text":"<pre><code>spec {\n    describe \"FeatureName\" [\n        context \"when specific condition\" [\n            it \"behaves in expected way\" (fun () -&gt;\n                // Arrange\n                let input = setupTestData()\n\n                // Act\n                let result = performOperation(input)\n\n                // Assert\n                expect result |&gt; to' (equal expectedValue)\n            )\n        ]\n    ]\n}\n</code></pre>"},{"location":"community/contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Test happy paths</li> <li>Test edge cases</li> <li>Test error conditions</li> <li>Test boundary values</li> </ul>"},{"location":"community/contributing/#good-test-examples","title":"Good Test Examples","text":"<pre><code>// Good: Clear, focused, descriptive\nit \"adds two positive numbers\" (fun () -&gt;\n    expect (Calculator.add 2 3) |&gt; to' (equal 5)\n)\n\n// Good: Tests edge case\nit \"handles division by zero\" (fun () -&gt;\n    expect (fun () -&gt; Calculator.divide 10 0) |&gt; to' raiseException\n)\n\n// Less good: Unclear what's being tested\nit \"test1\" (fun () -&gt;\n    expect (doSomething()) |&gt; to' (equal 42)\n)\n</code></pre>"},{"location":"community/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Questions: Open a discussion</li> <li>Bugs: Open an issue</li> <li>Chat: Join our community chat (link TBD)</li> </ul>"},{"location":"community/contributing/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"community/contributing/#our-standards","title":"Our Standards","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Accept constructive criticism</li> <li>Focus on what's best for the community</li> <li>Show empathy</li> </ul>"},{"location":"community/contributing/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>Harassment or discrimination</li> <li>Trolling or insulting comments</li> <li>Personal or political attacks</li> <li>Publishing others' private information</li> </ul>"},{"location":"community/contributing/#enforcement","title":"Enforcement","text":"<p>Violations may result in temporary or permanent ban from the project.</p>"},{"location":"community/contributing/#license","title":"License","text":"<p>By contributing to FxSpec, you agree that your contributions will be licensed under the same license as the project (MIT License).</p>"},{"location":"community/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>GitHub contributors list</li> <li>Release notes</li> <li>Project documentation</li> </ul> <p>Thank you for contributing to FxSpec!</p>"},{"location":"reference/","title":"Reference Documentation","text":"<p>Complete API reference for FxSpec.</p>"},{"location":"reference/#quick-links","title":"Quick Links","text":"<ul> <li> <p> DSL API</p> <p>Complete reference for <code>spec</code>, <code>describe</code>, <code>it</code>, <code>context</code>, and all DSL functions.</p> </li> <li> <p> Matchers</p> <p>All available matchers organized by category.</p> </li> </ul>"},{"location":"reference/#api-categories","title":"API Categories","text":""},{"location":"reference/#core-dsl","title":"Core DSL","text":"<ul> <li>spec - Computation expression builder for test trees</li> <li>describe - Group related tests</li> <li>context - Add context to test groups (alias for <code>describe</code>)</li> <li>it - Define individual test cases</li> </ul>"},{"location":"reference/#focus-pending","title":"Focus &amp; Pending","text":"<ul> <li>fit - Focus on specific test</li> <li>fdescribe - Focus on test group</li> <li>xit - Skip a test</li> <li>pending - Mark test as pending (alias for <code>xit</code>)</li> </ul>"},{"location":"reference/#hooks","title":"Hooks","text":"<ul> <li>beforeEach - Run before each test</li> <li>afterEach - Run after each test</li> <li>beforeAll - Run once before all tests in group</li> <li>afterAll - Run once after all tests in group</li> </ul>"},{"location":"reference/#assertions","title":"Assertions","text":"<ul> <li>expect - Start an assertion</li> <li>to' - Apply a matcher (positive assertion)</li> <li>notTo' - Apply a matcher (negative assertion)</li> </ul>"},{"location":"reference/#matcher-categories","title":"Matcher Categories","text":""},{"location":"reference/#core-matchers","title":"Core Matchers","text":"<p>Basic equality, null checks, boolean, and option matchers.</p>"},{"location":"reference/#collection-matchers","title":"Collection Matchers","text":"<p>Matchers for lists, arrays, sequences, and other collections.</p>"},{"location":"reference/#string-matchers","title":"String Matchers","text":"<p>String-specific matchers for prefixes, suffixes, patterns, and more.</p>"},{"location":"reference/#numeric-matchers","title":"Numeric Matchers","text":"<p>Numeric comparisons and range checks.</p>"},{"location":"reference/#exception-matchers","title":"Exception Matchers","text":"<p>Testing exception throwing behavior.</p>"},{"location":"reference/dsl-api/","title":"DSL API Reference","text":"<p>Complete reference for FxSpec's Domain-Specific Language functions.</p>"},{"location":"reference/dsl-api/#overview","title":"Overview","text":"<p>FxSpec uses an F# computation expression (<code>spec</code>) to build test trees. The DSL provides functions for organizing tests, defining test cases, and managing test lifecycle.</p>"},{"location":"reference/dsl-api/#core-functions","title":"Core Functions","text":""},{"location":"reference/dsl-api/#spec","title":"spec","text":"<p>Type: <code>SpecBuilder</code></p> <p>The computation expression builder that creates test trees.</p> <p>Usage:</p> <pre><code>spec {\n    // Your test definitions\n}\n</code></pre> <p>Example:</p> <pre><code>[&lt;Tests&gt;]\nlet myTests =\n    spec {\n        describe \"Feature\" [\n            it \"works\" (fun () -&gt;\n                expect true |&gt; to' beTrue\n            )\n        ]\n    }\n</code></pre> <p>Notes:</p> <ul> <li>All tests must be wrapped in a <code>spec { }</code> block</li> <li>The <code>spec</code> builder creates an immutable test tree</li> <li>Tests are not executed during building, only when the runner executes them</li> <li>Mark test functions with <code>[&lt;Tests&gt;]</code> attribute for discovery</li> </ul>"},{"location":"reference/dsl-api/#describe","title":"describe","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Groups related tests together with a description.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the group</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>describe \"description\" [\n    // child tests\n]\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"Calculator\" [\n        describe \"addition\" [\n            it \"adds positive numbers\" (fun () -&gt;\n                expect (2 + 3) |&gt; to' (equal 5)\n            )\n        ]\n\n        describe \"subtraction\" [\n            it \"subtracts numbers\" (fun () -&gt;\n                expect (5 - 3) |&gt; to' (equal 2)\n            )\n        ]\n    ]\n}\n</code></pre> <p>Output:</p> <pre><code>Calculator\n  addition\n    \u2713 adds positive numbers\n  subtraction\n    \u2713 subtracts numbers\n</code></pre> <p>Notes:</p> <ul> <li><code>describe</code> blocks can be nested arbitrarily deep</li> <li>Use <code>describe</code> for grouping by feature, class, or module</li> <li>Descriptions should be clear and descriptive</li> </ul>"},{"location":"reference/dsl-api/#context","title":"context","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Alias for <code>describe</code> that reads better when describing context or state.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the context</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>context \"when something is true\" [\n    // tests in this context\n]\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"Stack\" [\n        context \"when empty\" [\n            it \"has zero count\" (fun () -&gt;\n                let stack = Stack&lt;int&gt;()\n                expect stack.Count |&gt; to' (equal 0)\n            )\n        ]\n\n        context \"when not empty\" [\n            it \"has non-zero count\" (fun () -&gt;\n                let stack = Stack&lt;int&gt;()\n                stack.Push(1)\n                expect stack.Count |&gt; to' (equal 1)\n            )\n        ]\n    ]\n}\n</code></pre> <p>Notes:</p> <ul> <li>Functionally identical to <code>describe</code></li> <li>Use <code>context</code> for \"when\" or \"with\" scenarios</li> <li>Improves readability in BDD-style tests</li> </ul>"},{"location":"reference/dsl-api/#it","title":"it","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Defines an individual test case.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing what the test does</li> <li><code>test</code> - Function that performs assertions</li> </ul> <p>Usage:</p> <pre><code>it \"description\" (fun () -&gt;\n    // test code and assertions\n)\n</code></pre> <p>Example:</p> <pre><code>it \"adds two numbers\" (fun () -&gt;\n    let result = Calculator.add 2 3\n    expect result |&gt; to' (equal 5)\n)\n</code></pre> <p>Notes:</p> <ul> <li>Test function must be wrapped in <code>fun () -&gt;</code> for lazy evaluation</li> <li>Descriptions should start with a verb (e.g., \"returns\", \"throws\", \"creates\")</li> <li>Tests should focus on one behavior</li> <li>If the test function throws an exception, the test fails</li> </ul>"},{"location":"reference/dsl-api/#focus-pending","title":"Focus &amp; Pending","text":""},{"location":"reference/dsl-api/#fit","title":"fit","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Focused test - runs only this test when focused tests exist.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function that performs assertions</li> </ul> <p>Usage:</p> <pre><code>fit \"only run this test\" (fun () -&gt;\n    expect true |&gt; to' beTrue\n)\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"My Suite\" [\n        fit \"work on this test\" (fun () -&gt;  // Only this runs\n            expect (2 + 2) |&gt; to' (equal 4)\n        )\n\n        it \"this is skipped\" (fun () -&gt;    // Skipped\n            expect true |&gt; to' beTrue\n        )\n    ]\n}\n</code></pre> <p>Output:</p> <pre><code>My Suite\n  \u2713 work on this test\n  \u2298 this is skipped (not focused)\n</code></pre> <p>Notes:</p> <ul> <li>Use during development to focus on specific tests</li> <li>When any <code>fit</code> or <code>fdescribe</code> exists, unfocused tests are skipped</li> <li>Remove all <code>fit</code> before committing code</li> <li>Multiple <code>fit</code> tests can exist - all focused tests run</li> </ul>"},{"location":"reference/dsl-api/#fdescribe","title":"fdescribe","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Focused group - runs only tests in focused groups.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the group</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>fdescribe \"only run this group\" [\n    // all tests in this group run\n]\n</code></pre> <p>Example:</p> <pre><code>spec {\n    fdescribe \"Work on Calculator\" [  // This group runs\n        it \"test 1\" (fun () -&gt;\n            expect true |&gt; to' beTrue\n        )\n        it \"test 2\" (fun () -&gt;\n            expect true |&gt; to' beTrue\n        )\n    ]\n\n    describe \"Other Feature\" [        // This group is skipped\n        it \"test 3\" (fun () -&gt;\n            expect true |&gt; to' beTrue\n        )\n    ]\n}\n</code></pre> <p>Notes:</p> <ul> <li>All tests within <code>fdescribe</code> run</li> <li>Tests outside <code>fdescribe</code> are skipped</li> <li>Can be nested - inner <code>fdescribe</code> focuses further</li> <li>Remove before committing</li> </ul>"},{"location":"reference/dsl-api/#xit","title":"xit","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Excluded test - skips this test.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function (not executed)</li> </ul> <p>Usage:</p> <pre><code>xit \"not ready yet\" (fun () -&gt;\n    // this code doesn't run\n)\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"Feature\" [\n        it \"working test\" (fun () -&gt;\n            expect true |&gt; to' beTrue\n        )\n\n        xit \"broken test\" (fun () -&gt;  // Skipped\n            expect false |&gt; to' beTrue\n        )\n    ]\n}\n</code></pre> <p>Output:</p> <pre><code>Feature\n  \u2713 working test\n  \u2298 broken test\n</code></pre> <p>Notes:</p> <ul> <li>Use for temporarily disabling broken tests</li> <li>Test function is never executed</li> <li>Skipped tests are reported in the summary</li> <li>Better than commenting out tests (maintains test count)</li> </ul>"},{"location":"reference/dsl-api/#pending","title":"pending","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Alias for <code>xit</code> that reads better for unfinished tests.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function (not executed)</li> </ul> <p>Usage:</p> <pre><code>pending \"TODO: implement this test\" (fun () -&gt;\n    ()\n)\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"Feature\" [\n        it \"implemented test\" (fun () -&gt;\n            expect true |&gt; to' beTrue\n        )\n\n        pending \"write test for edge case\" (fun () -&gt;\n            ()\n        )\n    ]\n}\n</code></pre> <p>Notes:</p> <ul> <li>Functionally identical to <code>xit</code></li> <li>Use for planned but unimplemented tests</li> <li>Can pass empty function <code>(fun () -&gt; ())</code></li> </ul>"},{"location":"reference/dsl-api/#lifecycle-hooks","title":"Lifecycle Hooks","text":""},{"location":"reference/dsl-api/#beforeeach","title":"beforeEach","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs before each test in the current group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run before each test</li> </ul> <p>Usage:</p> <pre><code>beforeEach (fun () -&gt;\n    // setup code\n)\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"Database Tests\" [\n        let mutable connection = null\n\n        beforeEach (fun () -&gt;\n            connection &lt;- Database.connect()\n            connection.BeginTransaction()\n        )\n\n        afterEach (fun () -&gt;\n            connection.RollbackTransaction()\n            connection.Dispose()\n        )\n\n        it \"queries data\" (fun () -&gt;\n            let result = connection.Query(\"SELECT 1\")\n            expect result |&gt; notTo' beEmpty\n        )\n\n        it \"inserts data\" (fun () -&gt;\n            connection.Execute(\"INSERT INTO users VALUES (1, 'test')\")\n            let count = connection.Query(\"SELECT COUNT(*) FROM users\")\n            expect count |&gt; to' (equal 1)\n        )\n    ]\n}\n</code></pre> <p>Execution Order:</p> <pre><code>beforeEach \u2192 test 1 \u2192 afterEach\nbeforeEach \u2192 test 2 \u2192 afterEach\n</code></pre> <p>Notes:</p> <ul> <li>Runs before each test in the group</li> <li>Useful for test isolation and setup</li> <li>Can access mutable variables from outer scope</li> <li>Multiple <code>beforeEach</code> hooks run in order of definition</li> </ul>"},{"location":"reference/dsl-api/#aftereach","title":"afterEach","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs after each test in the current group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run after each test</li> </ul> <p>Usage:</p> <pre><code>afterEach (fun () -&gt;\n    // cleanup code\n)\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"File Tests\" [\n        let testFile = \"test.txt\"\n\n        beforeEach (fun () -&gt;\n            File.WriteAllText(testFile, \"test content\")\n        )\n\n        afterEach (fun () -&gt;\n            if File.Exists(testFile) then\n                File.Delete(testFile)\n        )\n\n        it \"reads file\" (fun () -&gt;\n            let content = File.ReadAllText(testFile)\n            expect content |&gt; to' (equal \"test content\")\n        )\n    ]\n}\n</code></pre> <p>Notes:</p> <ul> <li>Runs after each test, even if test fails</li> <li>Use for cleanup and resource disposal</li> <li>Guaranteed to run (unless unhandled exception in beforeEach)</li> </ul>"},{"location":"reference/dsl-api/#beforeall","title":"beforeAll","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs once before all tests in the group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run once before tests</li> </ul> <p>Usage:</p> <pre><code>beforeAll (fun () -&gt;\n    // expensive setup\n)\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"API Tests\" [\n        let mutable server = null\n\n        beforeAll (fun () -&gt;\n            server &lt;- TestServer.start()\n            server.SeedDatabase()\n        )\n\n        afterAll (fun () -&gt;\n            server.Stop()\n        )\n\n        it \"test 1\" (fun () -&gt;\n            let response = server.Get(\"/api/users\")\n            expect response.Status |&gt; to' (equal 200)\n        )\n\n        it \"test 2\" (fun () -&gt;\n            let response = server.Post(\"/api/users\", { Name = \"test\" })\n            expect response.Status |&gt; to' (equal 201)\n        )\n    ]\n}\n</code></pre> <p>Execution Order:</p> <pre><code>beforeAll \u2192 test 1 \u2192 test 2 \u2192 afterAll\n</code></pre> <p>Notes:</p> <ul> <li>Runs only once before all tests in the group</li> <li>Use for expensive setup (database seeding, server start, etc.)</li> <li>Shared state across tests (be careful of test isolation)</li> </ul>"},{"location":"reference/dsl-api/#afterall","title":"afterAll","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs once after all tests in the group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run once after all tests</li> </ul> <p>Usage:</p> <pre><code>afterAll (fun () -&gt;\n    // cleanup expensive resources\n)\n</code></pre> <p>Example:</p> <pre><code>spec {\n    describe \"Integration Tests\" [\n        let mutable dockerContainer = null\n\n        beforeAll (fun () -&gt;\n            dockerContainer &lt;- Docker.startContainer(\"postgres:15\")\n        )\n\n        afterAll (fun () -&gt;\n            Docker.stopContainer(dockerContainer)\n        )\n\n        // tests...\n    ]\n}\n</code></pre> <p>Notes:</p> <ul> <li>Runs only once after all tests in the group</li> <li>Use for expensive cleanup</li> <li>Guaranteed to run even if tests fail</li> </ul>"},{"location":"reference/dsl-api/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive example using all DSL features:</p> <pre><code>module UserServiceSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet userServiceSpecs =\n    spec {\n        describe \"UserService\" [\n            let mutable service = null\n            let mutable db = null\n\n            beforeAll (fun () -&gt;\n                db &lt;- Database.createInMemory()\n            )\n\n            afterAll (fun () -&gt;\n                db.Dispose()\n            )\n\n            beforeEach (fun () -&gt;\n                db.Clear()\n                service &lt;- UserService(db)\n            )\n\n            describe \"CreateUser\" [\n                context \"when valid data is provided\" [\n                    it \"creates a new user\" (fun () -&gt;\n                        let user = service.CreateUser(\"Alice\", \"alice@example.com\")\n                        expect user.Name |&gt; to' (equal \"Alice\")\n                        expect user.Email |&gt; to' (equal \"alice@example.com\")\n                    )\n\n                    it \"assigns a unique ID\" (fun () -&gt;\n                        let user = service.CreateUser(\"Bob\", \"bob@example.com\")\n                        expect user.Id |&gt; to' (beGreaterThan 0)\n                    )\n                ]\n\n                context \"when invalid data is provided\" [\n                    it \"raises exception for empty name\" (fun () -&gt;\n                        let action () = service.CreateUser(\"\", \"test@example.com\")\n                        expect action |&gt; to' raiseException\n                    )\n\n                    xit \"validates email format\" (fun () -&gt;\n                        // TODO: implement email validation\n                        let action () = service.CreateUser(\"Test\", \"invalid-email\")\n                        expect action |&gt; to' raiseException\n                    )\n                ]\n            ]\n\n            describe \"GetUser\" [\n                it \"returns existing user\" (fun () -&gt;\n                    let created = service.CreateUser(\"Charlie\", \"charlie@example.com\")\n                    let retrieved = service.GetUser(created.Id)\n                    expect retrieved |&gt; to' (beSome created)\n                )\n\n                it \"returns None for non-existent user\" (fun () -&gt;\n                    let result = service.GetUser(9999)\n                    expect result |&gt; to' beNone\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/dsl-api/#best-practices","title":"Best Practices","text":""},{"location":"reference/dsl-api/#naming-conventions","title":"Naming Conventions","text":"<pre><code>// Good\ndescribe \"UserService\"\nit \"creates a new user\"\ncontext \"when user is authenticated\"\n\n// Avoid\ndescribe \"Test Suite 1\"\nit \"test1\"\ncontext \"scenario A\"\n</code></pre>"},{"location":"reference/dsl-api/#test-organization","title":"Test Organization","text":"<pre><code>spec {\n    describe \"FeatureName\" [           // Top-level: feature/module/class\n        describe \"MethodOrFunction\" [   // Second-level: method/function\n            context \"when condition\" [  // Third-level: specific context\n                it \"expected behavior\" (fun () -&gt; ...)\n            ]\n        ]\n    ]\n}\n</code></pre>"},{"location":"reference/dsl-api/#hook-usage","title":"Hook Usage","text":"<ul> <li>Use <code>beforeEach</code>/<code>afterEach</code> for test isolation</li> <li>Use <code>beforeAll</code>/<code>afterAll</code> for expensive setup</li> <li>Keep hooks simple and focused</li> <li>Avoid complex logic in hooks</li> </ul>"},{"location":"reference/dsl-api/#focus-pending_1","title":"Focus &amp; Pending","text":"<ul> <li>Use <code>fit</code>/<code>fdescribe</code> temporarily during development</li> <li>Always remove before committing</li> <li>Use <code>xit</code>/<code>pending</code> to track incomplete tests</li> <li>Document why tests are pending</li> </ul>"},{"location":"reference/dsl-api/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Get started with FxSpec</li> <li>Matchers Reference - Learn about assertions</li> <li>Contributing - Contribute to FxSpec</li> </ul>"},{"location":"reference/matchers/collections/","title":"Collection Matchers","text":"<p>Matchers for lists, arrays, sequences, and other collections.</p>"},{"location":"reference/matchers/collections/#membership","title":"Membership","text":""},{"location":"reference/matchers/collections/#contain","title":"contain","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection contains the expected item.</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (contain item)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3] |&gt; to' (contain 2)\nexpect [|\"a\"; \"b\"; \"c\"|] |&gt; to' (contain \"b\")\nexpect (seq { 1..10 }) |&gt; to' (contain 5)\n\n// With custom types\ntype Person = { Name: string }\nlet people = [{ Name = \"Alice\" }; { Name = \"Bob\" }]\nexpect people |&gt; to' (contain { Name = \"Alice\" })\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' (contain 5)\n// =&gt; Expected collection to contain 5, but it did not. Collection: [1; 2; 3]\n</code></pre>"},{"location":"reference/matchers/collections/#containall","title":"containAll","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection contains all expected items (in any order).</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (containAll expected)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; to' (containAll [2; 4])\nexpect [1; 2; 3; 4; 5] |&gt; to' (containAll [5; 1; 3])  // Order doesn't matter\nexpect [\"a\"; \"b\"; \"c\"; \"d\"] |&gt; to' (containAll [\"c\"; \"a\"])\n\n// Empty expected list always passes\nexpect [1; 2; 3] |&gt; to' (containAll [])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' (containAll [2; 5; 7])\n// =&gt; Expected collection to contain all of [2; 5; 7], but missing: [5; 7]\n</code></pre>"},{"location":"reference/matchers/collections/#size","title":"Size","text":""},{"location":"reference/matchers/collections/#beempty","title":"beEmpty","text":"<p>Type: <code>Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection is empty.</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' beEmpty\n</code></pre> <p>Examples:</p> <pre><code>expect [] |&gt; to' beEmpty\nexpect [||] |&gt; to' beEmpty\nexpect Seq.empty |&gt; to' beEmpty\nexpect (List&lt;int&gt;()) |&gt; to' beEmpty\n\n// After operations\nlet filtered = [1; 2; 3] |&gt; List.filter (fun x -&gt; x &gt; 10)\nexpect filtered |&gt; to' beEmpty\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' beEmpty\n// =&gt; Expected empty collection, but found 3 items\n</code></pre>"},{"location":"reference/matchers/collections/#havelength","title":"haveLength","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has the expected length.</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (haveLength count)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3] |&gt; to' (haveLength 3)\nexpect [|\"a\"; \"b\"|] |&gt; to' (haveLength 2)\nexpect \"hello\" |&gt; to' (haveLength 5)  // Strings are sequences of chars\n\n// With operations\nlet doubled = [1; 2; 3] |&gt; List.map (fun x -&gt; x * 2)\nexpect doubled |&gt; to' (haveLength 3)\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' (haveLength 5)\n// =&gt; Expected collection to have length 5, but found length 3\n</code></pre> <p>Notes:</p> <ul> <li>Validates that expected length is non-negative</li> <li>Works with any <code>seq&lt;'a&gt;</code></li> <li>For strings, use <code>haveStringLength</code> for better error messages</li> </ul>"},{"location":"reference/matchers/collections/#havecountatleast","title":"haveCountAtLeast","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has at least the expected count.</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (haveCountAtLeast minimum)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; to' (haveCountAtLeast 3)  // Passes (5 &gt;= 3)\nexpect [1; 2] |&gt; to' (haveCountAtLeast 2)  // Passes (2 &gt;= 2)\nexpect [1] |&gt; to' (haveCountAtLeast 5)  // Fails (1 &lt; 5)\n\n// Useful for pagination\nlet page = database.Query().Take(10)\nexpect page |&gt; to' (haveCountAtLeast 1)  // At least one result\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2] |&gt; to' (haveCountAtLeast 5)\n// =&gt; Expected collection to have at least 5 items, but found 2\n</code></pre>"},{"location":"reference/matchers/collections/#havecountatmost","title":"haveCountAtMost","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has at most the expected count.</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (haveCountAtMost maximum)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2] |&gt; to' (haveCountAtMost 5)  // Passes (2 &lt;= 5)\nexpect [1; 2; 3] |&gt; to' (haveCountAtMost 3)  // Passes (3 &lt;= 3)\nexpect [1; 2; 3; 4; 5] |&gt; to' (haveCountAtMost 3)  // Fails (5 &gt; 3)\n\n// Useful for limiting results\nlet recent = events |&gt; List.take 100\nexpect recent |&gt; to' (haveCountAtMost 100)\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; to' (haveCountAtMost 3)\n// =&gt; Expected collection to have at most 3 items, but found 5\n</code></pre>"},{"location":"reference/matchers/collections/#sequences","title":"Sequences","text":""},{"location":"reference/matchers/collections/#equalseq","title":"equalSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection equals the expected sequence (same order, same values).</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (equalSeq expected)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3] |&gt; to' (equalSeq [1; 2; 3])\nexpect [|\"a\"; \"b\"|] |&gt; to' (equalSeq [\"a\"; \"b\"])  // Arrays and lists can be compared\n\n// Order matters!\nexpect [1; 2; 3] |&gt; notTo' (equalSeq [3; 2; 1])\nexpect [1; 2; 3] |&gt; notTo' (equalSeq [1; 3; 2])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' (equalSeq [1; 2; 4])\n// =&gt; Expected sequence [1; 2; 4], but found [1; 2; 3]\n</code></pre> <p>Notes:</p> <ul> <li>Order matters (unlike <code>containAll</code>)</li> <li>Use <code>equal</code> for structural equality (works with lists, arrays, etc.)</li> <li>Use <code>equalSeq</code> when comparing different collection types</li> </ul>"},{"location":"reference/matchers/collections/#startwithseq","title":"startWithSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection starts with the expected sequence.</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (startWithSeq prefix)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; to' (startWithSeq [1; 2])\nexpect [1; 2; 3; 4; 5] |&gt; to' (startWithSeq [1; 2; 3])\nexpect [1; 2; 3; 4; 5] |&gt; to' (startWithSeq [])  // Empty prefix always matches\n\n// Fails\nexpect [1; 2; 3; 4; 5] |&gt; notTo' (startWithSeq [2; 3])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' (startWithSeq [2; 3])\n// =&gt; Expected sequence to start with [2; 3], but found [1; 2]\n</code></pre>"},{"location":"reference/matchers/collections/#endwithseq","title":"endWithSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection ends with the expected sequence.</p> <p>Usage:</p> <pre><code>expect collection |&gt; to' (endWithSeq suffix)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; to' (endWithSeq [4; 5])\nexpect [1; 2; 3; 4; 5] |&gt; to' (endWithSeq [3; 4; 5])\nexpect [1; 2; 3; 4; 5] |&gt; to' (endWithSeq [])  // Empty suffix always matches\n\n// Fails\nexpect [1; 2; 3; 4; 5] |&gt; notTo' (endWithSeq [3; 4])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' (endWithSeq [2; 4])\n// =&gt; Expected sequence to end with [2; 4], but found [2; 3]\n</code></pre>"},{"location":"reference/matchers/collections/#predicates","title":"Predicates","text":""},{"location":"reference/matchers/collections/#allsatisfy","title":"allSatisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a seq&gt;)</code></p> <p>Matches if all items in the collection satisfy the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test each item</li> <li><code>description</code> - Human-readable description</li> </ul> <p>Usage:</p> <pre><code>expect collection |&gt; to' (allSatisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>expect [2; 4; 6; 8] |&gt; to' (allSatisfy (fun x -&gt; x % 2 = 0) \"be even\")\nexpect [\"hello\"; \"world\"] |&gt; to' (allSatisfy (fun s -&gt; s.Length &gt; 0) \"be non-empty\")\n\n// With domain logic\ntype User = { Name: string; Age: int }\nlet users = [\n    { Name = \"Alice\"; Age = 25 }\n    { Name = \"Bob\"; Age = 30 }\n]\nexpect users |&gt; to' (allSatisfy (fun u -&gt; u.Age &gt;= 18) \"be adults\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect [2; 3; 4; 5] |&gt; to' (allSatisfy (fun x -&gt; x % 2 = 0) \"be even\")\n// =&gt; Expected all items to satisfy 'be even', but these did not: [3; 5]\n</code></pre> <p>Notes:</p> <ul> <li>Shows up to 5 failing items in error message</li> <li>Empty collection always passes (vacuous truth)</li> <li>Use descriptive descriptions for clear error messages</li> </ul>"},{"location":"reference/matchers/collections/#anysatisfy","title":"anySatisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a seq&gt;)</code></p> <p>Matches if at least one item in the collection satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test each item</li> <li><code>description</code> - Human-readable description</li> </ul> <p>Usage:</p> <pre><code>expect collection |&gt; to' (anySatisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; to' (anySatisfy (fun x -&gt; x &gt; 3) \"be greater than 3\")\nexpect [\"hello\"; \"world\"; \"!\"] |&gt; to' (anySatisfy (fun s -&gt; s.Length = 1) \"be a single character\")\n\n// Searching\ntype Product = { Name: string; Price: decimal; InStock: bool }\nlet products = [\n    { Name = \"Laptop\"; Price = 999.99m; InStock = true }\n    { Name = \"Mouse\"; Price = 29.99m; InStock = false }\n]\nexpect products |&gt; to' (anySatisfy (fun p -&gt; p.InStock) \"be in stock\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; to' (anySatisfy (fun x -&gt; x &gt; 10) \"be greater than 10\")\n// =&gt; Expected at least one item to satisfy 'be greater than 10', but none did. Collection: [1; 2; 3]\n</code></pre> <p>Notes:</p> <ul> <li>Fails on empty collection (no items to satisfy)</li> <li>Short-circuits on first match (efficient for large collections)</li> <li>Shows collection contents in error message (up to 10 items)</li> </ul>"},{"location":"reference/matchers/collections/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/collections/#testing-a-shopping-cart","title":"Testing a Shopping Cart","text":"<pre><code>module ShoppingCartSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\ntype CartItem = { ProductId: int; Quantity: int; Price: decimal }\ntype Cart = { Items: CartItem list }\n\n[&lt;Tests&gt;]\nlet shoppingCartSpecs =\n    spec {\n        describe \"ShoppingCart\" [\n            describe \"addItem\" [\n                it \"adds item to empty cart\" (fun () -&gt;\n                    let cart = Cart.empty\n                    let updated = cart.AddItem({ ProductId = 1; Quantity = 2; Price = 10.00m })\n\n                    expect updated.Items |&gt; to' (haveLength 1)\n                    expect updated.Items |&gt; to' (contain { ProductId = 1; Quantity = 2; Price = 10.00m })\n                )\n\n                it \"increases quantity for existing item\" (fun () -&gt;\n                    let cart = { Items = [{ ProductId = 1; Quantity = 1; Price = 10.00m }] }\n                    let updated = cart.AddItem({ ProductId = 1; Quantity = 2; Price = 10.00m })\n\n                    expect updated.Items |&gt; to' (haveLength 1)\n                    expect updated.Items.[0].Quantity |&gt; to' (equal 3)\n                )\n            ]\n\n            describe \"removeItem\" [\n                it \"removes item from cart\" (fun () -&gt;\n                    let cart = {\n                        Items = [\n                            { ProductId = 1; Quantity = 1; Price = 10.00m }\n                            { ProductId = 2; Quantity = 1; Price = 20.00m }\n                        ]\n                    }\n                    let updated = cart.RemoveItem(1)\n\n                    expect updated.Items |&gt; to' (haveLength 1)\n                    expect updated.Items |&gt; to' (anySatisfy (fun item -&gt; item.ProductId = 2) \"contain product 2\")\n                    expect updated.Items |&gt; notTo' (anySatisfy (fun item -&gt; item.ProductId = 1) \"contain product 1\")\n                )\n            ]\n\n            describe \"total\" [\n                it \"calculates total price\" (fun () -&gt;\n                    let cart = {\n                        Items = [\n                            { ProductId = 1; Quantity = 2; Price = 10.00m }  // $20\n                            { ProductId = 2; Quantity = 1; Price = 30.00m }  // $30\n                        ]\n                    }\n                    let total = cart.Total()\n\n                    expect total |&gt; to' (equal 50.00m)\n                )\n\n                it \"returns zero for empty cart\" (fun () -&gt;\n                    let cart = Cart.empty\n                    expect cart.Total() |&gt; to' (equal 0.00m)\n                    expect cart.Items |&gt; to' beEmpty\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/collections/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality and type matchers</li> <li>String Matchers - String-specific matchers</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Quick Start - Get started with FxSpec</li> </ul>"},{"location":"reference/matchers/core/","title":"Core Matchers","text":"<p>Basic equality, null checks, boolean, Option, Result, and type matchers.</p>"},{"location":"reference/matchers/core/#assertions","title":"Assertions","text":""},{"location":"reference/matchers/core/#expect","title":"expect","text":"<p>Type: <code>'a -&gt; 'a</code></p> <p>Starts an assertion chain. Pass the actual value to test.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' matcher\nexpect actual |&gt; notTo' matcher\n</code></pre> <p>Example:</p> <pre><code>expect (2 + 2) |&gt; to' (equal 4)\nexpect \"hello\" |&gt; to' (startWith \"hel\")\nexpect [1; 2; 3] |&gt; to' (contain 2)\n</code></pre>"},{"location":"reference/matchers/core/#to","title":"to'","text":"<p>Type: <code>Matcher&lt;'a&gt; -&gt; 'a -&gt; unit</code></p> <p>Applies a matcher for positive assertion. Throws <code>AssertionException</code> if matcher fails.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' matcher\n</code></pre> <p>Example:</p> <pre><code>expect 10 |&gt; to' (beGreaterThan 5)\nexpect \"test\" |&gt; to' (haveStringLength 4)\n</code></pre>"},{"location":"reference/matchers/core/#notto","title":"notTo'","text":"<p>Type: <code>Matcher&lt;'a&gt; -&gt; 'a -&gt; unit</code></p> <p>Applies a matcher for negative assertion. Throws <code>AssertionException</code> if matcher passes.</p> <p>Usage:</p> <pre><code>expect actual |&gt; notTo' matcher\n</code></pre> <p>Example:</p> <pre><code>expect 5 |&gt; notTo' (equal 10)\nexpect \"hello\" |&gt; notTo' beEmptyString\nexpect [] |&gt; notTo' (contain 42)\n</code></pre>"},{"location":"reference/matchers/core/#equality","title":"Equality","text":""},{"location":"reference/matchers/core/#equal","title":"equal","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt;</code></p> <p>Matches if the actual value equals the expected value using F#'s structural equality.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (equal expected)\n</code></pre> <p>Examples:</p> <pre><code>// Primitives\nexpect 42 |&gt; to' (equal 42)\nexpect \"hello\" |&gt; to' (equal \"hello\")\nexpect true |&gt; to' (equal true)\n\n// Collections (structural equality)\nexpect [1; 2; 3] |&gt; to' (equal [1; 2; 3])\nexpect {| Name = \"Alice\"; Age = 30 |} |&gt; to' (equal {| Name = \"Alice\"; Age = 30 |})\n\n// Records and DUs\ntype Person = { Name: string; Age: int }\nlet person1 = { Name = \"Alice\"; Age = 30 }\nlet person2 = { Name = \"Alice\"; Age = 30 }\nexpect person1 |&gt; to' (equal person2)  // Passes\n</code></pre> <p>Notes:</p> <ul> <li>Uses F# <code>=</code> operator (structural equality)</li> <li>Works with any type that supports equality</li> <li>For reference equality, use <code>beSameAs</code></li> </ul>"},{"location":"reference/matchers/core/#null-checks","title":"Null Checks","text":""},{"location":"reference/matchers/core/#benil","title":"beNil","text":"<p>Type: <code>Matcher&lt;'a when 'a : null&gt;</code></p> <p>Matches if the actual value is <code>null</code>.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beNil\n</code></pre> <p>Examples:</p> <pre><code>expect null |&gt; to' beNil\nexpect (null: string) |&gt; to' beNil\n\nlet maybeNull: string = getSomeValue()\nif isNull maybeNull then\n    expect maybeNull |&gt; to' beNil\n</code></pre> <p>Notes:</p> <ul> <li>Type constraint: <code>'a : null</code> (reference types only)</li> <li>Cannot use with value types (int, bool, etc.)</li> <li>For strings, consider <code>beNullOrEmpty</code> or <code>beNullOrWhitespace</code></li> </ul>"},{"location":"reference/matchers/core/#notbenil","title":"notBeNil","text":"<p>Type: <code>Matcher&lt;'a when 'a : null&gt;</code></p> <p>Matches if the actual value is not <code>null</code>.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' notBeNil\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello\" |&gt; to' notBeNil\nexpect [1; 2; 3] |&gt; to' notBeNil\n\nlet result = database.Query()\nexpect result |&gt; to' notBeNil\n</code></pre>"},{"location":"reference/matchers/core/#boolean","title":"Boolean","text":""},{"location":"reference/matchers/core/#betrue","title":"beTrue","text":"<p>Type: <code>Matcher&lt;bool&gt;</code></p> <p>Matches if the actual value is <code>true</code>.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beTrue\n</code></pre> <p>Examples:</p> <pre><code>expect true |&gt; to' beTrue\nexpect (2 &gt; 1) |&gt; to' beTrue\nexpect (list.Any()) |&gt; to' beTrue\n</code></pre>"},{"location":"reference/matchers/core/#befalse","title":"beFalse","text":"<p>Type: <code>Matcher&lt;bool&gt;</code></p> <p>Matches if the actual value is <code>false</code>.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beFalse\n</code></pre> <p>Examples:</p> <pre><code>expect false |&gt; to' beFalse\nexpect (1 &gt; 2) |&gt; to' beFalse\nexpect (list.IsEmpty) |&gt; to' beFalse\n</code></pre>"},{"location":"reference/matchers/core/#option","title":"Option","text":""},{"location":"reference/matchers/core/#besome","title":"beSome","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a option&gt;</code></p> <p>Matches if the actual Option is <code>Some</code> with the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beSome expected)\n</code></pre> <p>Examples:</p> <pre><code>expect (Some 42) |&gt; to' (beSome 42)\nexpect (Some \"hello\") |&gt; to' (beSome \"hello\")\n\nlet result = tryFindUser(userId)\nexpect result |&gt; to' (beSome expectedUser)\n</code></pre> <p>Failure Messages:</p> <pre><code>// If actual is None\nexpect None |&gt; to' (beSome 42)\n// =&gt; Expected Some 42, but found None\n\n// If actual is Some with different value\nexpect (Some 10) |&gt; to' (beSome 42)\n// =&gt; Expected Some 42, but found Some 10\n</code></pre>"},{"location":"reference/matchers/core/#benone","title":"beNone","text":"<p>Type: <code>Matcher&lt;'a option&gt;</code></p> <p>Matches if the actual Option is <code>None</code>.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beNone\n</code></pre> <p>Examples:</p> <pre><code>expect None |&gt; to' beNone\n\nlet result = tryParseInt(\"not a number\")\nexpect result |&gt; to' beNone\n</code></pre> <p>Failure Message:</p> <pre><code>expect (Some 42) |&gt; to' beNone\n// =&gt; Expected None, but found Some 42\n</code></pre>"},{"location":"reference/matchers/core/#result","title":"Result","text":""},{"location":"reference/matchers/core/#beok","title":"beOk","text":"<p>Type: <code>'a -&gt; Matcher&lt;Result&lt;'a, 'b&gt;&gt;</code></p> <p>Matches if the actual Result is <code>Ok</code> with the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beOk expected)\n</code></pre> <p>Examples:</p> <pre><code>expect (Ok 42) |&gt; to' (beOk 42)\nexpect (Ok \"success\") |&gt; to' (beOk \"success\")\n\nlet result = validateEmail(\"test@example.com\")\nexpect result |&gt; to' (beOk validEmail)\n</code></pre> <p>Failure Messages:</p> <pre><code>// If actual is Error\nexpect (Error \"failed\") |&gt; to' (beOk 42)\n// =&gt; Expected Ok 42, but found Error \"failed\"\n\n// If actual is Ok with different value\nexpect (Ok 10) |&gt; to' (beOk 42)\n// =&gt; Expected Ok 42, but found Ok 10\n</code></pre>"},{"location":"reference/matchers/core/#beerror","title":"beError","text":"<p>Type: <code>'b -&gt; Matcher&lt;Result&lt;'a, 'b&gt;&gt;</code></p> <p>Matches if the actual Result is <code>Error</code> with the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beError expected)\n</code></pre> <p>Examples:</p> <pre><code>expect (Error \"failed\") |&gt; to' (beError \"failed\")\nexpect (Error 404) |&gt; to' (beError 404)\n\nlet result = validateAge(-1)\nexpect result |&gt; to' (beError \"Age must be positive\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// If actual is Ok\nexpect (Ok 42) |&gt; to' (beError \"failed\")\n// =&gt; Expected Error \"failed\", but found Ok 42\n\n// If actual is Error with different value\nexpect (Error \"error1\") |&gt; to' (beError \"error2\")\n// =&gt; Expected Error \"error2\", but found Error \"error1\"\n</code></pre>"},{"location":"reference/matchers/core/#type-checking","title":"Type Checking","text":""},{"location":"reference/matchers/core/#beoftype","title":"beOfType","text":"<p>Type: <code>Matcher&lt;obj&gt;</code></p> <p>Matches if the actual value is of the specified type.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beOfType&lt;TargetType&gt;)\n</code></pre> <p>Examples:</p> <pre><code>expect (box \"hello\") |&gt; to' (beOfType&lt;string&gt;)\nexpect (box 42) |&gt; to' (beOfType&lt;int&gt;)\nexpect (box [1; 2; 3]) |&gt; to' (beOfType&lt;int list&gt;)\n\n// With inheritance\ntype Animal = { Name: string }\ntype Dog = { Name: string; Breed: string }\n\nlet animal: obj = box { Name = \"Buddy\"; Breed = \"Labrador\" }\nexpect animal |&gt; to' (beOfType&lt;Dog&gt;)\n</code></pre> <p>Failure Message:</p> <pre><code>expect (box 42) |&gt; to' (beOfType&lt;string&gt;)\n// =&gt; Expected type string, but found type Int32\n</code></pre>"},{"location":"reference/matchers/core/#reference-equality","title":"Reference Equality","text":""},{"location":"reference/matchers/core/#besameas","title":"beSameAs","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt;</code></p> <p>Matches if the actual value is the same reference as the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beSameAs expected)\n</code></pre> <p>Examples:</p> <pre><code>let list1 = [1; 2; 3]\nlet list2 = list1\nlet list3 = [1; 2; 3]\n\nexpect list2 |&gt; to' (beSameAs list1)  // Passes (same reference)\nexpect list3 |&gt; notTo' (beSameAs list1)  // Passes (different reference, same value)\n\n// Singletons\nlet singleton = SingletonService.Instance\nexpect (SingletonService.Instance) |&gt; to' (beSameAs singleton)\n</code></pre> <p>Notes:</p> <ul> <li>Uses <code>obj.ReferenceEquals</code></li> <li>Different from <code>equal</code> which uses structural equality</li> <li>Useful for testing singletons, caching, or memoization</li> </ul>"},{"location":"reference/matchers/core/#custom-predicates","title":"Custom Predicates","text":""},{"location":"reference/matchers/core/#satisfy","title":"satisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a&gt;)</code></p> <p>Matches if the actual value satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test the value</li> <li><code>description</code> - Human-readable description of the predicate</li> </ul> <p>Usage:</p> <pre><code>expect actual |&gt; to' (satisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>// Simple predicate\nexpect 10 |&gt; to' (satisfy (fun x -&gt; x &gt; 5) \"be greater than 5\")\n\n// Complex predicate\nexpect \"hello\" |&gt; to' (satisfy\n    (fun s -&gt; s.Length &gt; 3 &amp;&amp; s.StartsWith(\"h\"))\n    \"be longer than 3 chars and start with 'h'\"\n)\n\n// Domain validation\ntype Email = Email of string\nlet isValidEmail (Email email) =\n    email.Contains(\"@\") &amp;&amp; email.Contains(\".\")\n\nexpect (Email \"test@example.com\") |&gt; to' (satisfy isValidEmail \"be a valid email\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect 3 |&gt; to' (satisfy (fun x -&gt; x &gt; 5) \"be greater than 5\")\n// =&gt; Expected value to satisfy 'be greater than 5', but 3 did not\n</code></pre> <p>Notes:</p> <ul> <li>Use for custom validation logic</li> <li>Description is shown in failure messages</li> <li>Consider creating a dedicated matcher for commonly used predicates</li> </ul>"},{"location":"reference/matchers/core/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/core/#testing-a-user-registration-function","title":"Testing a User Registration Function","text":"<pre><code>module UserRegistrationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\ntype ValidationError =\n    | EmailInvalid\n    | PasswordTooShort\n    | UsernameTaken\n\ntype User = { Id: int; Email: string; Username: string }\n\n[&lt;Tests&gt;]\nlet userRegistrationSpecs =\n    spec {\n        describe \"UserService.Register\" [\n            context \"when valid data is provided\" [\n                it \"returns Ok with new user\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"alice@example.com\", \"password123\")\n\n                    match result with\n                    | Ok user -&gt;\n                        expect user.Username |&gt; to' (equal \"alice\")\n                        expect user.Email |&gt; to' (equal \"alice@example.com\")\n                        expect user.Id |&gt; to' (beGreaterThan 0)\n                    | Error _ -&gt;\n                        failwith \"Expected Ok but got Error\"\n                )\n            ]\n\n            context \"when email is invalid\" [\n                it \"returns Error EmailInvalid\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"not-an-email\", \"password123\")\n                    expect result |&gt; to' (beError EmailInvalid)\n                )\n            ]\n\n            context \"when password is too short\" [\n                it \"returns Error PasswordTooShort\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"alice@example.com\", \"123\")\n                    expect result |&gt; to' (beError PasswordTooShort)\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/core/#see-also","title":"See Also","text":"<ul> <li>Collection Matchers - Matchers for lists, arrays, and sequences</li> <li>String Matchers - String-specific matchers</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Exception Matchers - Exception testing</li> <li>Quick Start - Get started with FxSpec</li> </ul>"},{"location":"reference/matchers/exceptions/","title":"Exception Matchers","text":"<p>Matchers for testing exception throwing behavior.</p>"},{"location":"reference/matchers/exceptions/#basic-exception-testing","title":"Basic Exception Testing","text":""},{"location":"reference/matchers/exceptions/#raiseexception","title":"raiseException","text":"<p>Type: <code>Matcher&lt;unit -&gt; unit&gt; when 'T :&gt; exn</code></p> <p>Matches if the function raises an exception of the specified type.</p> <p>Usage:</p> <pre><code>expect action |&gt; to' raiseException&lt;ExceptionType&gt;\n</code></pre> <p>Examples:</p> <pre><code>// Basic exception\nexpect (fun () -&gt; failwith \"error\") |&gt; to' raiseException&lt;System.Exception&gt;\n\n// Specific exception type\nexpect (fun () -&gt; invalidArg \"param\" \"error\") |&gt; to' raiseException&lt;System.ArgumentException&gt;\n\n// Division by zero\nexpect (fun () -&gt; 1 / 0 |&gt; ignore) |&gt; to' raiseException&lt;System.DivideByZeroException&gt;\n\n// Custom exceptions\ntype ValidationException() = inherit exn()\nexpect (fun () -&gt; raise (ValidationException())) |&gt; to' raiseException&lt;ValidationException&gt;\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception thrown\nexpect (fun () -&gt; 1 + 1) |&gt; to' raiseException&lt;Exception&gt;\n// =&gt; Expected an exception of type Exception to be thrown, but nothing was thrown\n\n// Wrong exception type\nexpect (fun () -&gt; invalidArg \"x\" \"error\") |&gt; to' raiseException&lt;InvalidOperationException&gt;\n// =&gt; Expected an exception of type InvalidOperationException, but an exception of type ArgumentException was thrown: error\n</code></pre> <p>Notes:</p> <ul> <li>Use generic type parameter to specify expected exception type</li> <li>Catches exact type and derived types</li> <li>Use most specific exception type possible for clarity</li> </ul>"},{"location":"reference/matchers/exceptions/#message-matching","title":"Message Matching","text":""},{"location":"reference/matchers/exceptions/#raiseexceptionwithmessage","title":"raiseExceptionWithMessage","text":"<p>Type: <code>string -&gt; Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function raises an exception with the specified message (exact match).</p> <p>Usage:</p> <pre><code>expect action |&gt; to' (raiseExceptionWithMessage \"expected message\")\n</code></pre> <p>Examples:</p> <pre><code>expect (fun () -&gt; failwith \"error\") |&gt; to' (raiseExceptionWithMessage \"error\")\nexpect (fun () -&gt; invalidArg \"x\" \"must be positive\") |&gt; to' (raiseExceptionWithMessage \"must be positive (Parameter 'x')\")\n\n// Custom error messages\nlet validateAge age =\n    if age &lt; 0 then\n        invalidArg (nameof age) \"Age cannot be negative\"\n\nexpect (fun () -&gt; validateAge -5) |&gt; to' (raiseExceptionWithMessage \"Age cannot be negative (Parameter 'age')\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception\nexpect (fun () -&gt; 1 + 1) |&gt; to' (raiseExceptionWithMessage \"error\")\n// =&gt; Expected an exception with message 'error' to be thrown, but nothing was thrown\n\n// Different message\nexpect (fun () -&gt; failwith \"wrong\") |&gt; to' (raiseExceptionWithMessage \"error\")\n// =&gt; Expected exception message 'error', but found 'wrong'\n</code></pre> <p>Notes:</p> <ul> <li>Message must match exactly (case-sensitive)</li> <li>For partial matching, use <code>raiseExceptionContaining</code></li> <li>Be aware of .NET exception message formatting (e.g., ArgumentException adds parameter name)</li> </ul>"},{"location":"reference/matchers/exceptions/#raiseexceptioncontaining","title":"raiseExceptionContaining","text":"<p>Type: <code>string -&gt; Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function raises an exception containing the specified substring.</p> <p>Usage:</p> <pre><code>expect action |&gt; to' (raiseExceptionContaining \"substring\")\n</code></pre> <p>Examples:</p> <pre><code>expect (fun () -&gt; failwith \"file not found\") |&gt; to' (raiseExceptionContaining \"not found\")\nexpect (fun () -&gt; failwith \"error: invalid input\") |&gt; to' (raiseExceptionContaining \"error:\")\n\n// Partial message matching\nlet validateEmail email =\n    if not (email.Contains(\"@\")) then\n        invalidOp \"Email must contain @\"\n\nexpect (fun () -&gt; validateEmail \"invalid\") |&gt; to' (raiseExceptionContaining \"@\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception\nexpect (fun () -&gt; 1 + 1) |&gt; to' (raiseExceptionContaining \"error\")\n// =&gt; Expected an exception containing 'error' to be thrown, but nothing was thrown\n\n// Substring not found\nexpect (fun () -&gt; failwith \"wrong\") |&gt; to' (raiseExceptionContaining \"error\")\n// =&gt; Expected exception message to contain 'error', but found 'wrong'\n</code></pre> <p>Notes:</p> <ul> <li>Case-sensitive substring matching</li> <li>More flexible than exact message matching</li> <li>Good for testing error messages that include dynamic content (IDs, timestamps, etc.)</li> </ul>"},{"location":"reference/matchers/exceptions/#advanced-exception-testing","title":"Advanced Exception Testing","text":""},{"location":"reference/matchers/exceptions/#raiseexceptionmatching","title":"raiseExceptionMatching","text":"<p>Type: <code>('T -&gt; bool) -&gt; string -&gt; Matcher&lt;unit -&gt; unit&gt; when 'T :&gt; exn</code></p> <p>Matches if the function raises an exception of the specified type that satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test the exception</li> <li><code>description</code> - Human-readable description of the predicate</li> </ul> <p>Usage:</p> <pre><code>expect action |&gt; to' (raiseExceptionMatching&lt;ExceptionType&gt; predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>// Check exception property\ntype CustomException(code: int) =\n    inherit exn()\n    member _.ErrorCode = code\n\nexpect (fun () -&gt; raise (CustomException(404))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode = 404)\n        \"have error code 404\")\n\n// ArgumentException with specific parameter name\nexpect (fun () -&gt; invalidArg \"userId\" \"error\") |&gt; to'\n    (raiseExceptionMatching&lt;ArgumentException&gt;\n        (fun ex -&gt; ex.ParamName = \"userId\")\n        \"have parameter name 'userId'\")\n\n// Multiple conditions\nexpect (fun () -&gt; raise (CustomException(500))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode &gt;= 500 &amp;&amp; ex.ErrorCode &lt; 600)\n        \"have 5xx error code\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// Exception doesn't match predicate\nexpect (fun () -&gt; raise (CustomException(200))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode = 404)\n        \"have error code 404\")\n// =&gt; Expected exception to match 'have error code 404', but it did not: [exception message]\n\n// Wrong exception type\nexpect (fun () -&gt; failwith \"error\") |&gt; to'\n    (raiseExceptionMatching&lt;ArgumentException&gt;\n        (fun ex -&gt; ex.ParamName = \"x\")\n        \"have parameter name 'x'\")\n// =&gt; Expected an exception of type ArgumentException, but an exception of type Exception was thrown\n</code></pre> <p>Notes:</p> <ul> <li>Combines type checking and predicate matching</li> <li>Description appears in error messages</li> <li>Use for complex exception validation</li> <li>Predicate receives strongly-typed exception</li> </ul>"},{"location":"reference/matchers/exceptions/#negative-testing","title":"Negative Testing","text":""},{"location":"reference/matchers/exceptions/#notraiseexception","title":"notRaiseException","text":"<p>Type: <code>Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function does not raise any exception.</p> <p>Usage:</p> <pre><code>expect action |&gt; to' notRaiseException\n</code></pre> <p>Examples:</p> <pre><code>expect (fun () -&gt; 1 + 1) |&gt; to' notRaiseException\nexpect (fun () -&gt; printfn \"hello\") |&gt; to' notRaiseException\n\n// Safe operations\nlet safeDivide x y =\n    if y = 0 then 0\n    else x / y\n\nexpect (fun () -&gt; safeDivide 10 0 |&gt; ignore) |&gt; to' notRaiseException\n</code></pre> <p>Failure Message:</p> <pre><code>expect (fun () -&gt; failwith \"error\") |&gt; to' notRaiseException\n// =&gt; Expected no exception to be thrown, but Exception was thrown: error\n\nexpect (fun () -&gt; 1 / 0 |&gt; ignore) |&gt; to' notRaiseException\n// =&gt; Expected no exception to be thrown, but DivideByZeroException was thrown: Attempted to divide by zero.\n</code></pre> <p>Notes:</p> <ul> <li>Useful for testing error handling code</li> <li>Can also use <code>notTo' raiseException&lt;exn&gt;</code></li> <li>Shows exception type and message in failure</li> </ul>"},{"location":"reference/matchers/exceptions/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/exceptions/#testing-input-validation","title":"Testing Input Validation","text":"<pre><code>module ValidationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\nopen System\n\ntype ValidationError =\n    | Required of field: string\n    | InvalidFormat of field: string\n    | OutOfRange of field: string * min: int * max: int\n\nexception ValidationException of ValidationError\n\nmodule Validator =\n    let validateAge age =\n        if age &lt; 0 then\n            invalidArg (nameof age) \"Age cannot be negative\"\n        elif age &gt; 150 then\n            invalidArg (nameof age) \"Age must be less than 150\"\n        else\n            age\n\n    let validateEmail email =\n        if String.IsNullOrWhiteSpace(email) then\n            raise (ValidationException(Required \"email\"))\n        elif not (email.Contains(\"@\")) then\n            raise (ValidationException(InvalidFormat \"email\"))\n        else\n            email\n\n[&lt;Tests&gt;]\nlet validationSpecs =\n    spec {\n        describe \"Validator\" [\n            describe \"validateAge\" [\n                context \"when age is valid\" [\n                    it \"returns age without exception\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge 25 |&gt; ignore) |&gt; to' notRaiseException\n                    )\n                ]\n\n                context \"when age is negative\" [\n                    it \"raises ArgumentException\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            raiseException&lt;ArgumentException&gt;\n                    )\n\n                    it \"has descriptive error message\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            (raiseExceptionContaining \"cannot be negative\")\n                    )\n\n                    it \"includes parameter name\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            (raiseExceptionMatching&lt;ArgumentException&gt;\n                                (fun ex -&gt; ex.ParamName = \"age\")\n                                \"have parameter name 'age'\")\n                    )\n                ]\n\n                context \"when age is too large\" [\n                    it \"raises ArgumentException with message\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge 200 |&gt; ignore) |&gt; to'\n                            (raiseExceptionContaining \"less than 150\")\n                    )\n                ]\n            ]\n\n            describe \"validateEmail\" [\n                context \"when email is null or empty\" [\n                    it \"raises ValidationException with Required error\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"\" |&gt; ignore) |&gt; to'\n                            (raiseExceptionMatching&lt;ValidationException&gt;\n                                (fun ex -&gt;\n                                    match ex.Data0 with\n                                    | Required field -&gt; field = \"email\"\n                                    | _ -&gt; false)\n                                \"have Required error for email field\")\n                    )\n                ]\n\n                context \"when email format is invalid\" [\n                    it \"raises ValidationException with InvalidFormat error\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"notanemail\" |&gt; ignore) |&gt; to'\n                            raiseException&lt;ValidationException&gt;\n                    )\n                ]\n\n                context \"when email is valid\" [\n                    it \"does not raise exception\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"test@example.com\" |&gt; ignore) |&gt; to'\n                            notRaiseException\n                    )\n                ]\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/exceptions/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>module ErrorHandlingSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\nopen System\nopen System.IO\n\nmodule FileService =\n    let readFile path =\n        if not (File.Exists(path)) then\n            raise (FileNotFoundException($\"File not found: {path}\"))\n        File.ReadAllText(path)\n\n    let safeReadFile path =\n        try\n            Ok (readFile path)\n        with\n        | :? FileNotFoundException as ex -&gt; Error ex.Message\n        | ex -&gt; Error $\"Unexpected error: {ex.Message}\"\n\n[&lt;Tests&gt;]\nlet errorHandlingSpecs =\n    spec {\n        describe \"FileService\" [\n            describe \"readFile\" [\n                it \"raises FileNotFoundException for missing file\" (fun () -&gt;\n                    expect (fun () -&gt; FileService.readFile \"nonexistent.txt\" |&gt; ignore) |&gt; to'\n                        raiseException&lt;FileNotFoundException&gt;\n                )\n\n                it \"includes filename in exception message\" (fun () -&gt;\n                    let path = \"missing.txt\"\n                    expect (fun () -&gt; FileService.readFile path |&gt; ignore) |&gt; to'\n                        (raiseExceptionContaining path)\n                )\n            ]\n\n            describe \"safeReadFile\" [\n                it \"returns Error for missing file\" (fun () -&gt;\n                    let result = FileService.safeReadFile \"nonexistent.txt\"\n                    expect result |&gt; to' (satisfy Result.isError \"be Error\")\n                )\n\n                it \"does not raise exception\" (fun () -&gt;\n                    expect (fun () -&gt; FileService.safeReadFile \"nonexistent.txt\" |&gt; ignore) |&gt; to'\n                        notRaiseException\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/exceptions/#best-practices","title":"Best Practices","text":""},{"location":"reference/matchers/exceptions/#be-specific","title":"Be Specific","text":"<pre><code>// Good - specific exception type\nexpect action |&gt; to' raiseException&lt;ArgumentNullException&gt;\n\n// Less good - generic exception type\nexpect action |&gt; to' raiseException&lt;Exception&gt;\n</code></pre>"},{"location":"reference/matchers/exceptions/#test-exception-messages","title":"Test Exception Messages","text":"<pre><code>// Good - validates error communication\nexpect action |&gt; to' (raiseExceptionContaining \"must be positive\")\n\n// Less good - only checks exception type\nexpect action |&gt; to' raiseException&lt;ArgumentException&gt;\n</code></pre>"},{"location":"reference/matchers/exceptions/#use-lambdas-for-lazy-evaluation","title":"Use Lambdas for Lazy Evaluation","text":"<pre><code>// Good - lazy evaluation\nexpect (fun () -&gt; riskyOperation()) |&gt; to' raiseException&lt;Exception&gt;\n\n// Wrong - evaluates immediately, exception thrown before matcher\nexpect riskyOperation() |&gt; to' raiseException&lt;Exception&gt;  // Compilation error\n</code></pre>"},{"location":"reference/matchers/exceptions/#prefer-result-types-for-errors","title":"Prefer Result Types for Errors","text":"<pre><code>// Consider using Result types instead of exceptions for expected errors\ntype ValidationResult = Result&lt;ValidatedData, ValidationError&gt;\n\nlet validate data : ValidationResult =\n    if isValid data then\n        Ok (ValidatedData data)\n    else\n        Error (ValidationError \"Invalid data\")\n\n// Test with Result matchers\nexpect (validate invalidData) |&gt; to' (beError (ValidationError \"Invalid data\"))\n</code></pre>"},{"location":"reference/matchers/exceptions/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic matchers including Result matchers</li> <li>Quick Start - Get started with FxSpec</li> <li>DSL API - Complete DSL reference</li> </ul>"},{"location":"reference/matchers/numeric/","title":"Numeric Matchers","text":"<p>Numeric comparisons and range checks for numbers.</p>"},{"location":"reference/matchers/numeric/#comparisons","title":"Comparisons","text":""},{"location":"reference/matchers/numeric/#begreaterthan","title":"beGreaterThan","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is greater than the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beGreaterThan expected)\n</code></pre> <p>Examples:</p> <pre><code>expect 10 |&gt; to' (beGreaterThan 5)\nexpect 3.14 |&gt; to' (beGreaterThan 3.0)\nexpect 100L |&gt; to' (beGreaterThan 50L)\n\n// After calculations\nlet score = calculateScore()\nexpect score |&gt; to' (beGreaterThan 0)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 5 |&gt; to' (beGreaterThan 10)\n// =&gt; Expected value to be greater than 10, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#begreaterthanorequal","title":"beGreaterThanOrEqual","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is greater than or equal to the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beGreaterThanOrEqual expected)\n</code></pre> <p>Examples:</p> <pre><code>expect 10 |&gt; to' (beGreaterThanOrEqual 10)  // Equal case\nexpect 10 |&gt; to' (beGreaterThanOrEqual 5)   // Greater case\nexpect 5.0 |&gt; to' (beGreaterThanOrEqual 5.0)\n\n// Minimum validation\nlet age = user.Age\nexpect age |&gt; to' (beGreaterThanOrEqual 18)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 5 |&gt; to' (beGreaterThanOrEqual 10)\n// =&gt; Expected value to be greater than or equal to 10, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#belessthan","title":"beLessThan","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is less than the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beLessThan expected)\n</code></pre> <p>Examples:</p> <pre><code>expect 5 |&gt; to' (beLessThan 10)\nexpect 2.5 |&gt; to' (beLessThan 3.0)\nexpect -10 |&gt; to' (beLessThan 0)\n\n// Maximum validation\nlet count = list.Length\nexpect count |&gt; to' (beLessThan 100)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 15 |&gt; to' (beLessThan 10)\n// =&gt; Expected value to be less than 10, but found 15\n</code></pre>"},{"location":"reference/matchers/numeric/#belessthanorequal","title":"beLessThanOrEqual","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is less than or equal to the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beLessThanOrEqual expected)\n</code></pre> <p>Examples:</p> <pre><code>expect 5 |&gt; to' (beLessThanOrEqual 5)   // Equal case\nexpect 5 |&gt; to' (beLessThanOrEqual 10)  // Less case\nexpect 3.14 |&gt; to' (beLessThanOrEqual 4.0)\n\n// Maximum limit\nlet responseTime = measureResponseTime()\nexpect responseTime |&gt; to' (beLessThanOrEqual 1000)  // Max 1000ms\n</code></pre> <p>Failure Message:</p> <pre><code>expect 15 |&gt; to' (beLessThanOrEqual 10)\n// =&gt; Expected value to be less than or equal to 10, but found 15\n</code></pre>"},{"location":"reference/matchers/numeric/#ranges","title":"Ranges","text":""},{"location":"reference/matchers/numeric/#bebetween","title":"beBetween","text":"<p>Type: <code>'a -&gt; 'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is between min and max (inclusive).</p> <p>Parameters:</p> <ul> <li><code>min</code> - Minimum value (inclusive)</li> <li><code>max</code> - Maximum value (inclusive)</li> </ul> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beBetween min max)\n</code></pre> <p>Examples:</p> <pre><code>expect 5 |&gt; to' (beBetween 1 10)    // Within range\nexpect 1 |&gt; to' (beBetween 1 10)    // Minimum (inclusive)\nexpect 10 |&gt; to' (beBetween 1 10)   // Maximum (inclusive)\n\n// Age validation\nlet age = user.Age\nexpect age |&gt; to' (beBetween 18 65)\n\n// Percentage\nlet score = getScore()\nexpect score |&gt; to' (beBetween 0.0 100.0)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 15 |&gt; to' (beBetween 1 10)\n// =&gt; Expected value to be between 1 and 10, but found 15\n</code></pre> <p>Notes:</p> <ul> <li>Both bounds are inclusive</li> <li>Validates that <code>min &lt;= max</code> at creation time</li> <li>Works with any comparable type (int, float, DateTime, etc.)</li> </ul>"},{"location":"reference/matchers/numeric/#floating-point","title":"Floating Point","text":""},{"location":"reference/matchers/numeric/#becloseto","title":"beCloseTo","text":"<p>Type: <code>float -&gt; float -&gt; Matcher&lt;float&gt;</code></p> <p>Matches if the actual floating-point value is close to the expected value within a tolerance.</p> <p>Parameters:</p> <ul> <li><code>expected</code> - Expected value</li> <li><code>tolerance</code> - Maximum allowed difference</li> </ul> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beCloseTo expected tolerance)\n</code></pre> <p>Examples:</p> <pre><code>expect 3.14159 |&gt; to' (beCloseTo 3.14 0.01)     // Within tolerance\nexpect 3.14159 |&gt; to' (beCloseTo 3.14159 0.0)   // Exact match\n\n// Calculation precision\nlet result = Math.PI * 2.0\nexpect result |&gt; to' (beCloseTo 6.283 0.001)\n\n// Financial calculations\nlet total = calculateTotal()\nexpect total |&gt; to' (beCloseTo 99.99 0.01)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 3.5 |&gt; to' (beCloseTo 3.14 0.1)\n// =&gt; Expected value to be close to 3.14 (\u00b10.1), but found 3.5 (diff: 0.36)\n</code></pre> <p>Notes:</p> <ul> <li>Tolerance must be non-negative</li> <li>Does not accept NaN or Infinity</li> <li>Use for comparing floating-point results where exact equality is unreliable</li> <li>Default to smallest reasonable tolerance</li> </ul>"},{"location":"reference/matchers/numeric/#sign-checks","title":"Sign Checks","text":""},{"location":"reference/matchers/numeric/#bepositive","title":"bePositive","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : comparison and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is positive (&gt; 0).</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' bePositive\n</code></pre> <p>Examples:</p> <pre><code>expect 5 |&gt; to' bePositive\nexpect 0.1 |&gt; to' bePositive\nexpect 100L |&gt; to' bePositive\n\n// After calculations\nlet profit = revenue - expenses\nexpect profit |&gt; to' bePositive\n</code></pre> <p>Failure Message:</p> <pre><code>expect -5 |&gt; to' bePositive\n// =&gt; Expected positive value, but found -5\n\nexpect 0 |&gt; to' bePositive\n// =&gt; Expected positive value, but found 0\n</code></pre> <p>Notes:</p> <ul> <li>Zero is not positive (use <code>beGreaterThanOrEqual 0</code> to include zero)</li> <li>Works with any numeric type that has a <code>Zero</code> member</li> </ul>"},{"location":"reference/matchers/numeric/#benegative","title":"beNegative","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : comparison and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is negative (&lt; 0).</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beNegative\n</code></pre> <p>Examples:</p> <pre><code>expect -5 |&gt; to' beNegative\nexpect -0.1 |&gt; to' beNegative\nexpect -100L |&gt; to' beNegative\n\n// Testing debt\nlet balance = account.Balance\nif balance &lt; 0 then\n    expect balance |&gt; to' beNegative\n</code></pre> <p>Failure Message:</p> <pre><code>expect 5 |&gt; to' beNegative\n// =&gt; Expected negative value, but found 5\n\nexpect 0 |&gt; to' beNegative\n// =&gt; Expected negative value, but found 0\n</code></pre>"},{"location":"reference/matchers/numeric/#bezero","title":"beZero","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : equality and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is zero.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beZero\n</code></pre> <p>Examples:</p> <pre><code>expect 0 |&gt; to' beZero\nexpect 0.0 |&gt; to' beZero\nexpect 0L |&gt; to' beZero\n\n// After operations\nlet remainder = 10 % 2\nexpect remainder |&gt; to' beZero\n</code></pre> <p>Failure Message:</p> <pre><code>expect 5 |&gt; to' beZero\n// =&gt; Expected zero, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#integer-properties","title":"Integer Properties","text":""},{"location":"reference/matchers/numeric/#beeven","title":"beEven","text":"<p>Type: <code>Matcher&lt;int&gt;</code></p> <p>Matches if the actual integer is even.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beEven\n</code></pre> <p>Examples:</p> <pre><code>expect 2 |&gt; to' beEven\nexpect 0 |&gt; to' beEven\nexpect -4 |&gt; to' beEven\n\n// Testing parity\nlet count = list.Length\nif shouldBeEven(count) then\n    expect count |&gt; to' beEven\n</code></pre> <p>Failure Message:</p> <pre><code>expect 3 |&gt; to' beEven\n// =&gt; Expected even number, but found 3\n</code></pre>"},{"location":"reference/matchers/numeric/#beodd","title":"beOdd","text":"<p>Type: <code>Matcher&lt;int&gt;</code></p> <p>Matches if the actual integer is odd.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' beOdd\n</code></pre> <p>Examples:</p> <pre><code>expect 1 |&gt; to' beOdd\nexpect 3 |&gt; to' beOdd\nexpect -5 |&gt; to' beOdd\n\n// Testing alternating pattern\nlet index = getCurrentIndex()\nif shouldBeOnOddIndex(index) then\n    expect index |&gt; to' beOdd\n</code></pre> <p>Failure Message:</p> <pre><code>expect 4 |&gt; to' beOdd\n// =&gt; Expected odd number, but found 4\n</code></pre>"},{"location":"reference/matchers/numeric/#bedivisibleby","title":"beDivisibleBy","text":"<p>Type: <code>int -&gt; Matcher&lt;int&gt;</code></p> <p>Matches if the actual value is divisible by the expected divisor.</p> <p>Usage:</p> <pre><code>expect actual |&gt; to' (beDivisibleBy divisor)\n</code></pre> <p>Examples:</p> <pre><code>expect 15 |&gt; to' (beDivisibleBy 5)\nexpect 12 |&gt; to' (beDivisibleBy 3)\nexpect 100 |&gt; to' (beDivisibleBy 10)\n\n// Page size validation\nlet itemCount = items.Length\nexpect itemCount |&gt; to' (beDivisibleBy pageSize)\n\n// Even numbers are divisible by 2\nexpect 8 |&gt; to' (beDivisibleBy 2)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 7 |&gt; to' (beDivisibleBy 3)\n// =&gt; Expected 7 to be divisible by 3, but it is not\n</code></pre> <p>Notes:</p> <ul> <li>Divisor cannot be zero (throws <code>ArgumentException</code>)</li> <li>Works with negative numbers</li> <li><code>beDivisibleBy 2</code> is equivalent to <code>beEven</code></li> </ul>"},{"location":"reference/matchers/numeric/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/numeric/#testing-a-math-library","title":"Testing a Math Library","text":"<pre><code>module MathLibrarySpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\nopen System\n\n[&lt;Tests&gt;]\nlet mathLibrarySpecs =\n    spec {\n        describe \"MathHelpers\" [\n            describe \"average\" [\n                it \"calculates average of numbers\" (fun () -&gt;\n                    let result = MathHelpers.average [1.0; 2.0; 3.0; 4.0; 5.0]\n                    expect result |&gt; to' (equal 3.0)\n                    expect result |&gt; to' (beGreaterThan 0.0)\n                )\n\n                it \"handles floating-point precision\" (fun () -&gt;\n                    let result = MathHelpers.average [1.0/3.0; 2.0/3.0; 3.0/3.0]\n                    expect result |&gt; to' (beCloseTo 0.666 0.001)\n                )\n            ]\n\n            describe \"factorial\" [\n                it \"calculates factorial of positive number\" (fun () -&gt;\n                    let result = MathHelpers.factorial 5\n                    expect result |&gt; to' (equal 120)\n                    expect result |&gt; to' bePositive\n                )\n\n                it \"returns 1 for zero\" (fun () -&gt;\n                    let result = MathHelpers.factorial 0\n                    expect result |&gt; to' (equal 1)\n                )\n            ]\n\n            describe \"isPrime\" [\n                it \"identifies prime numbers\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 2) |&gt; to' beTrue\n                    expect (MathHelpers.isPrime 7) |&gt; to' beTrue\n                    expect (MathHelpers.isPrime 13) |&gt; to' beTrue\n                )\n\n                it \"rejects composite numbers\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 4) |&gt; to' beFalse\n                    expect (MathHelpers.isPrime 9) |&gt; to' beFalse\n                )\n\n                it \"rejects numbers less than 2\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 1) |&gt; to' beFalse\n                    expect (MathHelpers.isPrime 0) |&gt; to' beFalse\n                    expect (MathHelpers.isPrime -5) |&gt; to' beFalse\n                )\n            ]\n\n            describe \"clamp\" [\n                it \"keeps value within range\" (fun () -&gt;\n                    let result = MathHelpers.clamp 5 1 10\n                    expect result |&gt; to' (equal 5)\n                    expect result |&gt; to' (beBetween 1 10)\n                )\n\n                it \"clamps to minimum\" (fun () -&gt;\n                    let result = MathHelpers.clamp -5 1 10\n                    expect result |&gt; to' (equal 1)\n                    expect result |&gt; to' (beGreaterThanOrEqual 1)\n                )\n\n                it \"clamps to maximum\" (fun () -&gt;\n                    let result = MathHelpers.clamp 15 1 10\n                    expect result |&gt; to' (equal 10)\n                    expect result |&gt; to' (beLessThanOrEqual 10)\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/numeric/#testing-financial-calculations","title":"Testing Financial Calculations","text":"<pre><code>module FinancialSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet financialSpecs =\n    spec {\n        describe \"Financial Calculations\" [\n            describe \"calculateInterest\" [\n                it \"calculates simple interest\" (fun () -&gt;\n                    let principal = 1000.0\n                    let rate = 0.05  // 5%\n                    let time = 2.0   // 2 years\n\n                    let interest = Financial.calculateSimpleInterest principal rate time\n                    expect interest |&gt; to' (beCloseTo 100.0 0.01)\n                    expect interest |&gt; to' bePositive\n                )\n\n                it \"handles edge case of zero rate\" (fun () -&gt;\n                    let interest = Financial.calculateSimpleInterest 1000.0 0.0 2.0\n                    expect interest |&gt; to' beZero\n                )\n            ]\n\n            describe \"calculateTax\" [\n                it \"calculates tax for income bracket\" (fun () -&gt;\n                    let income = 50000.0\n                    let tax = Financial.calculateTax income\n\n                    expect tax |&gt; to' bePositive\n                    expect tax |&gt; to' (beLessThan income)\n                    expect tax |&gt; to' (beCloseTo 7500.0 100.0)  // Approximate\n                )\n\n                it \"returns zero tax for income below threshold\" (fun () -&gt;\n                    let income = 5000.0\n                    let tax = Financial.calculateTax income\n                    expect tax |&gt; to' beZero\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/numeric/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality matchers</li> <li>Collection Matchers - Collection matchers</li> <li>String Matchers - String matchers</li> <li>Quick Start - Get started with FxSpec</li> </ul>"},{"location":"reference/matchers/strings/","title":"String Matchers","text":"<p>String-specific matchers for prefixes, suffixes, patterns, and more.</p>"},{"location":"reference/matchers/strings/#prefixes-suffixes","title":"Prefixes &amp; Suffixes","text":""},{"location":"reference/matchers/strings/#startwith","title":"startWith","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string starts with the expected prefix.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' (startWith prefix)\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello world\" |&gt; to' (startWith \"hello\")\nexpect \"FxSpec\" |&gt; to' (startWith \"Fx\")\nexpect \"https://example.com\" |&gt; to' (startWith \"https://\")\n\n// Case-sensitive\nexpect \"Hello\" |&gt; notTo' (startWith \"hello\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello world\" |&gt; to' (startWith \"goodbye\")\n// =&gt; Expected string to start with 'goodbye', but found 'hello world'\n</code></pre> <p>Notes:</p> <ul> <li>Case-sensitive by default</li> <li>Returns error for null strings</li> <li>For case-insensitive matching, use custom logic or convert to lowercase first</li> </ul>"},{"location":"reference/matchers/strings/#endwith","title":"endWith","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string ends with the expected suffix.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' (endWith suffix)\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello world\" |&gt; to' (endWith \"world\")\nexpect \"test.txt\" |&gt; to' (endWith \".txt\")\nexpect \"FxSpec\" |&gt; to' (endWith \"Spec\")\n\n// File extensions\nlet filename = \"document.pdf\"\nexpect filename |&gt; to' (endWith \".pdf\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello world\" |&gt; to' (endWith \".txt\")\n// =&gt; Expected string to end with '.txt', but found 'hello world'\n</code></pre>"},{"location":"reference/matchers/strings/#substrings","title":"Substrings","text":""},{"location":"reference/matchers/strings/#containsubstring","title":"containSubstring","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string contains the expected substring.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' (containSubstring substring)\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello world\" |&gt; to' (containSubstring \"lo wo\")\nexpect \"FxSpec is great\" |&gt; to' (containSubstring \"Spec\")\nexpect \"error: file not found\" |&gt; to' (containSubstring \"error:\")\n\n// Search in logs\nlet logMessage = \"2025-01-01 10:00:00 INFO User logged in\"\nexpect logMessage |&gt; to' (containSubstring \"INFO\")\nexpect logMessage |&gt; to' (containSubstring \"logged in\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello world\" |&gt; to' (containSubstring \"goodbye\")\n// =&gt; Expected string to contain 'goodbye', but found 'hello world'\n</code></pre>"},{"location":"reference/matchers/strings/#patterns","title":"Patterns","text":""},{"location":"reference/matchers/strings/#matchregex","title":"matchRegex","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string matches the regular expression pattern.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' (matchRegex pattern)\n</code></pre> <p>Examples:</p> <pre><code>// Email validation\nexpect \"test@example.com\" |&gt; to' (matchRegex @\"^\\w+@\\w+\\.\\w+$\")\n\n// Phone numbers\nexpect \"555-1234\" |&gt; to' (matchRegex @\"^\\d{3}-\\d{4}$\")\n\n// Dates\nexpect \"2025-01-01\" |&gt; to' (matchRegex @\"^\\d{4}-\\d{2}-\\d{2}$\")\n\n// Contains digits\nexpect \"hello123\" |&gt; to' (matchRegex @\"\\d+\")\n\n// Starts with uppercase\nexpect \"Hello\" |&gt; to' (matchRegex @\"^[A-Z]\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; to' (matchRegex @\"^\\d+$\")\n// =&gt; Expected string to match pattern '^\\d+$', but found 'hello'\n</code></pre> <p>Notes:</p> <ul> <li>Uses .NET <code>Regex.IsMatch</code></li> <li>Patterns are case-sensitive by default</li> <li>Use <code>(?i)</code> flag for case-insensitive matching: <code>matchRegex @\"(?i)hello\"</code></li> </ul>"},{"location":"reference/matchers/strings/#empty-checks","title":"Empty Checks","text":""},{"location":"reference/matchers/strings/#beemptystring","title":"beEmptyString","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is empty (<code>\"\"</code>).</p> <p>Usage:</p> <pre><code>expect string |&gt; to' beEmptyString\n</code></pre> <p>Examples:</p> <pre><code>expect \"\" |&gt; to' beEmptyString\nexpect String.Empty |&gt; to' beEmptyString\n\n// After operations\nlet trimmed = \"   \".Trim()\nexpect trimmed |&gt; to' beEmptyString\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; to' beEmptyString\n// =&gt; Expected empty string, but found 'hello'\n\nexpect null |&gt; to' beEmptyString\n// =&gt; Expected empty string, but found null\n</code></pre>"},{"location":"reference/matchers/strings/#benullorempty","title":"beNullOrEmpty","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is null or empty.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' beNullOrEmpty\n</code></pre> <p>Examples:</p> <pre><code>expect null |&gt; to' beNullOrEmpty\nexpect \"\" |&gt; to' beNullOrEmpty\nexpect String.Empty |&gt; to' beNullOrEmpty\n\n// Validation\nlet userInput = getUserInput()\nif String.IsNullOrEmpty(userInput) then\n    expect userInput |&gt; to' beNullOrEmpty\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; to' beNullOrEmpty\n// =&gt; Expected null or empty string, but found 'hello'\n</code></pre>"},{"location":"reference/matchers/strings/#benullorwhitespace","title":"beNullOrWhitespace","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is null, empty, or contains only whitespace.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' beNullOrWhitespace\n</code></pre> <p>Examples:</p> <pre><code>expect null |&gt; to' beNullOrWhitespace\nexpect \"\" |&gt; to' beNullOrWhitespace\nexpect \"   \" |&gt; to' beNullOrWhitespace\nexpect \"\\t\\n\" |&gt; to' beNullOrWhitespace\n\n// User input validation\nlet comment = getCommentText()\nif String.IsNullOrWhiteSpace(comment) then\n    expect comment |&gt; to' beNullOrWhitespace\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; to' beNullOrWhitespace\n// =&gt; Expected null, empty, or whitespace string, but found 'hello'\n</code></pre>"},{"location":"reference/matchers/strings/#length","title":"Length","text":""},{"location":"reference/matchers/strings/#havestringlength","title":"haveStringLength","text":"<p>Type: <code>int -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string has the expected length.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' (haveStringLength length)\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello\" |&gt; to' (haveStringLength 5)\nexpect \"\" |&gt; to' (haveStringLength 0)\nexpect \"FxSpec\" |&gt; to' (haveStringLength 6)\n\n// Password validation\nlet password = \"secret123\"\nexpect password |&gt; to' (haveStringLength 9)\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; to' (haveStringLength 10)\n// =&gt; Expected string of length 10, but found length 5 ('hello')\n\nexpect null |&gt; to' (haveStringLength 5)\n// =&gt; Expected string of length 5, but found null\n</code></pre>"},{"location":"reference/matchers/strings/#case-insensitive","title":"Case Insensitive","text":""},{"location":"reference/matchers/strings/#equalignorecase","title":"equalIgnoreCase","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string equals the expected value (case-insensitive).</p> <p>Usage:</p> <pre><code>expect string |&gt; to' (equalIgnoreCase expected)\n</code></pre> <p>Examples:</p> <pre><code>expect \"HELLO\" |&gt; to' (equalIgnoreCase \"hello\")\nexpect \"FxSpec\" |&gt; to' (equalIgnoreCase \"fxspec\")\nexpect \"TeSt\" |&gt; to' (equalIgnoreCase \"test\")\n\n// Configuration keys\nlet configKey = \"DatabaseConnectionString\"\nexpect configKey |&gt; to' (equalIgnoreCase \"databaseconnectionstring\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"HELLO\" |&gt; to' (equalIgnoreCase \"goodbye\")\n// =&gt; Expected 'goodbye' (case-insensitive), but found 'HELLO'\n</code></pre> <p>Notes:</p> <ul> <li>Uses <code>StringComparison.OrdinalIgnoreCase</code></li> <li>Handles null correctly</li> <li>For exact case match, use <code>equal</code> from core matchers</li> </ul>"},{"location":"reference/matchers/strings/#character-types","title":"Character Types","text":""},{"location":"reference/matchers/strings/#bealphabetic","title":"beAlphabetic","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string contains only letters.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' beAlphabetic\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello\" |&gt; to' beAlphabetic\nexpect \"FxSpec\" |&gt; to' beAlphabetic\nexpect \"ABC\" |&gt; to' beAlphabetic\n\n// Fails\nexpect \"hello123\" |&gt; notTo' beAlphabetic  // Contains digits\nexpect \"hello world\" |&gt; notTo' beAlphabetic  // Contains space\nexpect \"\" |&gt; notTo' beAlphabetic  // Empty string\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello123\" |&gt; to' beAlphabetic\n// =&gt; Expected alphabetic string, but found 'hello123'\n\nexpect \"\" |&gt; to' beAlphabetic\n// =&gt; Expected alphabetic string, but found empty string\n</code></pre>"},{"location":"reference/matchers/strings/#benumeric","title":"beNumeric","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string contains only digits.</p> <p>Usage:</p> <pre><code>expect string |&gt; to' beNumeric\n</code></pre> <p>Examples:</p> <pre><code>expect \"12345\" |&gt; to' beNumeric\nexpect \"0\" |&gt; to' beNumeric\nexpect \"999\" |&gt; to' beNumeric\n\n// Fails\nexpect \"123.45\" |&gt; notTo' beNumeric  // Contains decimal point\nexpect \"12 34\" |&gt; notTo' beNumeric  // Contains space\nexpect \"\" |&gt; notTo' beNumeric  // Empty string\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"12.34\" |&gt; to' beNumeric\n// =&gt; Expected numeric string, but found '12.34'\n</code></pre> <p>Notes:</p> <ul> <li>Only accepts digits 0-9</li> <li>Does not accept decimal points, minus signs, or spaces</li> <li>For parsing numbers, use <code>Int32.TryParse</code> or similar</li> </ul>"},{"location":"reference/matchers/strings/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/strings/#testing-url-validation","title":"Testing URL Validation","text":"<pre><code>module UrlValidationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet urlValidationSpecs =\n    spec {\n        describe \"URL Validator\" [\n            describe \"validateUrl\" [\n                context \"when URL is valid\" [\n                    it \"accepts https URLs\" (fun () -&gt;\n                        let url = \"https://example.com\"\n                        expect url |&gt; to' (startWith \"https://\")\n                        expect url |&gt; to' (matchRegex @\"^https?://[\\w\\-]+(\\.[\\w\\-]+)+[/#?]?.*$\")\n                    )\n\n                    it \"accepts http URLs\" (fun () -&gt;\n                        let url = \"http://example.com/path?query=value\"\n                        expect url |&gt; to' (startWith \"http://\")\n                        expect url |&gt; to' (containSubstring \"example.com\")\n                    )\n\n                    it \"accepts URLs with paths\" (fun () -&gt;\n                        let url = \"https://example.com/api/users\"\n                        expect url |&gt; to' (containSubstring \"/api/users\")\n                        expect url |&gt; to' (endWith \"/users\")\n                    )\n                ]\n\n                context \"when URL is invalid\" [\n                    it \"rejects empty strings\" (fun () -&gt;\n                        expect \"\" |&gt; to' beEmptyString\n                        expect \"\" |&gt; notTo' (startWith \"http\")\n                    )\n\n                    it \"rejects non-URL strings\" (fun () -&gt;\n                        expect \"not a url\" |&gt; notTo' (matchRegex @\"^https?://\")\n                    )\n                ]\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/strings/#testing-string-transformations","title":"Testing String Transformations","text":"<pre><code>module StringTransformationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet stringTransformationSpecs =\n    spec {\n        describe \"StringHelpers\" [\n            describe \"slugify\" [\n                it \"converts to lowercase\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"Hello World\"\n                    expect result |&gt; to' (equalIgnoreCase \"hello-world\")\n                    expect result |&gt; to' (equal \"hello-world\")\n                )\n\n                it \"replaces spaces with hyphens\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"My Blog Post\"\n                    expect result |&gt; to' (equal \"my-blog-post\")\n                    expect result |&gt; notTo' (containSubstring \" \")\n                )\n\n                it \"removes special characters\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"Hello, World!\"\n                    expect result |&gt; to' (equal \"hello-world\")\n                    expect result |&gt; to' beAlphabetic  // False, contains hyphen\n                    expect result |&gt; to' (matchRegex @\"^[a-z\\-]+$\")\n                )\n            ]\n\n            describe \"sanitize\" [\n                it \"trims whitespace\" (fun () -&gt;\n                    let result = StringHelpers.sanitize \"  hello  \"\n                    expect result |&gt; to' (equal \"hello\")\n                    expect result |&gt; notTo' (startWith \" \")\n                    expect result |&gt; notTo' (endWith \" \")\n                )\n\n                it \"returns empty string for whitespace-only input\" (fun () -&gt;\n                    let result = StringHelpers.sanitize \"   \"\n                    expect result |&gt; to' beEmptyString\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/strings/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality matchers</li> <li>Collection Matchers - Collection matchers (strings are sequences of chars)</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Quick Start - Get started with FxSpec</li> </ul>"}]}