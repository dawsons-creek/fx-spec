{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FxSpec","text":"<ul> <li> <p> Pure F# BDD Testing Framework</p> <p>Write beautiful, expressive tests with F#'s type safety and functional programming. Inspired by RSpec, built for F#.</p> </li> </ul> <p>Get Started in 5 Minutes View on GitHub</p>"},{"location":"#why-fxspec","title":"Why FxSpec?","text":"<ul> <li> <p> Pure F#</p> <p>No dependencies on xUnit, NUnit, or MSTest. 100% idiomatic F# with clean, functional syntax.</p> <p>Built by F# developers, for F# developers.</p> </li> <li> <p> Type-Safe</p> <p>Leverage F#'s type system to catch errors at compile time. Type-specific expectations with IntelliSense.</p> <p>Fluent API provides only applicable methods for each type.</p> </li> <li> <p> Self-Hosting</p> <p>FxSpec tests itself using its own framework. Dogfooding ensures quality.</p> <p>52 tests and growing - battle-tested in production.</p> </li> <li> <p> RSpec-Inspired</p> <p>Familiar BDD syntax: <code>describe</code>, <code>it</code>, fluent expectations, and rich assertions.</p> <p>Coming from RSpec, Jest, or pytest? You'll feel at home.</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>module CalculatorSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet calculatorSpecs =\n    describe \"Calculator\" [\n        context \"when adding numbers\" [\n            it \"returns the sum\" (fun () -&gt;\n                let result = Calculator.add 2 3\n                expect(result).toEqual(5)\n            )\n\n            it \"handles negative numbers\" (fun () -&gt;\n                let result = Calculator.add -1 -2\n                expect(result).toEqual(-3)\n            )\n        ]\n\n        context \"when dividing numbers\" [\n            it \"returns the quotient\" (fun () -&gt;\n                let result = Calculator.divide 10 2\n                expect(result).toEqual(5)\n            )\n\n            it \"handles division by zero\" (fun () -&gt;\n                expectThrows&lt;System.ArgumentException&gt;(fun () -&gt; \n                    Calculator.divide 10 0 |&gt; ignore\n                )\n            )\n        ]\n    ]\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#expressive-dsl","title":"Expressive DSL","text":"<p>Write tests that read like documentation. The clean syntax creates an immutable test tree that's easy to understand and maintain.</p>"},{"location":"#fluent-expectations","title":"Fluent Expectations","text":"<p>Comprehensive fluent API for all common assertions:</p> <ul> <li>Core expectations: <code>expect().toEqual()</code>, <code>expect().notToEqual()</code></li> <li>Collections: <code>expectSeq().toContain()</code>, <code>expectSeq().toBeEmpty()</code>, <code>expectSeq().toHaveLength()</code></li> <li>Strings: <code>expectStr().toStartWith()</code>, <code>expectStr().toEndWith()</code>, <code>expectStr().toMatchRegex()</code></li> <li>Numeric: <code>expectNum().toBeGreaterThan()</code>, <code>expectFloat().toBeCloseTo()</code></li> <li>Exceptions: <code>expectThrows&lt;T&gt;()</code>, <code>expectNotToThrow()</code></li> <li>Options/Results: <code>expectOption().toBeSome()</code>, <code>expectResult().toBeOk()</code></li> </ul>"},{"location":"#beautiful-output","title":"Beautiful Output","text":"<p>Tests results with Spectre.Console:</p> <ul> <li>Color-coded pass/fail indicators</li> <li>Hierarchical test structure</li> <li>Diff visualization for failures</li> <li>Performance timing</li> </ul>"},{"location":"#focused-pending-tests","title":"Focused &amp; Pending Tests","text":"<p>Development workflow features:</p> <ul> <li><code>fit</code> - Focus on specific tests</li> <li><code>fdescribe</code> - Focus on test groups</li> <li><code>xit</code> / <code>pending</code> - Skip tests temporarily</li> </ul>"},{"location":"#hooks-setup","title":"Hooks &amp; Setup","text":"<p>Lifecycle hooks for test setup and teardown:</p> <ul> <li><code>beforeEach</code> / <code>afterEach</code> - Run before/after each test</li> <li><code>beforeAll</code> / <code>afterAll</code> - Run once per group</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Type-Safe Testing</p> <p>FxSpec leverages F#'s type system to make testing safer and more maintainable. Type-specific expectations provide IntelliSense support, and the test tree is immutable and validated at compile-time.</p> <p>Behavior-Driven Development</p> <p>Tests should describe behavior, not implementation. FxSpec's DSL encourages writing tests that serve as living documentation of your system's behavior.</p> <p>Functional Throughout</p> <p>Pure functions, immutable data, and functional composition. FxSpec embraces F#'s functional programming paradigm throughout its design.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p> Quick Start</p> <p>Get your first test running in 5 minutes.</p> </li> <li> <p> DSL Reference</p> <p>Learn about <code>spec</code>, <code>describe</code>, <code>it</code>, and all DSL functions.</p> </li> <li> <p> Matchers</p> <p>Explore the complete matcher library.</p> </li> <li> <p> Contributing</p> <p>Join the community and contribute to FxSpec.</p> </li> </ul>"},{"location":"#comparison","title":"Comparison","text":""},{"location":"#coming-from-xunitnunit","title":"Coming from xUnit/NUnit?","text":"<p>FxSpec uses BDD-style testing instead of attribute-based testing:</p> xUnit/NUnitFxSpec <pre><code>[&lt;Fact&gt;]\nlet ``adds two numbers`` () =\n    let result = Calculator.add 2 3\n    Assert.Equal(5, result)\n</code></pre> <pre><code>it \"adds two numbers\" (fun () -&gt;\n    let result = Calculator.add 2 3\n    expect(result).toEqual(5)\n)\n</code></pre> <p>Benefits:</p> <ul> <li>Tests read like specifications</li> <li>Better organization with <code>describe</code>/<code>context</code></li> <li>Hierarchical structure</li> <li>Richer failure messages</li> </ul>"},{"location":"#coming-from-rspecjest","title":"Coming from RSpec/Jest?","text":"<p>FxSpec's syntax will feel familiar:</p> RSpec (Ruby)FxSpec (F#)Jest (JavaScript) <pre><code>describe \"Calculator\" do\n  it \"adds numbers\" do\n    expect(2 + 2).to eq(4)\n  end\nend\n</code></pre> <pre><code>describe \"Calculator\" [\n    it \"adds numbers\" (fun () -&gt;\n        expect(2 + 2).toEqual(4)\n    )\n]\n</code></pre> <pre><code>describe(\"Calculator\", () =&gt; {\n  it(\"adds numbers\", () =&gt; {\n    expect(2 + 2).toBe(4)\n  })\n})\n</code></pre> <p>Key differences:</p> <ul> <li>F# uses lists <code>[]</code> instead of blocks <code>{}</code></li> <li>Fluent API uses method chaining: <code>expect(x).toEqual(y)</code></li> <li>Tests are wrapped in <code>fun () -&gt;</code> for lazy evaluation</li> <li>Type-specific expectations: <code>expectSeq</code>, <code>expectStr</code>, <code>expectNum</code>, etc.</li> </ul>"},{"location":"#whats-next","title":"What's Next?","text":"<p>Ready to dive in?</p> <ol> <li>Quick Start - Install FxSpec and write your first test</li> <li>DSL API - Learn all the DSL functions</li> <li>Matchers - Explore the matcher library</li> </ol> <p>Questions or feedback? Open an issue on GitHub</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Get your first FxSpec test running in 5 minutes.</p>"},{"location":"quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8.0 or .NET 9.0 SDK</li> <li>F# 8.0+ (included with .NET SDK)</li> <li>Basic F# knowledge</li> </ul>"},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#step-1-create-a-test-project","title":"Step 1: Create a Test Project","text":"<p>Create a new F# console project for your tests:</p> <pre><code>dotnet new console -lang F# -n MyProject.Tests\ncd MyProject.Tests\n</code></pre>"},{"location":"quick-start/#step-2-add-fxspec-packages","title":"Step 2: Add FxSpec Packages","text":"<p>Add the FxSpec packages to your project:</p> <pre><code>dotnet add package FxSpec.Core\ndotnet add package FxSpec.Matchers\ndotnet add package FxSpec.Runner\n</code></pre> <p>Package Status</p> <p>FxSpec packages are not yet published to NuGet. For now, you'll need to build from source or reference the local projects.</p>"},{"location":"quick-start/#your-first-test","title":"Your First Test","text":""},{"location":"quick-start/#step-1-create-a-test-file","title":"Step 1: Create a Test File","text":"<p>Create a new file called <code>MyFirstSpecs.fs</code> in your test project:</p> <pre><code>module MyFirstSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet myFirstSpecs =\n    describe \"My First Test Suite\" [\n        it \"passes!\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n\n        it \"checks equality\" (fun () -&gt;\n            let result = 2 + 2\n            expect(result).toEqual(4)\n        )\n\n        it \"works with strings\" (fun () -&gt;\n            let greeting = \"Hello, FxSpec!\"\n            expectStr(greeting).toStartWith(\"Hello\")\n        )\n    ]\n</code></pre>"},{"location":"quick-start/#step-2-update-your-fsproj","title":"Step 2: Update Your .fsproj","text":"<p>Make sure your test file is included in the project:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;Compile Include=\"MyFirstSpecs.fs\" /&gt;\n  &lt;Compile Include=\"Program.fs\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"quick-start/#step-3-update-programfs","title":"Step 3: Update Program.fs","text":"<p>Replace the contents of <code>Program.fs</code> with:</p> <pre><code>[&lt;EntryPoint&gt;]\nlet main args =\n    // FxSpec will automatically discover tests\n    0\n</code></pre>"},{"location":"quick-start/#step-4-run-your-tests","title":"Step 4: Run Your Tests","text":"<p>Run the tests using the FxSpec runner:</p> <pre><code>dotnet build\ndotnet run\n</code></pre> <p>You should see beautiful output like this:</p> <pre><code>My First Test Suite\n  \u2713 passes! (2ms)\n  \u2713 checks equality (1ms)\n  \u2713 works with strings (1ms)\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ... \u2502 Passed \u2502 Failed \u2502 Skipped \u2502 Duration \u2502\n\u2502  3  \u2502   3    \u2502   0    \u2502    0    \u2502  0.01s   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Congratulations!</p> <p>You've just written and run your first FxSpec tests!</p>"},{"location":"quick-start/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what you just wrote:</p>"},{"location":"quick-start/#the-test-structure","title":"The Test Structure","text":"<pre><code>[&lt;Tests&gt;]\nlet myFirstSpecs =\n    describe \"My First Test Suite\" [\n        // Individual tests go here\n    ]\n</code></pre> <p>FxSpec tests are simple values marked with the <code>[&lt;Tests&gt;]</code> attribute. The test discovery system finds these automatically.</p>"},{"location":"quick-start/#the-describe-function","title":"The <code>describe</code> Function","text":"<pre><code>describe \"My First Test Suite\" [\n    // Individual tests go here\n]\n</code></pre> <p><code>describe</code> groups related tests together. You can nest multiple <code>describe</code> blocks to create a hierarchy.</p>"},{"location":"quick-start/#the-it-function","title":"The <code>it</code> Function","text":"<pre><code>it \"passes!\" (fun () -&gt;\n    expectBool(true).toBeTrue()\n)\n</code></pre> <p><code>it</code> defines an individual test case:</p> <ul> <li>First parameter: Test description (string)</li> <li>Second parameter: Test function that makes assertions</li> </ul>"},{"location":"quick-start/#the-fluent-expectation-api","title":"The Fluent Expectation API","text":"<pre><code>expect(actual).toEqual(expected)\nexpectBool(value).toBeTrue()\nexpectSeq(list).toContain(item)\n</code></pre> <p>FxSpec provides type-specific expectation functions that return fluent wrappers:</p> <ul> <li><code>expect(value)</code> - Generic expectations for any type</li> <li><code>expectBool(value)</code> - Boolean assertions</li> <li><code>expectNum(value)</code> - Numeric comparisons</li> <li><code>expectSeq(value)</code> - Collection assertions</li> <li><code>expectStr(value)</code> - String matching</li> <li>And more...</li> </ul>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have FxSpec running, explore more features:</p>"},{"location":"quick-start/#organize-with-context","title":"Organize with Context","text":"<p>Use <code>context</code> to add more structure:</p> <pre><code>describe \"Calculator\" [\n    context \"when adding positive numbers\" [\n        it \"returns the sum\" (fun () -&gt;\n            expect(2 + 3).toEqual(5)\n        )\n    ]\n\n    context \"when adding negative numbers\" [\n        it \"handles negatives correctly\" (fun () -&gt;\n            expect(-2 + -3).toEqual(-5)\n        )\n    ]\n]\n</code></pre>"},{"location":"quick-start/#use-type-specific-expectations","title":"Use Type-Specific Expectations","text":"<p>Explore the type-specific expectation functions:</p> <pre><code>// Collections\nexpectSeq([1; 2; 3]).toContain(2)\nexpectSeq([]).toBeEmpty()\nexpectSeq([1; 2; 3]).toHaveLength(3)\n\n// Strings\nexpectStr(\"hello world\").toEndWith(\"world\")\nexpectStr(\"test@example.com\").toMatchRegex(@\"^\\w+@\\w+\\.\\w+$\")\n\n// Numeric\nexpectNum(10).toBeGreaterThan(5)\nexpectFloat(3.14159).toBeCloseTo(3.14, 0.01)\n\n// Options\nexpectOption(Some 42).toBeSome(42)\nexpectOption(None).toBeNone()\n\n// Results\nexpectResult(Ok \"success\").toBeOk(\"success\")\nexpectResult(Error \"failed\").toBeError(\"failed\")\n\n// Exceptions\nexpectThrows&lt;System.ArgumentException&gt;(fun () -&gt; \n    invalidArg \"param\" \"message\"\n)\n</code></pre>"},{"location":"quick-start/#negative-assertions","title":"Negative Assertions","text":"<p>Use <code>.notTo...</code> methods for negative assertions:</p> <pre><code>expect(5).notToEqual(10)\nexpectStr(\"hello\").notToStartWith(\"bye\")\nexpectSeq([1; 2; 3]).notToBeEmpty()\n</code></pre>"},{"location":"quick-start/#focus-on-specific-tests","title":"Focus on Specific Tests","text":"<p>During development, focus on specific tests:</p> <pre><code>describe \"My Suite\" [\n    fit \"only run this test\" (fun () -&gt;  // (1)!\n        expectBool(true).toBeTrue()\n    )\n\n    it \"this test will be skipped\" (fun () -&gt;\n        expectBool(false).toBeTrue()\n    )\n]\n</code></pre> <ol> <li><code>fit</code> (focused it) runs only this test. Use <code>fdescribe</code> to focus an entire group.</li> </ol>"},{"location":"quick-start/#skip-tests-temporarily","title":"Skip Tests Temporarily","text":"<p>Mark tests as pending:</p> <pre><code>describe \"My Suite\" [\n    it \"working test\" (fun () -&gt;\n        expectBool(true).toBeTrue()\n    )\n\n    xit \"not ready yet\" (fun () -&gt;  // (1)!\n        expectBool(false).toBeTrue()\n    )\n\n    pending \"TODO: implement this test\" (fun () -&gt;  // (2)!\n        ()\n    )\n]\n</code></pre> <ol> <li><code>xit</code> (excluded it) skips this test</li> <li><code>pending</code> is an alias for <code>xit</code> that reads better for unfinished tests</li> </ol>"},{"location":"quick-start/#setup-and-teardown","title":"Setup and Teardown","text":"<p>Use hooks for test setup:</p> <pre><code>describe \"Database Tests\" [\n    let mutable connection = null\n\n    beforeEach (fun () -&gt;\n        connection &lt;- Database.connect()\n    )\n\n    afterEach (fun () -&gt;\n        connection.Dispose()\n    )\n\n    it \"queries the database\" (fun () -&gt;\n        let result = connection.Query(\"SELECT 1\")\n        expectSeq(result).notToBeEmpty()\n    )\n]\n</code></pre>"},{"location":"quick-start/#testing-your-own-code","title":"Testing Your Own Code","text":"<p>Here's a complete example testing a simple calculator:</p> <pre><code>// Calculator.fs\nmodule Calculator\n\nlet add x y = x + y\nlet subtract x y = x - y\nlet multiply x y = x * y\nlet divide x y =\n    if y = 0 then\n        invalidArg (nameof y) \"Cannot divide by zero\"\n    else\n        x / y\n</code></pre> <pre><code>// CalculatorSpecs.fs\nmodule CalculatorSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet calculatorSpecs =\n    describe \"Calculator\" [\n        describe \"add\" [\n            it \"adds positive numbers\" (fun () -&gt;\n                expect(Calculator.add 2 3).toEqual(5)\n            )\n\n            it \"adds negative numbers\" (fun () -&gt;\n                expect(Calculator.add -1 -2).toEqual(-3)\n            )\n\n            it \"adds mixed numbers\" (fun () -&gt;\n                expect(Calculator.add 10 -5).toEqual(5)\n            )\n        ]\n\n        describe \"divide\" [\n            it \"divides evenly\" (fun () -&gt;\n                expect(Calculator.divide 10 2).toEqual(5)\n            )\n\n            it \"raises exception on division by zero\" (fun () -&gt;\n                expectThrows&lt;System.ArgumentException&gt;(fun () -&gt; \n                    Calculator.divide 10 0 |&gt; ignore\n                )\n            )\n        ]\n    ]\n</code></pre>"},{"location":"quick-start/#running-tests","title":"Running Tests","text":""},{"location":"quick-start/#basic-run","title":"Basic Run","text":"<pre><code>dotnet run\n</code></pre>"},{"location":"quick-start/#run-specific-tests","title":"Run Specific Tests","text":"<pre><code>dotnet run -- --filter \"Calculator\"\n</code></pre>"},{"location":"quick-start/#choose-output-format","title":"Choose Output Format","text":"<pre><code># Documentation format (default, colorful)\ndotnet run -- --format documentation\n\n# Simple format (plain text)\ndotnet run -- --format simple\n</code></pre>"},{"location":"quick-start/#async-testing","title":"Async Testing","text":"<p>FxSpec supports asynchronous tests using <code>itAsync</code>:</p> <pre><code>open System.Net.Http\n\n[&lt;Tests&gt;]\nlet asyncSpecs =\n    describe \"Async Operations\" [\n        itAsync \"fetches data from API\" (async {\n            use client = new HttpClient()\n            let! response = client.GetAsync(\"https://api.github.com\") |&gt; Async.AwaitTask\n            expectHttp(response).toHaveStatusOk()\n        })\n\n        itAsync \"handles async computations\" (async {\n            let! result = async {\n                return 42\n            }\n            expect(result).toEqual(42)\n        })\n    ]\n</code></pre> <p>Key Points: - Use <code>itAsync</code> instead of <code>it</code> for async tests - Wrap test in <code>async { }</code> computation expression - Use <code>let!</code> to await async operations - Use <code>Async.AwaitTask</code> to convert .NET Tasks to F# Async</p> <p>For more details, see DSL API Reference.</p>"},{"location":"quick-start/#result-testing","title":"Result Testing","text":"<p>Test F# Result types with state-only or value-specific matchers:</p> <pre><code>[&lt;Tests&gt;]\nlet resultSpecs =\n    describe \"Result Matchers\" [\n        it \"checks success state\" (fun () -&gt;\n            let result = Ok 42\n            expectResult(result).toBeOk()  // Just check it succeeded\n        )\n\n        it \"checks specific success value\" (fun () -&gt;\n            let result = Ok \"success\"\n            expectResult(result).toBeOk(\"success\")  // Check value too\n        )\n\n        it \"checks error state\" (fun () -&gt;\n            let result = Error \"failed\"\n            expectResult(result).toBeError()  // Just check it failed\n        )\n    ]\n</code></pre> <p>For more details, see Result Matchers.</p>"},{"location":"quick-start/#http-testing","title":"HTTP Testing","text":"<p>Test HTTP responses with the fluent HTTP API:</p> <pre><code>open FxSpec.Http\nopen System.Net.Http\n\n[&lt;Tests&gt;]\nlet httpSpecs =\n    describe \"HTTP API Tests\" [\n        itAsync \"validates API response\" (async {\n            use client = new HttpClient()\n            let! response = client.GetAsync(\"https://api.example.com/users\") |&gt; Async.AwaitTask\n\n            expectHttp(response).toHaveStatusOk()\n            expectHttp(response).toHaveContentType(\"application/json\")\n            expectHttp(response).toHaveBodyContaining(\"users\")\n        })\n    ]\n</code></pre> <p>For more details, see HTTP Testing.</p>"},{"location":"quick-start/#whats-next","title":"What's Next?","text":"<p>You now have a solid foundation in FxSpec. Continue learning:</p> <ul> <li> <p> DSL API Reference</p> <p>Complete reference for all DSL functions</p> </li> <li> <p> Core Matchers</p> <p>Learn about all available matchers</p> </li> <li> <p> Contributing</p> <p>Help improve FxSpec</p> </li> </ul>"},{"location":"quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quick-start/#tests-not-discovered","title":"Tests Not Discovered","text":"<p>Make sure your test module has the <code>[&lt;Tests&gt;]</code> attribute:</p> <pre><code>[&lt;Tests&gt;]  // Don't forget this!\nlet mySpecs = describe \"...\" [...]\n</code></pre>"},{"location":"quick-start/#compilation-errors","title":"Compilation Errors","text":"<p>Common issues:</p> <ol> <li>Missing opens: Make sure you have both <code>open FxSpec.Core</code> and <code>open FxSpec.Matchers</code></li> <li>Wrong expectation type: Use the appropriate type-specific function (e.g., <code>expectSeq</code> for collections, <code>expectStr</code> for strings)</li> <li>Missing parentheses: Remember to wrap your test in <code>fun () -&gt;</code> for lazy evaluation</li> <li>Method not available: IntelliSense will show you the available methods for each expectation type</li> </ol>"},{"location":"quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Open an issue on GitHub</li> <li>Check existing issues for similar problems</li> <li>Read the Contributing Guide to submit bug reports</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions when using FxSpec.</p>"},{"location":"troubleshooting/#test-discovery-issues","title":"Test Discovery Issues","text":""},{"location":"troubleshooting/#no-tests-found-in-assembly","title":"\"No tests found in assembly\"","text":"<p>Symptoms:</p> <pre><code>FxSpec Test Runner\n==================\n\nNo tests found in assembly\n</code></pre> <p>Causes &amp; Solutions:</p>"},{"location":"troubleshooting/#missing-tests-attribute","title":"Missing <code>[&lt;Tests&gt;]</code> Attribute","text":"<p>Problem: Test module doesn't have the <code>[&lt;Tests&gt;]</code> attribute.</p> <pre><code>// \u274c Wrong - no attribute\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre> <p>Solution: Add the <code>[&lt;Tests&gt;]</code> attribute:</p> <pre><code>// \u2705 Correct\n[&lt;Tests&gt;]\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#wrong-return-type","title":"Wrong Return Type","text":"<p>Problem: Test member doesn't return <code>TestNode list</code>.</p> <pre><code>// \u274c Wrong - returns unit\n[&lt;Tests&gt;]\nlet mySpecs () =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre> <p>Solution: Return <code>TestNode list</code>:</p> <pre><code>// \u2705 Correct\n[&lt;Tests&gt;]\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#non-static-member","title":"Non-Static Member","text":"<p>Problem: Test member is not static.</p> <pre><code>// \u274c Wrong - instance member\ntype MyTests() =\n    [&lt;Tests&gt;]\n    member this.Specs =\n        spec { ... }\n</code></pre> <p>Solution: Make it static:</p> <pre><code>// \u2705 Correct\ntype MyTests =\n    [&lt;Tests&gt;]\n    static member Specs =\n        spec { ... }\n\n// Or use module-level let binding\nmodule MyTests\n\n[&lt;Tests&gt;]\nlet specs =\n    spec { ... }\n</code></pre>"},{"location":"troubleshooting/#compilation-errors","title":"Compilation Errors","text":""},{"location":"troubleshooting/#the-value-or-constructor-spec-is-not-defined","title":"\"The value or constructor 'spec' is not defined\"","text":"<p>Problem: Missing <code>open FxSpec.Core</code>.</p> <p>Solution:</p> <pre><code>open FxSpec.Core  // \u2190 Add this\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet mySpecs = spec { ... }\n</code></pre>"},{"location":"troubleshooting/#the-value-or-constructor-expect-is-not-defined","title":"\"The value or constructor 'expect' is not defined\"","text":"<p>Problem: Missing <code>open FxSpec.Matchers</code>.</p> <p>Solution:</p> <pre><code>open FxSpec.Core\nopen FxSpec.Matchers  // \u2190 Add this\n\n[&lt;Tests&gt;]\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt;\n                expect true |&gt; should beTrue\n            )\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#this-expression-was-expected-to-have-type-testnode-list-but-here-has-type-testnode","title":"\"This expression was expected to have type 'TestNode list' but here has type 'TestNode'\"","text":"<p>Problem: Missing <code>yield</code> keyword in spec block.</p> <pre><code>// \u274c Wrong\nspec {\n    describe \"Feature\" [  // Missing yield\n        it \"test\" (fun () -&gt; ...)\n    ]\n}\n</code></pre> <p>Solution: Add <code>yield</code>:</p> <pre><code>// \u2705 Correct\nspec {\n    yield describe \"Feature\" [\n        it \"test\" (fun () -&gt; ...)\n    ]\n}\n</code></pre>"},{"location":"troubleshooting/#this-expression-was-expected-to-have-type-unit-unit-but-here-has-type-unit","title":"\"This expression was expected to have type 'unit -&gt; unit' but here has type 'unit'\"","text":"<p>Problem: Test code not wrapped in a function.</p> <pre><code>// \u274c Wrong\nit \"test\" (\n    expect true |&gt; should beTrue  // Not wrapped\n)\n</code></pre> <p>Solution: Wrap in <code>(fun () -&gt; ...)</code>:</p> <pre><code>// \u2705 Correct\nit \"test\" (fun () -&gt;\n    expect true |&gt; should beTrue\n)\n</code></pre>"},{"location":"troubleshooting/#matcher-type-errors","title":"Matcher Type Errors","text":""},{"location":"troubleshooting/#type-mismatch-with-matchers","title":"\"Type mismatch\" with Matchers","text":"<p>Problem: Matcher type doesn't match actual value type.</p> <pre><code>// \u274c Wrong - comparing int to string\nexpect 42 |&gt; should (equal \"42\")\n</code></pre> <p>Solution: Ensure types match:</p> <pre><code>// \u2705 Correct\nexpect 42 |&gt; should (equal 42)\nexpect \"42\" |&gt; should (equal \"42\")\n</code></pre>"},{"location":"troubleshooting/#this-expression-was-expected-to-have-type-matchera-but-here-has-type-matchresult","title":"\"This expression was expected to have type 'Matcher&lt;'a&gt;' but here has type 'MatchResult'\"","text":"<p>Problem: Calling matcher function instead of passing it.</p> <pre><code>// \u274c Wrong - calling equal with ()\nexpect 42 |&gt; should (equal 42 ())\n</code></pre> <p>Solution: Don't call the matcher:</p> <pre><code>// \u2705 Correct\nexpect 42 |&gt; should (equal 42)\n</code></pre>"},{"location":"troubleshooting/#the-type-string-does-not-support-the-comparison-constraint","title":"\"The type 'string' does not support the comparison constraint\"","text":"<p>Problem: Using numeric matchers on non-comparable types.</p> <pre><code>// \u274c Wrong - can't compare functions\nlet f = fun x -&gt; x + 1\nexpect f |&gt; should (beGreaterThan (fun x -&gt; x))\n</code></pre> <p>Solution: Use appropriate matchers for the type:</p> <pre><code>// \u2705 Correct - use equality for functions\nlet f = fun x -&gt; x + 1\nexpect (f 5) |&gt; should (equal 6)\n</code></pre>"},{"location":"troubleshooting/#runtime-errors","title":"Runtime Errors","text":""},{"location":"troubleshooting/#assembly-not-found-or-could-not-load-file-or-assembly","title":"\"Assembly not found\" or \"Could not load file or assembly\"","text":"<p>Problem: Assembly path is incorrect or assembly not built.</p> <p>Solution:</p> <pre><code># 1. Build the test project first\ndotnet build tests/MyProject.Tests/MyProject.Tests.fsproj\n\n# 2. Use the correct path to the built assembly\ndotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n  tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n</code></pre>"},{"location":"troubleshooting/#no-tests-match-the-filter","title":"\"No tests match the filter\"","text":"<p>Problem: Filter pattern doesn't match any test descriptions.</p> <p>Symptoms:</p> <pre><code>Filtering tests by: MyTest\nRunning 0 filtered examples\n\nNo tests match the filter\n</code></pre> <p>Solutions:</p> <ol> <li>Check case sensitivity - filters are case-sensitive:</li> </ol> <pre><code># \u274c Wrong\n./run-tests.sh --filter \"calculator\"\n\n# \u2705 Correct\n./run-tests.sh --filter \"Calculator\"\n</code></pre> <ol> <li>Use partial matches:</li> </ol> <pre><code># \u274c Too specific\n./run-tests.sh --filter \"Calculator &gt; addition &gt; adds two numbers\"\n\n# \u2705 Better\n./run-tests.sh --filter \"addition\"\n</code></pre> <ol> <li>Remove filter to see all test names:</li> </ol> <pre><code>./run-tests.sh\n</code></pre>"},{"location":"troubleshooting/#tests-run-but-all-fail-with-object-reference-not-set","title":"Tests Run But All Fail with \"Object reference not set\"","text":"<p>Problem: Hooks or test setup not running correctly.</p> <p>Common Causes:</p> <ol> <li>Using mutable variables without initialization:</li> </ol> <pre><code>// \u274c Wrong\ndescribe \"Database\" [\n    let mutable connection = null  // null reference\n\n    it \"queries data\" (fun () -&gt;\n        connection.Query(\"SELECT 1\")  // NullReferenceException\n    )\n]\n</code></pre> <p>Solution: Use <code>beforeEach</code> to initialize:</p> <pre><code>// \u2705 Correct\ndescribe \"Database\" [\n    let mutable connection = null\n\n    beforeEach (fun () -&gt;\n        connection &lt;- Database.connect()\n    )\n\n    it \"queries data\" (fun () -&gt;\n        connection.Query(\"SELECT 1\")\n    )\n]\n</code></pre>"},{"location":"troubleshooting/#test-execution-issues","title":"Test Execution Issues","text":""},{"location":"troubleshooting/#tests-pass-individually-but-fail-when-run-together","title":"Tests Pass Individually But Fail When Run Together","text":"<p>Problem: Tests are not isolated - they share state.</p> <p>Solution: Use <code>beforeEach</code> and <code>afterEach</code> for proper isolation:</p> <pre><code>describe \"User Tests\" [\n    let mutable user = null\n\n    beforeEach (fun () -&gt;\n        user &lt;- createUser()  // Fresh user for each test\n    )\n\n    afterEach (fun () -&gt;\n        deleteUser(user)  // Clean up after each test\n    )\n\n    it \"test 1\" (fun () -&gt; ...)\n    it \"test 2\" (fun () -&gt; ...)\n]\n</code></pre>"},{"location":"troubleshooting/#focused-tests-not-running","title":"Focused Tests Not Running","text":"<p>Problem: Using <code>fit</code> or <code>fdescribe</code> but all tests still run.</p> <p>Cause: Focused filtering only works when tests are discovered together.</p> <p>Solution: Ensure all tests are in the same assembly and discovered together:</p> <pre><code>// \u2705 Correct - both in same spec\n[&lt;Tests&gt;]\nlet specs =\n    spec {\n        yield describe \"Suite\" [\n            fit \"only this runs\" (fun () -&gt; ...)\n            it \"this is skipped\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#pending-tests-still-running","title":"Pending Tests Still Running","text":"<p>Problem: Using <code>xit</code> but test still executes.</p> <p>Cause: Typo in function name.</p> <pre><code>// \u274c Wrong - typo\nxIt \"test\" (fun () -&gt; ...)  // Capital I\n</code></pre> <p>Solution: Use correct function name:</p> <pre><code>// \u2705 Correct\nxit \"test\" (fun () -&gt; ...)  // lowercase i\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#tests-running-slowly","title":"Tests Running Slowly","text":"<p>Causes &amp; Solutions:</p>"},{"location":"troubleshooting/#using-beforeeach-for-expensive-setup","title":"Using <code>beforeEach</code> for Expensive Setup","text":"<p>Problem: Expensive setup runs before every test.</p> <pre><code>// \u274c Slow - database created for each test\nbeforeEach (fun () -&gt;\n    createDatabase()  // Expensive!\n)\n</code></pre> <p>Solution: Use <code>beforeAll</code> for expensive setup:</p> <pre><code>// \u2705 Fast - database created once\nbeforeAll (fun () -&gt;\n    createDatabase()\n)\n\nbeforeEach (fun () -&gt;\n    clearData()  // Fast cleanup\n)\n</code></pre>"},{"location":"troubleshooting/#not-cleaning-up-resources","title":"Not Cleaning Up Resources","text":"<p>Problem: Resources accumulate during test run.</p> <p>Solution: Use <code>afterEach</code> or <code>afterAll</code>:</p> <pre><code>describe \"File Tests\" [\n    let mutable tempFile = \"\"\n\n    beforeEach (fun () -&gt;\n        tempFile &lt;- Path.GetTempFileName()\n    )\n\n    afterEach (fun () -&gt;\n        File.Delete(tempFile)  // Clean up\n    )\n\n    it \"test\" (fun () -&gt; ...)\n]\n</code></pre>"},{"location":"troubleshooting/#ide-integration-issues","title":"IDE Integration Issues","text":""},{"location":"troubleshooting/#tests-not-discovered-in-ide","title":"Tests Not Discovered in IDE","text":"<p>Problem: FxSpec doesn't integrate with standard .NET test explorers.</p> <p>Explanation: FxSpec uses its own test runner, not the standard .NET test framework.</p> <p>Workaround: Run tests from command line:</p> <pre><code>./run-tests.sh\n</code></pre> <p>Future: IDE integration is planned for future releases.</p>"},{"location":"troubleshooting/#syntax-highlighting-issues","title":"Syntax Highlighting Issues","text":"<p>Problem: F# syntax highlighting doesn't work well with FxSpec DSL.</p> <p>Solution: This is a limitation of current F# tooling. The code is valid F# even if highlighting is imperfect.</p>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you encounter an issue not covered here:</p> <ol> <li>Check the documentation:</li> <li>Quick Start Guide</li> <li>DSL API Reference</li> <li> <p>Test Runner</p> </li> <li> <p>Search existing issues: GitHub Issues</p> </li> <li> <p>Ask for help:</p> </li> <li> <p>Open a new issue with:</p> <ul> <li>FxSpec version</li> <li>.NET version</li> <li>Minimal reproduction code</li> <li>Error messages</li> <li>What you've tried</li> </ul> </li> <li> <p>Contribute: Found a bug? Submit a PR!</p> </li> </ol>"},{"location":"troubleshooting/#common-gotchas","title":"Common Gotchas","text":""},{"location":"troubleshooting/#1-forgetting-yield","title":"1. Forgetting <code>yield</code>","text":"<pre><code>// \u274c Won't compile\nspec {\n    describe \"Test\" [ ... ]\n}\n\n// \u2705 Correct\nspec {\n    yield describe \"Test\" [ ... ]\n}\n</code></pre>"},{"location":"troubleshooting/#2-not-wrapping-test-code-in-function","title":"2. Not Wrapping Test Code in Function","text":"<pre><code>// \u274c Won't compile\nit \"test\" (expect true |&gt; should beTrue)\n\n// \u2705 Correct\nit \"test\" (fun () -&gt; expect true |&gt; should beTrue)\n</code></pre>"},{"location":"troubleshooting/#3-using-instead-of","title":"3. Using <code>{}</code> Instead of <code>[]</code>","text":"<pre><code>// \u274c Wrong syntax\ndescribe \"Test\" {\n    it \"test\" { ... }\n}\n\n// \u2705 Correct syntax\ndescribe \"Test\" [\n    it \"test\" (fun () -&gt; ...)\n]\n</code></pre>"},{"location":"troubleshooting/#4-forgetting-tests-attribute","title":"4. Forgetting <code>[&lt;Tests&gt;]</code> Attribute","text":"<pre><code>// \u274c Tests won't be discovered\nlet mySpecs = spec { ... }\n\n// \u2705 Tests will be discovered\n[&lt;Tests&gt;]\nlet mySpecs = spec { ... }\n</code></pre>"},{"location":"troubleshooting/#5-wrong-open-statements","title":"5. Wrong <code>open</code> Statements","text":"<pre><code>// \u274c Missing opens\nlet specs = spec { ... }  // Error: 'spec' not defined\n\n// \u2705 Correct opens\nopen FxSpec.Core\nopen FxSpec.Matchers\n\nlet specs = spec { ... }\n</code></pre>"},{"location":"troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Quick Start Guide - Getting started</li> <li>DSL API Reference - Complete DSL documentation</li> <li>Test Runner - Runner options and usage</li> <li>Contributing - How to contribute</li> </ul>"},{"location":"community/contributing/","title":"Contributing to FxSpec","text":"<p>Thank you for your interest in contributing to FxSpec! This document provides guidelines and instructions for contributing.</p>"},{"location":"community/contributing/#getting-started","title":"Getting Started","text":""},{"location":"community/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8.0 or .NET 9.0 SDK</li> <li>F# 8.0+ (included with .NET SDK)</li> <li>Git</li> <li>Basic F# knowledge</li> <li>Familiarity with BDD testing concepts</li> </ul>"},{"location":"community/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li>Fork and clone the repository:</li> </ol> <pre><code>git clone https://github.com/fxspec/fx-spec.git\ncd fx-spec\n</code></pre> <ol> <li>Build the solution:</li> </ol> <pre><code>dotnet build\n</code></pre> <ol> <li>Run the tests:</li> </ol> <pre><code>./run-tests.sh\n</code></pre> <p>You should see all tests passing. FxSpec uses itself for testing (dogfooding).</p>"},{"location":"community/contributing/#building-the-project","title":"Building the Project","text":""},{"location":"community/contributing/#project-structure","title":"Project Structure","text":"<pre><code>fx-spec/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 FxSpec.Core/          # Core DSL and test tree\n\u2502   \u251c\u2500\u2500 FxSpec.Matchers/      # Assertion matchers\n\u2502   \u2514\u2500\u2500 FxSpec.Runner/        # Test discovery and execution\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 FxSpec.Core.Tests/    # Tests for Core\n\u2502   \u2514\u2500\u2500 FxSpec.Matchers.Tests/# Tests for Matchers\n\u251c\u2500\u2500 examples/                  # Example usage\n\u2514\u2500\u2500 docs/                      # Documentation\n</code></pre>"},{"location":"community/contributing/#build-commands","title":"Build Commands","text":"<pre><code># Build everything\ndotnet build\n\n# Build specific project\ndotnet build src/FxSpec.Core/FxSpec.Core.fsproj\n\n# Clean build\ndotnet clean\ndotnet build\n\n# Release build\ndotnet build -c Release\n</code></pre>"},{"location":"community/contributing/#running-tests","title":"Running Tests","text":"<p>FxSpec tests itself using its own framework.</p>"},{"location":"community/contributing/#run-all-tests","title":"Run All Tests","text":"<pre><code>./run-tests.sh\n</code></pre>"},{"location":"community/contributing/#run-specific-tests","title":"Run Specific Tests","text":"<pre><code># Filter by test description\n./run-tests.sh --filter \"SpecBuilder\"\n\n# Use simple formatter\n./run-tests.sh --format simple\n</code></pre>"},{"location":"community/contributing/#run-tests-manually","title":"Run Tests Manually","text":"<pre><code># Build and run\ndotnet build tests/FxSpec.Core.Tests/FxSpec.Core.Tests.fsproj\ndotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n  tests/FxSpec.Core.Tests/bin/Debug/net9.0/FxSpec.Core.Tests.dll\n</code></pre>"},{"location":"community/contributing/#code-style","title":"Code Style","text":""},{"location":"community/contributing/#f-conventions","title":"F# Conventions","text":"<p>FxSpec follows standard F# conventions:</p> <ul> <li>Naming:</li> <li><code>camelCase</code> for functions and values</li> <li><code>PascalCase</code> for types, modules, and DU cases</li> <li> <p>Prefix private functions with <code>private</code> keyword</p> </li> <li> <p>Code Organization:</p> </li> <li>Group related functions together</li> <li>Use <code>/// XML comments</code> for public APIs</li> <li> <p>Keep functions focused and small (prefer &lt; 25 lines)</p> </li> <li> <p>Pattern Matching:</p> </li> <li>Use <code>function</code> shorthand for single-argument pattern matching</li> <li>Match exhaustively (compiler enforces this)</li> <li>Put most common cases first</li> </ul>"},{"location":"community/contributing/#example","title":"Example","text":"<pre><code>/// Builds the full path to a test node.\nlet rec buildTestPath (path: string list) (node: TestResultNode) : (string * TestResult * TimeSpan) list =\n    match node with\n    | ExampleResult (desc, result, duration) -&gt;\n        let fullPath = (path @ [desc]) |&gt; String.concat \" &gt; \"\n        [(fullPath, result, duration)]\n    | GroupResult (desc, children) -&gt;\n        let newPath = path @ [desc]\n        children |&gt; List.collect (buildTestPath newPath)\n</code></pre>"},{"location":"community/contributing/#code-quality","title":"Code Quality","text":"<ul> <li>No compiler warnings: Code must compile without warnings</li> <li>Follow best practices:</li> <li>Prefer pure functions</li> <li>Minimize mutable state</li> <li>Use type constraints appropriately</li> <li>Avoid magic numbers (use named constants)</li> <li>Write tests: All new features must have tests</li> <li>Document public APIs: Use XML comments for all public functions</li> </ul>"},{"location":"community/contributing/#making-changes","title":"Making Changes","text":""},{"location":"community/contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n# or\ngit checkout -b fix/bug-description\n</code></pre>"},{"location":"community/contributing/#branch-naming","title":"Branch Naming","text":"<ul> <li><code>feature/</code> - New features</li> <li><code>fix/</code> - Bug fixes</li> <li><code>docs/</code> - Documentation changes</li> <li><code>refactor/</code> - Code refactoring</li> </ul>"},{"location":"community/contributing/#2-write-code","title":"2. Write Code","text":"<ul> <li>Follow F# conventions and code style</li> <li>Add tests for new functionality</li> <li>Update documentation if needed</li> </ul>"},{"location":"community/contributing/#3-write-tests","title":"3. Write Tests","text":"<p>All code changes must include tests. FxSpec tests itself:</p> <pre><code>module MyNewFeatureSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet myNewFeatureSpecs =\n    spec {\n        describe \"MyNewFeature\" [\n            it \"works as expected\" (fun () -&gt;\n                let result = MyNewFeature.doSomething()\n                expect result |&gt; should (equal expectedValue)\n            )\n        ]\n    }\n</code></pre>"},{"location":"community/contributing/#4-run-tests","title":"4. Run Tests","text":"<pre><code>./run-tests.sh\n</code></pre> <p>All tests must pass before submitting a pull request.</p>"},{"location":"community/contributing/#5-commit-changes","title":"5. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"feat: add new feature description\"\n</code></pre>"},{"location":"community/contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commits format:</p> <pre><code>type(scope): description\n\n[optional body]\n</code></pre> <p>Types: - <code>feat:</code> - New feature - <code>fix:</code> - Bug fix - <code>docs:</code> - Documentation changes - <code>refactor:</code> - Code refactoring - <code>test:</code> - Adding or updating tests - <code>chore:</code> - Maintenance tasks</p> <p>Examples:</p> <pre><code>feat(matchers): add bePositive and beNegative matchers\nfix(runner): handle null test descriptions correctly\ndocs(quick-start): update installation instructions\nrefactor(core): simplify test tree building\n</code></pre>"},{"location":"community/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"community/contributing/#1-push-your-branch","title":"1. Push Your Branch","text":"<pre><code>git push origin feature/my-new-feature\n</code></pre>"},{"location":"community/contributing/#2-open-pull-request","title":"2. Open Pull Request","text":"<ul> <li>Go to GitHub and open a pull request</li> <li>Fill in the PR template</li> <li>Link any related issues</li> </ul>"},{"location":"community/contributing/#pr-title","title":"PR Title","text":"<p>Follow the same format as commit messages:</p> <pre><code>feat(matchers): add numeric comparison matchers\nfix(runner): prevent crash on empty test suite\n</code></pre>"},{"location":"community/contributing/#pr-description","title":"PR Description","text":"<p>Include:</p> <ul> <li>What: What changes did you make?</li> <li>Why: Why are these changes needed?</li> <li>How: How did you implement the changes?</li> <li>Testing: How did you test the changes?</li> </ul>"},{"location":"community/contributing/#example-pr-description","title":"Example PR Description","text":"<pre><code>## What\n\nAdd `bePositive`, `beNegative`, and `beZero` matchers for numeric comparisons.\n\n## Why\n\nUsers need a convenient way to test if numbers are positive, negative, or zero without writing custom matchers or using comparison operators.\n\n## How\n\n- Added three new matchers in `NumericMatchers.fs`\n- Used inline functions with generic numeric constraints\n- Leveraged `LanguagePrimitives.GenericZero`\n\n## Testing\n\n- Added comprehensive tests in `NumericMatchersSpecs.fs`\n- Tested with int, float, and decimal types\n- All 166 tests passing\n</code></pre>"},{"location":"community/contributing/#3-code-review","title":"3. Code Review","text":"<ul> <li>Address reviewer feedback</li> <li>Update code as needed</li> <li>Push changes to the same branch</li> <li>PR will update automatically</li> </ul>"},{"location":"community/contributing/#4-merge","title":"4. Merge","text":"<p>Once approved: - Squash and merge (preferred) - Merge commit (for multi-commit features) - Rebase and merge (for clean history)</p>"},{"location":"community/contributing/#areas-to-contribute","title":"Areas to Contribute","text":""},{"location":"community/contributing/#matchers","title":"Matchers","text":"<p>We always welcome new matchers! Ideas:</p> <ul> <li>DateTime matchers: <code>beToday</code>, <code>beBefore</code>, <code>beAfter</code>, <code>beInYear</code></li> <li>Async matchers: Matchers for <code>Async&lt;'T&gt;</code> and <code>Task&lt;'T&gt;</code></li> <li>File/IO matchers: <code>fileExist</code>, <code>directoryExist</code>, <code>haveExtension</code></li> <li>JSON matchers: Matchers for JSON comparison</li> </ul>"},{"location":"community/contributing/#formatters","title":"Formatters","text":"<ul> <li>Alternative output formats (JSON, JUnit XML, TAP)</li> <li>Integration with test reporting tools</li> <li>VS Code extension support</li> </ul>"},{"location":"community/contributing/#documentation","title":"Documentation","text":"<ul> <li>Tutorial content</li> <li>How-to guides</li> <li>Example projects</li> <li>Blog posts</li> </ul>"},{"location":"community/contributing/#bug-fixes","title":"Bug Fixes","text":"<p>Check open issues for bugs to fix.</p>"},{"location":"community/contributing/#documentation_1","title":"Documentation","text":""},{"location":"community/contributing/#building-documentation","title":"Building Documentation","text":"<p>Documentation uses Material for MkDocs:</p> <pre><code># Install dependencies (first time only)\nuv venv\nuv pip install mkdocs-material mkdocs-mermaid2-plugin\n\n# Serve locally\nuv run mkdocs serve\n\n# Open http://127.0.0.1:8000\n</code></pre>"},{"location":"community/contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Add practical use cases</li> <li>Follow existing structure</li> </ul> <p>Documentation structure follows the Di\u00e1taxis framework:</p> <ul> <li>Tutorials: Learning-oriented lessons</li> <li>How-To Guides: Task-oriented directions</li> <li>Reference: Information-oriented descriptions</li> <li>Explanation: Understanding-oriented discussions</li> </ul>"},{"location":"community/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"community/contributing/#test-organization","title":"Test Organization","text":"<pre><code>spec {\n    describe \"FeatureName\" [\n        context \"when specific condition\" [\n            it \"behaves in expected way\" (fun () -&gt;\n                // Arrange\n                let input = setupTestData()\n\n                // Act\n                let result = performOperation(input)\n\n                // Assert\n                expect result |&gt; should (equal expectedValue)\n            )\n        ]\n    ]\n}\n</code></pre>"},{"location":"community/contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Test happy paths</li> <li>Test edge cases</li> <li>Test error conditions</li> <li>Test boundary values</li> </ul>"},{"location":"community/contributing/#good-test-examples","title":"Good Test Examples","text":"<pre><code>// Good: Clear, focused, descriptive\nit \"adds two positive numbers\" (fun () -&gt;\n    expect (Calculator.add 2 3) |&gt; should (equal 5)\n)\n\n// Good: Tests edge case\nit \"handles division by zero\" (fun () -&gt;\n    expect (fun () -&gt; Calculator.divide 10 0) |&gt; should raiseException\n)\n\n// Less good: Unclear what's being tested\nit \"test1\" (fun () -&gt;\n    expect (doSomething()) |&gt; should (equal 42)\n)\n</code></pre>"},{"location":"community/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Questions: Open a discussion</li> <li>Bugs: Open an issue</li> <li>Chat: Join our community chat (link TBD)</li> </ul>"},{"location":"community/contributing/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"community/contributing/#our-standards","title":"Our Standards","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Accept constructive criticism</li> <li>Focus on what's best for the community</li> <li>Show empathy</li> </ul>"},{"location":"community/contributing/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>Harassment or discrimination</li> <li>Trolling or insulting comments</li> <li>Personal or political attacks</li> <li>Publishing others' private information</li> </ul>"},{"location":"community/contributing/#enforcement","title":"Enforcement","text":"<p>Violations may result in temporary or permanent ban from the project.</p>"},{"location":"community/contributing/#license","title":"License","text":"<p>By contributing to FxSpec, you agree that your contributions will be licensed under the same license as the project (MIT License).</p>"},{"location":"community/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>GitHub contributors list</li> <li>Release notes</li> <li>Project documentation</li> </ul> <p>Thank you for contributing to FxSpec!</p>"},{"location":"reference/","title":"Reference Documentation","text":"<p>Complete API reference for FxSpec.</p>"},{"location":"reference/#quick-links","title":"Quick Links","text":"<ul> <li> <p> DSL API</p> <p>Complete reference for <code>describe</code>, <code>it</code>, <code>context</code>, and all DSL functions.</p> </li> <li> <p> Matchers</p> <p>All available matchers organized by category.</p> </li> </ul>"},{"location":"reference/#api-categories","title":"API Categories","text":""},{"location":"reference/#core-dsl","title":"Core DSL","text":"<ul> <li>describe - Group related tests</li> <li>context - Add context to test groups (alias for <code>describe</code>)</li> <li>it - Define individual test cases</li> </ul>"},{"location":"reference/#focus-pending","title":"Focus &amp; Pending","text":"<ul> <li>fit - Focus on specific test</li> <li>fdescribe - Focus on test group</li> <li>xit - Skip a test</li> <li>pending - Mark test as pending (alias for <code>xit</code>)</li> </ul>"},{"location":"reference/#hooks","title":"Hooks","text":"<ul> <li>beforeEach - Run before each test</li> <li>afterEach - Run after each test</li> <li>beforeAll - Run once before all tests in group</li> <li>afterAll - Run once after all tests in group</li> </ul>"},{"location":"reference/#expectations","title":"Expectations","text":"<ul> <li>expect - Create a generic expectation</li> <li>expectBool - Create a boolean expectation</li> <li>expectOption - Create an Option expectation</li> <li>expectResult - Create a Result expectation</li> <li>expectSeq - Create a collection expectation</li> <li>expectStr - Create a string expectation</li> <li>expectNum - Create a numeric expectation</li> <li>expectInt - Create an integer expectation</li> <li>expectFloat - Create a float expectation</li> <li>expectThrows - Assert an exception is thrown</li> </ul>"},{"location":"reference/#matcher-categories","title":"Matcher Categories","text":""},{"location":"reference/#core-matchers","title":"Core Matchers","text":"<p>Basic equality, null checks, boolean, and option matchers.</p>"},{"location":"reference/#collection-matchers","title":"Collection Matchers","text":"<p>Matchers for lists, arrays, sequences, and other collections.</p>"},{"location":"reference/#string-matchers","title":"String Matchers","text":"<p>String-specific matchers for prefixes, suffixes, patterns, and more.</p>"},{"location":"reference/#numeric-matchers","title":"Numeric Matchers","text":"<p>Numeric comparisons and range checks.</p>"},{"location":"reference/#exception-matchers","title":"Exception Matchers","text":"<p>Testing exception throwing behavior.</p>"},{"location":"reference/dsl-api/","title":"DSL API Reference","text":"<p>Complete reference for FxSpec's Domain-Specific Language functions.</p>"},{"location":"reference/dsl-api/#overview","title":"Overview","text":"<p>FxSpec uses a clean, functional DSL to build test trees. The DSL provides functions for organizing tests, defining test cases, and managing test lifecycle with hooks.</p>"},{"location":"reference/dsl-api/#core-functions","title":"Core Functions","text":""},{"location":"reference/dsl-api/#test-structure","title":"Test Structure","text":"<p>FxSpec tests are simple values marked with the <code>[&lt;Tests&gt;]</code> attribute. No wrapper is needed.</p> <p>Usage:</p> <pre><code>[&lt;Tests&gt;]\nlet myTests =\n    describe \"Feature\" [\n        it \"works\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n</code></pre> <p>Example:</p> <pre><code>[&lt;Tests&gt;]\nlet myTests =\n    describe \"Feature\" [\n        it \"works\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Tests are immutable tree structures built at declaration time</li> <li>Tests are not executed during building, only when the runner executes them</li> <li>Mark test functions with <code>[&lt;Tests&gt;]</code> attribute for discovery</li> <li>Test discovery works with both <code>TestNode</code> and <code>TestNode list</code> types</li> </ul>"},{"location":"reference/dsl-api/#describe","title":"describe","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Groups related tests together with a description.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the group</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>describe \"description\" [\n    // child tests\n]\n</code></pre> <p>Example:</p> <pre><code>describe \"Calculator\" [\n    describe \"addition\" [\n        it \"adds positive numbers\" (fun () -&gt;\n            expect(2 + 3).toEqual(5)\n        )\n    ]\n\n    describe \"subtraction\" [\n        it \"subtracts numbers\" (fun () -&gt;\n            expect(5 - 3).toEqual(2)\n        )\n    ]\n]\n</code></pre> <p>Output:</p> <pre><code>Calculator\n  addition\n    \u2713 adds positive numbers\n  subtraction\n    \u2713 subtracts numbers\n</code></pre> <p>Notes:</p> <ul> <li><code>describe</code> blocks can be nested arbitrarily deep</li> <li>Use <code>describe</code> for grouping by feature, class, or module</li> <li>Descriptions should be clear and descriptive</li> </ul>"},{"location":"reference/dsl-api/#context","title":"context","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Alias for <code>describe</code> that reads better when describing context or state.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the context</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>context \"when something is true\" [\n    // tests in this context\n]\n</code></pre> <p>Example:</p> <pre><code>describe \"Stack\" [\n    context \"when empty\" [\n        it \"has zero count\" (fun () -&gt;\n            let stack = Stack&lt;int&gt;()\n            expect(stack.Count).toEqual(0)\n        )\n    ]\n\n    context \"when not empty\" [\n        it \"has non-zero count\" (fun () -&gt;\n            let stack = Stack&lt;int&gt;()\n            stack.Push(1)\n            expect(stack.Count).toEqual(1)\n        )\n    ]\n]\n</code></pre> <p>Notes:</p> <ul> <li>Functionally identical to <code>describe</code></li> <li>Use <code>context</code> for \"when\" or \"with\" scenarios</li> <li>Improves readability in BDD-style tests</li> </ul>"},{"location":"reference/dsl-api/#it","title":"it","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Defines an individual test case.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing what the test does</li> <li><code>test</code> - Function that performs assertions</li> </ul> <p>Usage:</p> <pre><code>it \"description\" (fun () -&gt;\n    // test code and assertions\n)\n</code></pre> <p>Example:</p> <pre><code>it \"adds two numbers\" (fun () -&gt;\n    let result = Calculator.add 2 3\n    expect(result).toEqual(5)\n)\n</code></pre> <p>Notes:</p> <ul> <li>Test function must be wrapped in <code>fun () -&gt;</code> for lazy evaluation</li> <li>Descriptions should start with a verb (e.g., \"returns\", \"throws\", \"creates\")</li> <li>Tests should focus on one behavior</li> <li>If the test function throws an exception, the test fails</li> </ul>"},{"location":"reference/dsl-api/#itasync","title":"itAsync","text":"<p>Type: <code>string -&gt; Async&lt;unit&gt; -&gt; TestNode</code></p> <p>Defines an asynchronous test case that runs in an async workflow.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing what the test does</li> <li><code>test</code> - Async computation that performs assertions</li> </ul> <p>Usage:</p> <pre><code>itAsync \"description\" (async {\n    // async test code\n})\n</code></pre> <p>Example:</p> <pre><code>itAsync \"fetches user data\" (async {\n    let! user = getUserAsync 123\n    expectOption(user).toBeSome()\n})\n</code></pre> <p>With Task Interop:</p> <pre><code>itAsync \"calls HTTP API\" (async {\n    use client = new HttpClient()\n    let! response = client.GetAsync(\"https://api.example.com/users\") |&gt; Async.AwaitTask\n    expectHttp(response).toHaveStatusOk()\n})\n</code></pre> <p>With Result Types:</p> <pre><code>itAsync \"validates async operation\" (async {\n    let! result = processDataAsync(data)\n    expectResult(result).toBeOk()\n})\n</code></pre> <p>Notes:</p> <ul> <li>Use for tests that perform I/O operations (database, HTTP, file system)</li> <li>Test runs using <code>Async.RunSynchronously</code> internally</li> <li>Can use <code>let!</code> to await async operations</li> <li>Can use <code>Async.AwaitTask</code> to work with .NET Task-based APIs</li> <li>Compatible with all FxSpec matchers and hooks</li> <li>Can mix <code>it</code> and <code>itAsync</code> in the same test suite</li> </ul>"},{"location":"reference/dsl-api/#async-testing-patterns","title":"Async Testing Patterns","text":""},{"location":"reference/dsl-api/#http-api-testing","title":"HTTP API Testing","text":"<pre><code>open System.Net.Http\nopen FxSpec.Http\n\ndescribe \"User API\" [\n    let client = new HttpClient(BaseAddress = Uri(\"http://localhost:5000\"))\n\n    itAsync \"creates user successfully\" (async {\n        let json = \"\"\"{\"name\":\"John\",\"email\":\"john@example.com\"}\"\"\"\n        let content = new StringContent(json, Encoding.UTF8, \"application/json\")\n        let! response = client.PostAsync(\"/api/users\", content) |&gt; Async.AwaitTask\n\n        expectHttp(response).toHaveStatusCreated()\n        expectHttp(response).toHaveJsonBody({| id = 1; name = \"John\" |})\n    })\n\n    itAsync \"retrieves user by ID\" (async {\n        let! response = client.GetAsync(\"/api/users/1\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#database-operations","title":"Database Operations","text":"<pre><code>describe \"User Repository\" [\n    let connectionString = \"Server=localhost;Database=test\"\n\n    itAsync \"saves user to database\" (async {\n        use! connection = openConnectionAsync(connectionString)\n        let! result = repository.SaveAsync(connection, newUser)\n        expectResult(result).toBeOk()\n    })\n\n    itAsync \"retrieves user from database\" (async {\n        use! connection = openConnectionAsync(connectionString)\n        let! user = repository.GetAsync(connection, userId)\n        expectOption(user).toBeSome()\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#async-result-patterns","title":"Async Result Patterns","text":"<pre><code>describe \"Async Result Workflows\" [\n    itAsync \"handles successful async operation\" (async {\n        let! result = fetchDataAsync(validId)\n        expectResult(result).toBeOk()\n    })\n\n    itAsync \"handles async errors\" (async {\n        let! result = fetchDataAsync(invalidId)\n        expectResult(result).toBeError()\n    })\n\n    itAsync \"chains async Result operations\" (async {\n        let! result = \n            validateInputAsync(data)\n            |&gt; AsyncResult.bind processDataAsync\n            |&gt; AsyncResult.bind saveToDbAsync\n\n        expectResult(result).toBeOk()\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#parallel-async-operations","title":"Parallel Async Operations","text":"<pre><code>describe \"Parallel Operations\" [\n    itAsync \"runs multiple operations in parallel\" (async {\n        let! results = \n            [1..10]\n            |&gt; List.map (fun id -&gt; fetchUserAsync id)\n            |&gt; Async.Parallel\n\n        expectSeq(results).toHaveLength(10)\n    })\n\n    itAsync \"handles parallel failures gracefully\" (async {\n        let operations = [\n            fetchUserAsync 1\n            fetchUserAsync 999  // This will fail\n            fetchUserAsync 3\n        ]\n\n        let! results = Async.Parallel operations\n        expectSeq(results |&gt; Array.filter Result.isOk).toHaveLength(2)\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#file-io","title":"File I/O","text":"<pre><code>describe \"File Operations\" [\n    itAsync \"reads file asynchronously\" (async {\n        let! content = File.ReadAllTextAsync(\"test.txt\") |&gt; Async.AwaitTask\n        expectStr(content).toContain(\"expected text\")\n    })\n\n    itAsync \"writes file asynchronously\" (async {\n        let! _ = File.WriteAllTextAsync(\"output.txt\", \"test\") |&gt; Async.AwaitTask\n        let! content = File.ReadAllTextAsync(\"output.txt\") |&gt; Async.AwaitTask\n        expectStr(content).toEqual(\"test\")\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#async-hooks","title":"Async Hooks","text":"<p>Hooks can be async-aware when working with async tests:</p> <pre><code>describe \"Integration Tests\" [\n    let mutable client = Unchecked.defaultof&lt;HttpClient&gt;\n\n    beforeEach (fun () -&gt;\n        client &lt;- new HttpClient(BaseAddress = Uri(\"http://localhost:5000\"))\n    )\n\n    afterEach (fun () -&gt;\n        client.Dispose()\n    )\n\n    itAsync \"test 1\" (async {\n        let! response = client.GetAsync(\"/health\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n\n    itAsync \"test 2\" (async {\n        let! response = client.GetAsync(\"/api/users\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n]\n</code></pre> <p>Notes on Async Testing: - <code>itAsync</code> internally uses <code>Async.RunSynchronously</code>, so tests still run synchronously at the top level - Use <code>Async.AwaitTask</code> to convert .NET Tasks to F# Async - Async tests can be focused with <code>fitAsync</code> or skipped with <code>xitAsync</code> - Async tests work with all lifecycle hooks (<code>beforeEach</code>, <code>afterEach</code>, etc.) - Mix sync and async tests freely in the same suite</p>"},{"location":"reference/dsl-api/#focus-pending","title":"Focus &amp; Pending","text":""},{"location":"reference/dsl-api/#fit","title":"fit","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Focused test - runs only this test when focused tests exist.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function that performs assertions</li> </ul> <p>Usage:</p> <pre><code>fit \"only run this test\" (fun () -&gt;\n    expectBool(true).toBeTrue()\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"My Suite\" [\n    fit \"work on this test\" (fun () -&gt;  // Only this runs\n        expect(2 + 2).toEqual(4)\n    )\n\n    it \"this is skipped\" (fun () -&gt;    // Skipped\n        expectBool(true).toBeTrue()\n    )\n]\n</code></pre> <p>Output:</p> <pre><code>My Suite\n  \u2713 work on this test\n  \u2298 this is skipped (not focused)\n</code></pre> <p>Notes:</p> <ul> <li>Use during development to focus on specific tests</li> <li>When any <code>fit</code> or <code>fdescribe</code> exists, unfocused tests are skipped</li> <li>Remove all <code>fit</code> before committing code</li> <li>Multiple <code>fit</code> tests can exist - all focused tests run</li> </ul>"},{"location":"reference/dsl-api/#fdescribe","title":"fdescribe","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Focused group - runs only tests in focused groups.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the group</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>fdescribe \"only run this group\" [\n    // all tests in this group run\n]\n</code></pre> <p>Example:</p> <pre><code>spec {\n    fdescribe \"Work on Calculator\" [  // This group runs\n        it \"test 1\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n        it \"test 2\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n\n    describe \"Other Feature\" [        // This group is skipped\n        it \"test 3\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n}\n</code></pre> <p>Notes:</p> <ul> <li>All tests within <code>fdescribe</code> run</li> <li>Tests outside <code>fdescribe</code> are skipped</li> <li>Can be nested - inner <code>fdescribe</code> focuses further</li> <li>Remove before committing</li> </ul>"},{"location":"reference/dsl-api/#xit","title":"xit","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Excluded test - skips this test.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function (not executed)</li> </ul> <p>Usage:</p> <pre><code>xit \"not ready yet\" (fun () -&gt;\n    // this code doesn't run\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Feature\" [\n    it \"working test\" (fun () -&gt;\n        expectBool(true).toBeTrue()\n    )\n\n    xit \"broken test\" (fun () -&gt;  // Skipped\n        expectBool(false).toBeTrue()\n    )\n]\n</code></pre> <p>Output:</p> <pre><code>Feature\n  \u2713 working test\n  \u2298 broken test\n</code></pre> <p>Notes:</p> <ul> <li>Use for temporarily disabling broken tests</li> <li>Test function is never executed</li> <li>Skipped tests are reported in the summary</li> <li>Better than commenting out tests (maintains test count)</li> </ul>"},{"location":"reference/dsl-api/#xitasync","title":"xitAsync","text":"<p>Type: <code>string -&gt; Async&lt;unit&gt; -&gt; TestNode</code></p> <p>Excluded async test - skips this async test.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Async computation (not executed)</li> </ul> <p>Usage:</p> <pre><code>xitAsync \"not ready yet\" (async {\n    // this code doesn't run\n})\n</code></pre> <p>Example:</p> <pre><code>describe \"API Tests\" [\n    itAsync \"working test\" (async {\n        let! response = client.GetAsync(\"/api/users\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n\n    xitAsync \"broken async test\" (async {  // Skipped\n        let! data = failingOperationAsync()\n        expectResult(data).toBeOk()\n    })\n]\n</code></pre> <p>Notes:</p> <ul> <li>Same behavior as <code>xit</code> but for async tests</li> <li>Use for temporarily disabling broken async tests</li> <li>Test computation is never executed</li> </ul>"},{"location":"reference/dsl-api/#pending","title":"pending","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Alias for <code>xit</code> that reads better for unfinished tests.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function (not executed)</li> </ul> <p>Usage:</p> <pre><code>pending \"TODO: implement this test\" (fun () -&gt;\n    ()\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Feature\" [\n        it \"implemented test\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n\n        pending \"write test for edge case\" (fun () -&gt;\n            ()\n        )\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Functionally identical to <code>xit</code></li> <li>Use for planned but unimplemented tests</li> <li>Can pass empty function <code>(fun () -&gt; ())</code></li> </ul>"},{"location":"reference/dsl-api/#lifecycle-hooks","title":"Lifecycle Hooks","text":""},{"location":"reference/dsl-api/#beforeeach","title":"beforeEach","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs before each test in the current group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run before each test</li> </ul> <p>Usage:</p> <pre><code>beforeEach (fun () -&gt;\n    // setup code\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Database Tests\" [\n        let mutable connection = null\n\n        beforeEach (fun () -&gt;\n            connection &lt;- Database.connect()\n            connection.BeginTransaction()\n        )\n\n        afterEach (fun () -&gt;\n            connection.RollbackTransaction()\n            connection.Dispose()\n        )\n\n        it \"queries data\" (fun () -&gt;\n            let result = connection.Query(\"SELECT 1\")\n            expect result |&gt; shouldNot beEmpty\n        )\n\n        it \"inserts data\" (fun () -&gt;\n            connection.Execute(\"INSERT INTO users VALUES (1, 'test')\")\n            let count = connection.Query(\"SELECT COUNT(*) FROM users\")\n            expect(count).toEqual(1)\n        )\n    ]\n</code></pre> <p>Execution Order:</p> <pre><code>beforeEach \u2192 test 1 \u2192 afterEach\nbeforeEach \u2192 test 2 \u2192 afterEach\n</code></pre> <p>Notes:</p> <ul> <li>Runs before each test in the group</li> <li>Useful for test isolation and setup</li> <li>Can access mutable variables from outer scope</li> <li>Multiple <code>beforeEach</code> hooks run in order of definition</li> </ul>"},{"location":"reference/dsl-api/#aftereach","title":"afterEach","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs after each test in the current group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run after each test</li> </ul> <p>Usage:</p> <pre><code>afterEach (fun () -&gt;\n    // cleanup code\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"File Tests\" [\n        let testFile = \"test.txt\"\n\n        beforeEach (fun () -&gt;\n            File.WriteAllText(testFile, \"test content\")\n        )\n\n        afterEach (fun () -&gt;\n            if File.Exists(testFile) then\n                File.Delete(testFile)\n        )\n\n        it \"reads file\" (fun () -&gt;\n            let content = File.ReadAllText(testFile)\n            expect(content).toEqual(\"test content\")\n        )\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Runs after each test, even if test fails</li> <li>Use for cleanup and resource disposal</li> <li>Guaranteed to run (unless unhandled exception in beforeEach)</li> </ul>"},{"location":"reference/dsl-api/#beforeall","title":"beforeAll","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs once before all tests in the group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run once before tests</li> </ul> <p>Usage:</p> <pre><code>beforeAll (fun () -&gt;\n    // expensive setup\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"API Tests\" [\n        let mutable server = null\n\n        beforeAll (fun () -&gt;\n            server &lt;- TestServer.start()\n            server.SeedDatabase()\n        )\n\n        afterAll (fun () -&gt;\n            server.Stop()\n        )\n\n        it \"test 1\" (fun () -&gt;\n            let response = server.Get(\"/api/users\")\n            expect(response.Status).toEqual(200)\n        )\n\n        it \"test 2\" (fun () -&gt;\n            let response = server.Post(\"/api/users\", { Name = \"test\" })\n            expect(response.Status).toEqual(201)\n        )\n    ]\n</code></pre> <p>Execution Order:</p> <pre><code>beforeAll \u2192 test 1 \u2192 test 2 \u2192 afterAll\n</code></pre> <p>Notes:</p> <ul> <li>Runs only once before all tests in the group</li> <li>Use for expensive setup (database seeding, server start, etc.)</li> <li>Shared state across tests (be careful of test isolation)</li> </ul>"},{"location":"reference/dsl-api/#afterall","title":"afterAll","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs once after all tests in the group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run once after all tests</li> </ul> <p>Usage:</p> <pre><code>afterAll (fun () -&gt;\n    // cleanup expensive resources\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Integration Tests\" [\n        let mutable dockerContainer = null\n\n        beforeAll (fun () -&gt;\n            dockerContainer &lt;- Docker.startContainer(\"postgres:15\")\n        )\n\n        afterAll (fun () -&gt;\n            Docker.stopContainer(dockerContainer)\n        )\n\n        // tests...\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Runs only once after all tests in the group</li> <li>Use for expensive cleanup</li> <li>Guaranteed to run even if tests fail</li> </ul>"},{"location":"reference/dsl-api/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive example using all DSL features:</p> <pre><code>module UserServiceSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet userServiceSpecs =\n    spec {\n        describe \"UserService\" [\n            let mutable service = null\n            let mutable db = null\n\n            beforeAll (fun () -&gt;\n                db &lt;- Database.createInMemory()\n            )\n\n            afterAll (fun () -&gt;\n                db.Dispose()\n            )\n\n            beforeEach (fun () -&gt;\n                db.Clear()\n                service &lt;- UserService(db)\n            )\n\n            describe \"CreateUser\" [\n                context \"when valid data is provided\" [\n                    it \"creates a new user\" (fun () -&gt;\n                        let user = service.CreateUser(\"Alice\", \"alice@example.com\")\n                        expect(user.Name).toEqual(\"Alice\")\n                        expect(user.Email).toEqual(\"alice@example.com\")\n                    )\n\n                    it \"assigns a unique ID\" (fun () -&gt;\n                        let user = service.CreateUser(\"Bob\", \"bob@example.com\")\n                        expect user.Id |&gt; should (beGreaterThan 0)\n                    )\n                ]\n\n                context \"when invalid data is provided\" [\n                    it \"raises exception for empty name\" (fun () -&gt;\n                        let action () = service.CreateUser(\"\", \"test@example.com\")\n                        expect action |&gt; should raiseException\n                    )\n\n                    xit \"validates email format\" (fun () -&gt;\n                        // TODO: implement email validation\n                        let action () = service.CreateUser(\"Test\", \"invalid-email\")\n                        expect action |&gt; should raiseException\n                    )\n                ]\n            ]\n\n            describe \"GetUser\" [\n                it \"returns existing user\" (fun () -&gt;\n                    let created = service.CreateUser(\"Charlie\", \"charlie@example.com\")\n                    let retrieved = service.GetUser(created.Id)\n                    expect retrieved |&gt; should (beSome created)\n                )\n\n                it \"returns None for non-existent user\" (fun () -&gt;\n                    let result = service.GetUser(9999)\n                    expect result |&gt; should beNone\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/dsl-api/#best-practices","title":"Best Practices","text":""},{"location":"reference/dsl-api/#naming-conventions","title":"Naming Conventions","text":"<pre><code>// Good\ndescribe \"UserService\"\nit \"creates a new user\"\ncontext \"when user is authenticated\"\n\n// Avoid\ndescribe \"Test Suite 1\"\nit \"test1\"\ncontext \"scenario A\"\n</code></pre>"},{"location":"reference/dsl-api/#test-organization","title":"Test Organization","text":"<pre><code>describe \"FeatureName\" [           // Top-level: feature/module/class\n        describe \"MethodOrFunction\" [   // Second-level: method/function\n            context \"when condition\" [  // Third-level: specific context\n                it \"expected behavior\" (fun () -&gt; ...)\n            ]\n        ]\n    ]\n</code></pre>"},{"location":"reference/dsl-api/#hook-usage","title":"Hook Usage","text":"<ul> <li>Use <code>beforeEach</code>/<code>afterEach</code> for test isolation</li> <li>Use <code>beforeAll</code>/<code>afterAll</code> for expensive setup</li> <li>Keep hooks simple and focused</li> <li>Avoid complex logic in hooks</li> </ul>"},{"location":"reference/dsl-api/#focus-pending_1","title":"Focus &amp; Pending","text":"<ul> <li>Use <code>fit</code>/<code>fdescribe</code> temporarily during development</li> <li>Always remove before committing</li> <li>Use <code>xit</code>/<code>pending</code> to track incomplete tests</li> <li>Document why tests are pending</li> </ul>"},{"location":"reference/dsl-api/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Get started with FxSpec</li> <li>Matchers Reference - Learn about assertions</li> <li>Contributing - Contribute to FxSpec</li> </ul>"},{"location":"reference/http/","title":"HTTP Testing","text":"<p>FxSpec provides a fluent API for testing HTTP responses with comprehensive matchers for status codes, headers, and body content.</p>"},{"location":"reference/http/#overview","title":"Overview","text":"<p>The <code>expectHttp()</code> function creates an HTTP response expectation that provides type-safe, chainable matchers specifically designed for testing web APIs and HTTP services.</p> <pre><code>open FxSpec.Http\n\nitAsync \"tests API response\" (async {\n    let! response = client.GetAsync(\"/api/users\")\n    expectHttp(response).toHaveStatusOk()\n})\n</code></pre>"},{"location":"reference/http/#status-code-matchers","title":"Status Code Matchers","text":""},{"location":"reference/http/#tohavestatuscode-int","title":"toHaveStatus(code: int)","text":"<p>Asserts that the HTTP response has the specified status code.</p> <pre><code>expectHttp(response).toHaveStatus(200)\nexpectHttp(response).toHaveStatus(404)\nexpectHttp(response).toHaveStatus(500)\n</code></pre>"},{"location":"reference/http/#semantic-status-matchers","title":"Semantic Status Matchers","text":"<p>FxSpec provides semantic matchers for common HTTP status codes:</p> Matcher Status Code Description <code>toHaveStatusOk()</code> 200 OK <code>toHaveStatusCreated()</code> 201 Created <code>toHaveStatusNoContent()</code> 204 No Content <code>toHaveStatusBadRequest()</code> 400 Bad Request <code>toHaveStatusUnauthorized()</code> 401 Unauthorized <code>toHaveStatusNotFound()</code> 404 Not Found <code>toHaveStatusUnprocessableEntity()</code> 422 Unprocessable Entity <code>toHaveStatusInternalServerError()</code> 500 Internal Server Error <pre><code>describe \"User API\" [\n    itAsync \"creates user successfully\" (async {\n        let! response = client.PostAsync(\"/api/users\", content)\n        expectHttp(response).toHaveStatusCreated()\n    })\n\n    itAsync \"returns 404 for missing user\" (async {\n        let! response = client.GetAsync(\"/api/users/999\")\n        expectHttp(response).toHaveStatusNotFound()\n    })\n\n    itAsync \"requires authentication\" (async {\n        let! response = client.GetAsync(\"/api/admin\")\n        expectHttp(response).toHaveStatusUnauthorized()\n    })\n]\n</code></pre>"},{"location":"reference/http/#header-matchers","title":"Header Matchers","text":""},{"location":"reference/http/#tohaveheadername-string-value-string","title":"toHaveHeader(name: string, value: string)","text":"<p>Asserts that the response contains a header with the specified name and exact value.</p> <pre><code>expectHttp(response).toHaveHeader(\"Content-Type\", \"application/json\")\nexpectHttp(response).toHaveHeader(\"X-Custom-Header\", \"custom-value\")\n</code></pre>"},{"location":"reference/http/#tohaveheadername-string","title":"toHaveHeader(name: string)","text":"<p>Asserts that the response contains a header with the specified name (regardless of value).</p> <pre><code>expectHttp(response).toHaveHeader(\"ETag\")\nexpectHttp(response).toHaveHeader(\"X-Request-Id\")\n</code></pre>"},{"location":"reference/http/#tohavecontenttypemediatype-string","title":"toHaveContentType(mediaType: string)","text":"<p>Convenience method for asserting the Content-Type header. Automatically handles charset and other parameters.</p> <pre><code>expectHttp(response).toHaveContentType(\"application/json\")\nexpectHttp(response).toHaveContentType(\"text/html\")\nexpectHttp(response).toHaveContentType(\"application/xml\")\n</code></pre> <p>Example:</p> <pre><code>describe \"API Content Types\" [\n    itAsync \"returns JSON for API requests\" (async {\n        let! response = client.GetAsync(\"/api/users\")\n        expectHttp(response)\n            .toHaveStatusOk()\n            .toHaveContentType(\"application/json\")\n    })\n\n    itAsync \"includes custom headers\" (async {\n        let! response = client.GetAsync(\"/api/users\")\n        expectHttp(response)\n            .toHaveHeader(\"X-API-Version\", \"1.0\")\n            .toHaveHeader(\"X-Rate-Limit-Remaining\")\n    })\n]\n</code></pre>"},{"location":"reference/http/#body-matchers","title":"Body Matchers","text":""},{"location":"reference/http/#tohavebodyexpected-string","title":"toHaveBody(expected: string)","text":"<p>Asserts that the response body exactly matches the expected string.</p> <pre><code>expectHttp(response).toHaveBody(\"Hello, World!\")\nexpectHttp(response).toHaveBody(\"\")  // Empty body\n</code></pre>"},{"location":"reference/http/#tohavebodycontainingsubstring-string","title":"toHaveBodyContaining(substring: string)","text":"<p>Asserts that the response body contains the specified substring (case-sensitive).</p> <pre><code>expectHttp(response).toHaveBodyContaining(\"success\")\nexpectHttp(response).toHaveBodyContaining(\"error\")\nexpectHttp(response).toHaveBodyContaining(\"user123\")\n</code></pre>"},{"location":"reference/http/#tohavejsonbodytexpected-t","title":"toHaveJsonBody&lt;'T&gt;(expected: 'T)","text":"<p>Asserts that the response body is valid JSON that deserializes to the expected value. Automatically normalizes JSON formatting for comparison.</p> <pre><code>// Anonymous records\nexpectHttp(response).toHaveJsonBody({| name = \"John\"; age = 30 |})\n\n// Complex objects\nexpectHttp(response).toHaveJsonBody({| \n    users = [| {| id = 1 |}; {| id = 2 |} |]\n    count = 2 \n|})\n\n// Custom types\ntype User = { Id: int; Name: string; Email: string }\nexpectHttp(response).toHaveJsonBody({ Id = 1; Name = \"John\"; Email = \"john@example.com\" })\n</code></pre> <p>Example:</p> <pre><code>describe \"API Response Bodies\" [\n    itAsync \"returns JSON user data\" (async {\n        let! response = client.GetAsync(\"/api/users/1\")\n        expectHttp(response)\n            .toHaveStatusOk()\n            .toHaveJsonBody({| \n                id = 1\n                name = \"John Doe\"\n                email = \"john@example.com\"\n            |})\n    })\n\n    itAsync \"returns error message\" (async {\n        let! response = client.GetAsync(\"/api/users/invalid\")\n        expectHttp(response)\n            .toHaveStatusBadRequest()\n            .toHaveBodyContaining(\"Invalid user ID\")\n    })\n]\n</code></pre>"},{"location":"reference/http/#multiple-assertions","title":"Multiple Assertions","text":"<p>You can call multiple assertions on the same expectation:</p> <pre><code>describe \"Complete API Test\" [\n    itAsync \"validates full response\" (async {\n        let! response = client.PostAsync(\"/api/users\", content)\n\n        let expectation = expectHttp(response)\n        expectation.toHaveStatusCreated()\n        expectation.toHaveHeader(\"Location\", \"/api/users/123\")\n        expectation.toHaveContentType(\"application/json\")\n        expectation.toHaveBodyContaining(\"\\\"id\\\":123\")\n        expectation.toHaveJsonBody({| id = 123; name = \"John\" |})\n    })\n]\n</code></pre>"},{"location":"reference/http/#async-http-testing","title":"Async HTTP Testing","text":"<p>FxSpec's <code>itAsync</code> works seamlessly with F#'s <code>async</code> workflows and .NET's <code>Task</code>-based APIs:</p> <pre><code>open System.Net.Http\nopen System.Text\nopen FxSpec.Http\n\ndescribe \"User API Integration Tests\" [\n    let client = new HttpClient(BaseAddress = Uri(\"http://localhost:5000\"))\n\n    itAsync \"creates and retrieves user\" (async {\n        // Create user\n        let json = \"\"\"{\"name\":\"Jane\",\"email\":\"jane@example.com\"}\"\"\"\n        let content = new StringContent(json, Encoding.UTF8, \"application/json\")\n        let! createResponse = client.PostAsync(\"/api/users\", content) |&gt; Async.AwaitTask\n\n        expectHttp(createResponse)\n            .toHaveStatusCreated()\n            .toHaveHeader(\"Location\")\n\n        // Retrieve user\n        let! getResponse = client.GetAsync(\"/api/users/1\") |&gt; Async.AwaitTask\n        expectHttp(getResponse)\n            .toHaveStatusOk()\n            .toHaveJsonBody({| id = 1; name = \"Jane\"; email = \"jane@example.com\" |})\n    })\n\n    itAsync \"handles validation errors\" (async {\n        let json = \"\"\"{\"name\":\"\"}\"\"\"  // Invalid: empty name\n        let content = new StringContent(json, Encoding.UTF8, \"application/json\")\n        let! response = client.PostAsync(\"/api/users\", content) |&gt; Async.AwaitTask\n\n        expectHttp(response)\n            .toHaveStatusBadRequest()\n            .toHaveBodyContaining(\"Name is required\")\n    })\n]\n</code></pre>"},{"location":"reference/http/#error-messages","title":"Error Messages","text":"<p>FxSpec provides clear, actionable error messages when HTTP assertions fail:</p>"},{"location":"reference/http/#status-code-mismatch","title":"Status Code Mismatch","text":"<pre><code>Expected HTTP status 200, but got 404\nExpected: 200\nActual: 404\n</code></pre>"},{"location":"reference/http/#header-mismatch","title":"Header Mismatch","text":"<pre><code>Expected header 'Content-Type' to have value 'application/json', but got 'text/html'\nExpected: application/json\nActual: text/html\n</code></pre>"},{"location":"reference/http/#missing-header","title":"Missing Header","text":"<pre><code>Expected header 'X-Custom-Header' not found in response\nExpected: X-Custom-Header\n</code></pre>"},{"location":"reference/http/#body-mismatch","title":"Body Mismatch","text":"<pre><code>Expected body to contain 'success', but it was not found.\n\nActual body:\n{\"status\":\"error\",\"message\":\"Something went wrong\"}\n</code></pre>"},{"location":"reference/http/#json-body-mismatch","title":"JSON Body Mismatch","text":"<pre><code>Expected JSON body:\n{\"id\":1,\"name\":\"John\"}\n\nActual JSON body:\n{\"id\":1,\"name\":\"Jane\"}\n</code></pre>"},{"location":"reference/http/#migration-guide-old-api-to-new-api","title":"Migration Guide: Old API to New API","text":"<p>FxSpec previously used a <code>should</code>-based API. The new <code>expectHttp()</code> API is more consistent with the rest of the framework and provides better error messages.</p>"},{"location":"reference/http/#old-api-deprecated","title":"Old API (Deprecated)","text":"<pre><code>// Old style - still works but deprecated\nresponse |&gt; should (haveStatus beOk)\nresponse |&gt; should (haveHeader \"Content-Type\" \"application/json\")\nresponse |&gt; shouldBeOk\nresponse |&gt; shouldHaveJsonBody expected\n</code></pre>"},{"location":"reference/http/#new-api-recommended","title":"New API (Recommended)","text":"<pre><code>// New style - fluent and consistent\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveHeader(\"Content-Type\", \"application/json\")\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveJsonBody(expected)\n</code></pre>"},{"location":"reference/http/#migration-steps","title":"Migration Steps","text":"<ol> <li>Replace <code>response |&gt; should (haveStatus beOk)</code> with <code>expectHttp(response).toHaveStatusOk()</code></li> <li>Replace <code>response |&gt; shouldBeOk</code> with <code>expectHttp(response).toHaveStatusOk()</code></li> <li>Replace <code>response |&gt; should (haveHeader name value)</code> with <code>expectHttp(response).toHaveHeader(name, value)</code></li> <li>Replace <code>response |&gt; shouldHaveJsonBody expected</code> with <code>expectHttp(response).toHaveJsonBody(expected)</code></li> </ol> <p>The old API will be maintained for backward compatibility but may be removed in a future major version.</p>"},{"location":"reference/http/#best-practices","title":"Best Practices","text":""},{"location":"reference/http/#1-use-semantic-status-matchers","title":"1. Use Semantic Status Matchers","text":"<p>Prefer semantic matchers over numeric codes for better readability:</p> <pre><code>// Good\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveStatusNotFound()\n\n// Works, but less expressive\nexpectHttp(response).toHaveStatus(200)\nexpectHttp(response).toHaveStatus(404)\n</code></pre>"},{"location":"reference/http/#2-check-status-before-body","title":"2. Check Status Before Body","text":"<p>Always verify the status code before asserting on body content:</p> <pre><code>// Good\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveBodyContaining(\"success\")\n\n// Risky - might fail on wrong status\nexpectHttp(response).toHaveBodyContaining(\"success\")\n</code></pre>"},{"location":"reference/http/#3-use-tohavejsonbody-for-json-apis","title":"3. Use toHaveJsonBody for JSON APIs","text":"<p>For JSON responses, use <code>toHaveJsonBody</code> instead of string comparisons:</p> <pre><code>// Good - type-safe, handles formatting\nexpectHttp(response).toHaveJsonBody({| id = 1; name = \"John\" |})\n\n// Fragile - whitespace sensitive\nexpectHttp(response).toHaveBody(\"\"\"{\"id\":1,\"name\":\"John\"}\"\"\")\n</code></pre>"},{"location":"reference/http/#4-store-expectation-for-multiple-assertions","title":"4. Store Expectation for Multiple Assertions","text":"<p>When making multiple assertions, store the expectation:</p> <pre><code>let expectation = expectHttp(response)\nexpectation.toHaveStatusOk()\nexpectation.toHaveContentType(\"application/json\")\nexpectation.toHaveBodyContaining(\"data\")\n</code></pre>"},{"location":"reference/http/#see-also","title":"See Also","text":"<ul> <li>Async Support - Using <code>itAsync</code> for asynchronous tests</li> <li>Core Matchers - General-purpose matchers</li> <li>Quick Start - Getting started with FxSpec</li> </ul>"},{"location":"reference/runner/","title":"Test Runner","text":"<p>The FxSpec test runner discovers and executes tests from compiled assemblies.</p>"},{"location":"reference/runner/#basic-usage","title":"Basic Usage","text":"<pre><code>dotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- &lt;assembly-path&gt; [options]\n</code></pre> <p>Or use the convenience script:</p> <pre><code>./run-tests.sh [options]\n</code></pre>"},{"location":"reference/runner/#command-line-options","title":"Command-Line Options","text":""},{"location":"reference/runner/#assembly-path","title":"Assembly Path","text":"<p>Required. Path to the compiled test assembly (<code>.dll</code> file).</p> <pre><code>dotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- tests/MyTests.dll\n</code></pre>"},{"location":"reference/runner/#-filter-f","title":"<code>--filter</code>, <code>-f</code>","text":"<p>Filter tests by description (case-sensitive substring match).</p> <p>Usage:</p> <pre><code>--filter &lt;pattern&gt;\n-f &lt;pattern&gt;\n</code></pre> <p>Examples:</p> <pre><code># Run only tests with \"Calculator\" in the description\n./run-tests.sh --filter \"Calculator\"\n\n# Run only tests with \"User\" in the description\n./run-tests.sh -f \"User\"\n\n# Filter works on full test path (describe &gt; context &gt; it)\n./run-tests.sh --filter \"when adding numbers\"\n</code></pre> <p>How it works:</p> <ul> <li>Matches against the full test path: <code>\"SpecBuilder &gt; simple examples &gt; creates a single Example node\"</code></li> <li>Case-sensitive</li> <li>Substring match (not regex)</li> <li>Filters both groups and individual tests</li> </ul>"},{"location":"reference/runner/#-format","title":"<code>--format</code>","text":"<p>Choose output format.</p> <p>Usage:</p> <pre><code>--format &lt;format&gt;\n</code></pre> <p>Formats:</p> <ul> <li><code>documentation</code> (default) - Rich Spectre.Console output with colors, tables, and panels</li> <li><code>doc</code> - Alias for <code>documentation</code></li> <li><code>simple</code> - Plain text output</li> </ul> <p>Examples:</p> <pre><code># Use documentation format (default)\n./run-tests.sh --format documentation\n\n# Use simple format\n./run-tests.sh --format simple\n\n# Short alias\n./run-tests.sh --format doc\n</code></pre> <p>Documentation Format:</p> <pre><code>SpecBuilder\n  simple examples\n    \u2713 creates a single Example node (2ms)\n    \u2713 creates multiple nodes (1ms)\n  nested describe blocks\n    \u2713 creates nested Group structures (0ms)\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Total \u2502 Passed \u2502 Failed \u2502 Skipped \u2502 Duration \u2502\n\u2502   52  \u2502   52   \u2502   0    \u2502    0    \u2502  0.15s   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Simple Format:</p> <pre><code>SpecBuilder &gt; simple examples &gt; creates a single Example node: PASS\nSpecBuilder &gt; simple examples &gt; creates multiple nodes: PASS\nSpecBuilder &gt; nested describe blocks &gt; creates nested Group structures: PASS\n\n52 examples, 0 failures\n</code></pre>"},{"location":"reference/runner/#-verbose-v","title":"<code>--verbose</code>, <code>-v</code>","text":"<p>Enable verbose output (shows stack traces on errors).</p> <p>Usage:</p> <pre><code>--verbose\n-v\n</code></pre> <p>Example:</p> <pre><code>./run-tests.sh --verbose\n./run-tests.sh -v\n</code></pre>"},{"location":"reference/runner/#-help-h","title":"<code>--help</code>, <code>-h</code>","text":"<p>Show help message and exit.</p> <p>Usage:</p> <pre><code>--help\n-h\n</code></pre>"},{"location":"reference/runner/#exit-codes","title":"Exit Codes","text":"<p>The runner returns different exit codes based on test results:</p> Exit Code Meaning <code>0</code> All tests passed <code>1</code> One or more tests failed <code>1</code> Fatal error (assembly not found, etc.) <p>CI/CD Integration:</p> <pre><code>#!/bin/bash\ndotnet build tests/MyProject.Tests/MyProject.Tests.fsproj\ndotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n  tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n\nif [ $? -eq 0 ]; then\n    echo \"\u2705 All tests passed\"\nelse\n    echo \"\u274c Tests failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"reference/runner/#examples","title":"Examples","text":""},{"location":"reference/runner/#run-all-tests","title":"Run All Tests","text":"<pre><code># Build and run\ndotnet build tests/FxSpec.Core.Tests/FxSpec.Core.Tests.fsproj\ndotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n  tests/FxSpec.Core.Tests/bin/Debug/net9.0/FxSpec.Core.Tests.dll\n\n# Or use the script\n./run-tests.sh\n</code></pre>"},{"location":"reference/runner/#run-filtered-tests","title":"Run Filtered Tests","text":"<pre><code># Run only Calculator tests\n./run-tests.sh --filter \"Calculator\"\n\n# Run only tests in a specific context\n./run-tests.sh --filter \"when adding numbers\"\n\n# Run tests from a specific describe block\n./run-tests.sh --filter \"SpecBuilder\"\n</code></pre>"},{"location":"reference/runner/#run-with-different-formats","title":"Run with Different Formats","text":"<pre><code># Documentation format (default, colorful)\n./run-tests.sh --format documentation\n\n# Simple format (plain text, good for CI)\n./run-tests.sh --format simple\n</code></pre>"},{"location":"reference/runner/#combine-options","title":"Combine Options","text":"<pre><code># Filter + format\n./run-tests.sh --filter \"Calculator\" --format simple\n\n# Filter + verbose\n./run-tests.sh -f \"User\" -v\n\n# All options\n./run-tests.sh --filter \"Database\" --format documentation --verbose\n</code></pre>"},{"location":"reference/runner/#test-discovery","title":"Test Discovery","text":"<p>The runner discovers tests using reflection:</p> <ol> <li>Loads the assembly from the provided path</li> <li>Scans all types for static members marked with <code>[&lt;Tests&gt;]</code></li> <li>Collects TestNode lists from these members</li> <li>Applies focused filtering if any <code>fit</code> or <code>fdescribe</code> tests exist</li> <li>Applies user filter if <code>--filter</code> option is provided</li> </ol>"},{"location":"reference/runner/#requirements-for-test-discovery","title":"Requirements for Test Discovery","text":"<p>Your test module must:</p> <ol> <li>Have a static member (let-binding or property)</li> <li>Be marked with <code>[&lt;Tests&gt;]</code> attribute</li> <li>Return <code>TestNode list</code></li> <li>Be in a compiled assembly</li> </ol> <p>Example:</p> <pre><code>module MyTests\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]  // \u2190 Required for discovery\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"works\" (fun () -&gt;\n                expect true |&gt; should beTrue\n            )\n        ]\n    }\n</code></pre>"},{"location":"reference/runner/#focused-tests","title":"Focused Tests","text":"<p>When using <code>fit</code> or <code>fdescribe</code>, the runner automatically filters to run only focused tests:</p> <pre><code>[&lt;Tests&gt;]\nlet specs =\n    spec {\n        yield describe \"Suite\" [\n            fit \"only this runs\" (fun () -&gt;  // \u2190 Focused\n                expect true |&gt; should beTrue\n            )\n\n            it \"this is skipped\" (fun () -&gt;\n                expect false |&gt; should beTrue\n            )\n        ]\n    }\n</code></pre> <p>Output:</p> <pre><code>Suite\n  \u2713 only this runs (1ms)\n  \u2298 this is skipped (skipped - not focused)\n\n1 example, 0 failures, 1 skipped\n</code></pre> <p>Remove focused tests before committing</p> <p>Focused tests are for development only. Remove <code>fit</code>/<code>fdescribe</code> before committing code.</p>"},{"location":"reference/runner/#pending-tests","title":"Pending Tests","text":"<p>Tests marked with <code>xit</code> or <code>pending</code> are skipped:</p> <pre><code>[&lt;Tests&gt;]\nlet specs =\n    spec {\n        yield describe \"Suite\" [\n            it \"this runs\" (fun () -&gt;\n                expect true |&gt; should beTrue\n            )\n\n            xit \"this is skipped\" (fun () -&gt;\n                expect false |&gt; should beTrue\n            )\n\n            pending \"not implemented yet\" (fun () -&gt;\n                failwith \"TODO\"\n            )\n        ]\n    }\n</code></pre> <p>Output:</p> <pre><code>Suite\n  \u2713 this runs (0ms)\n  \u2298 this is skipped (pending)\n  \u2298 not implemented yet (pending)\n\n1 example, 0 failures, 2 skipped\n</code></pre>"},{"location":"reference/runner/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"reference/runner/#github-actions","title":"GitHub Actions","text":"<pre><code>name: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v3\n        with:\n          dotnet-version: '9.0.x'\n\n      - name: Build\n        run: dotnet build\n\n      - name: Run Tests\n        run: |\n          dotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n            tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll \\\n            --format simple\n</code></pre>"},{"location":"reference/runner/#gitlab-ci","title":"GitLab CI","text":"<pre><code>test:\n  image: mcr.microsoft.com/dotnet/sdk:9.0\n  script:\n    - dotnet build\n    - dotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj --\n        tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n        --format simple\n</code></pre>"},{"location":"reference/runner/#azure-pipelines","title":"Azure Pipelines","text":"<pre><code>steps:\n- task: DotNetCoreCLI@2\n  displayName: 'Build Tests'\n  inputs:\n    command: 'build'\n    projects: 'tests/**/*.fsproj'\n\n- script: |\n    dotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n      tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll \\\n      --format simple\n  displayName: 'Run Tests'\n</code></pre>"},{"location":"reference/runner/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/runner/#no-tests-found-in-assembly","title":"\"No tests found in assembly\"","text":"<p>Cause: No members marked with <code>[&lt;Tests&gt;]</code> attribute.</p> <p>Solution:</p> <pre><code>// \u2705 Correct\n[&lt;Tests&gt;]\nlet mySpecs = spec { ... }\n\n// \u274c Wrong - missing attribute\nlet mySpecs = spec { ... }\n</code></pre>"},{"location":"reference/runner/#assembly-not-found","title":"\"Assembly not found\"","text":"<p>Cause: Incorrect path to assembly or assembly not built.</p> <p>Solution:</p> <pre><code># Build first\ndotnet build tests/MyProject.Tests/MyProject.Tests.fsproj\n\n# Then run with correct path\ndotnet run --project src/FxSpec.Runner/FxSpec.Runner.fsproj -- \\\n  tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n</code></pre>"},{"location":"reference/runner/#no-tests-match-the-filter","title":"\"No tests match the filter\"","text":"<p>Cause: Filter pattern doesn't match any test descriptions.</p> <p>Solution:</p> <ul> <li>Check filter is case-sensitive</li> <li>Use partial matches: <code>--filter \"Calc\"</code> instead of <code>--filter \"Calculator tests\"</code></li> <li>Remove filter to see all test names</li> </ul>"},{"location":"reference/runner/#see-also","title":"See Also","text":"<ul> <li>DSL API Reference - Complete DSL documentation</li> <li>Quick Start Guide - Getting started</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"reference/matchers/collections/","title":"Collection Matchers","text":"<p>Matchers for lists, arrays, sequences, and other collections.</p>"},{"location":"reference/matchers/collections/#membership","title":"Membership","text":""},{"location":"reference/matchers/collections/#contain","title":"contain","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection contains the expected item.</p> <p>Usage:</p> <pre><code>expectSeq(collection).toContain(item)\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([1; 2; 3]).toContain(2)\nexpectSeq([|\"a\"; \"b\"; \"c\"|]).toContain(\"b\")\nexpectSeq((seq { 1..10 })).toContain(5)\n\n// With custom types\ntype Person = { Name: string }\nlet people = [{ Name = \"Alice\" }; { Name = \"Bob\" }]\nexpectSeq(people).toContain({ Name = \"Alice\" })\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toContain(5)\n// =&gt; Expected collection to contain 5, but it did not. Collection: [1; 2; 3]\n</code></pre>"},{"location":"reference/matchers/collections/#containall","title":"containAll","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection contains all expected items (in any order).</p> <p>Usage:</p> <pre><code>expectSeq(collection).toContainAll(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([1; 2; 3; 4; 5]).toContainAll([2; 4])\nexpectSeq([1; 2; 3; 4; 5]).toContainAll([5; 1; 3])  // Order doesn't matter\nexpectSeq([\"a\"; \"b\"; \"c\"; \"d\"]).toContainAll([\"c\"; \"a\"])\n\n// Empty expected list always passes\nexpectSeq([1; 2; 3]).toContainAll([])\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toContainAll([2; 5; 7])\n// =&gt; Expected collection to contain all of [2; 5; 7], but missing: [5; 7]\n</code></pre>"},{"location":"reference/matchers/collections/#size","title":"Size","text":""},{"location":"reference/matchers/collections/#beempty","title":"beEmpty","text":"<p>Type: <code>Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection is empty.</p> <p>Usage:</p> <pre><code>expectSeq(collection).toBeEmpty()\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([]).toBeEmpty()\nexpect [||] |&gt; should beEmpty\nexpectSeq(Seq.empty).toBeEmpty()\nexpectSeq((List&lt;int&gt;())).toBeEmpty()\n\n// After operations\nlet filtered = [1; 2; 3] |&gt; List.filter (fun x -&gt; x &gt; 10)\nexpectSeq(filtered).toBeEmpty()\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toBeEmpty()\n// =&gt; Expected empty collection, but found 3 items\n</code></pre>"},{"location":"reference/matchers/collections/#havelength","title":"haveLength","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has the expected length.</p> <p>Usage:</p> <pre><code>expectSeq(collection).toHaveLength(count)\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([1; 2; 3]).toHaveLength(3)\nexpect [|\"a\"; \"b\"|] |&gt; should (haveLength 2)\nexpectSeq(\"hello\").toHaveLength(5)  // Strings are sequences of chars\n\n// With operations\nlet doubled = [1; 2; 3] |&gt; List.map (fun x -&gt; x * 2)\nexpectSeq(doubled).toHaveLength(3)\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toHaveLength(5)\n// =&gt; Expected collection to have length 5, but found length 3\n</code></pre> <p>Notes:</p> <ul> <li>Validates that expected length is non-negative</li> <li>Works with any <code>seq&lt;'a&gt;</code></li> <li>For strings, use <code>haveStringLength</code> for better error messages</li> </ul>"},{"location":"reference/matchers/collections/#havecountatleast","title":"haveCountAtLeast","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has at least the expected count.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (haveCountAtLeast minimum)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (haveCountAtLeast 3)  // Passes (5 &gt;= 3)\nexpect [1; 2] |&gt; should (haveCountAtLeast 2)  // Passes (2 &gt;= 2)\nexpect [1] |&gt; should (haveCountAtLeast 5)  // Fails (1 &lt; 5)\n\n// Useful for pagination\nlet page = database.Query().Take(10)\nexpect page |&gt; should (haveCountAtLeast 1)  // At least one result\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2] |&gt; should (haveCountAtLeast 5)\n// =&gt; Expected collection to have at least 5 items, but found 2\n</code></pre>"},{"location":"reference/matchers/collections/#havecountatmost","title":"haveCountAtMost","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has at most the expected count.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (haveCountAtMost maximum)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2] |&gt; should (haveCountAtMost 5)  // Passes (2 &lt;= 5)\nexpect [1; 2; 3] |&gt; should (haveCountAtMost 3)  // Passes (3 &lt;= 3)\nexpect [1; 2; 3; 4; 5] |&gt; should (haveCountAtMost 3)  // Fails (5 &gt; 3)\n\n// Useful for limiting results\nlet recent = events |&gt; List.take 100\nexpect recent |&gt; should (haveCountAtMost 100)\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (haveCountAtMost 3)\n// =&gt; Expected collection to have at most 3 items, but found 5\n</code></pre>"},{"location":"reference/matchers/collections/#sequences","title":"Sequences","text":""},{"location":"reference/matchers/collections/#equalseq","title":"equalSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection equals the expected sequence (same order, same values).</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (equalSeq expected)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3] |&gt; should (equalSeq [1; 2; 3])\nexpect [|\"a\"; \"b\"|] |&gt; should (equalSeq [\"a\"; \"b\"])  // Arrays and lists can be compared\n\n// Order matters!\nexpect [1; 2; 3] |&gt; shouldNot (equalSeq [3; 2; 1])\nexpect [1; 2; 3] |&gt; shouldNot (equalSeq [1; 3; 2])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (equalSeq [1; 2; 4])\n// =&gt; Expected sequence [1; 2; 4], but found [1; 2; 3]\n</code></pre> <p>Notes:</p> <ul> <li>Order matters (unlike <code>containAll</code>)</li> <li>Use <code>equal</code> for structural equality (works with lists, arrays, etc.)</li> <li>Use <code>equalSeq</code> when comparing different collection types</li> </ul>"},{"location":"reference/matchers/collections/#startwithseq","title":"startWithSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection starts with the expected sequence.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (startWithSeq prefix)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (startWithSeq [1; 2])\nexpect [1; 2; 3; 4; 5] |&gt; should (startWithSeq [1; 2; 3])\nexpect [1; 2; 3; 4; 5] |&gt; should (startWithSeq [])  // Empty prefix always matches\n\n// Fails\nexpect [1; 2; 3; 4; 5] |&gt; shouldNot (startWithSeq [2; 3])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (startWithSeq [2; 3])\n// =&gt; Expected sequence to start with [2; 3], but found [1; 2]\n</code></pre>"},{"location":"reference/matchers/collections/#endwithseq","title":"endWithSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection ends with the expected sequence.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (endWithSeq suffix)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (endWithSeq [4; 5])\nexpect [1; 2; 3; 4; 5] |&gt; should (endWithSeq [3; 4; 5])\nexpect [1; 2; 3; 4; 5] |&gt; should (endWithSeq [])  // Empty suffix always matches\n\n// Fails\nexpect [1; 2; 3; 4; 5] |&gt; shouldNot (endWithSeq [3; 4])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (endWithSeq [2; 4])\n// =&gt; Expected sequence to end with [2; 4], but found [2; 3]\n</code></pre>"},{"location":"reference/matchers/collections/#predicates","title":"Predicates","text":""},{"location":"reference/matchers/collections/#allsatisfy","title":"allSatisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a seq&gt;)</code></p> <p>Matches if all items in the collection satisfy the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test each item</li> <li><code>description</code> - Human-readable description</li> </ul> <p>Usage:</p> <pre><code>expect collection |&gt; should (allSatisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>expect [2; 4; 6; 8] |&gt; should (allSatisfy (fun x -&gt; x % 2 = 0) \"be even\")\nexpect [\"hello\"; \"world\"] |&gt; should (allSatisfy (fun s -&gt; s.Length &gt; 0) \"be non-empty\")\n\n// With domain logic\ntype User = { Name: string; Age: int }\nlet users = [\n    { Name = \"Alice\"; Age = 25 }\n    { Name = \"Bob\"; Age = 30 }\n]\nexpect users |&gt; should (allSatisfy (fun u -&gt; u.Age &gt;= 18) \"be adults\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect [2; 3; 4; 5] |&gt; should (allSatisfy (fun x -&gt; x % 2 = 0) \"be even\")\n// =&gt; Expected all items to satisfy 'be even', but these did not: [3; 5]\n</code></pre> <p>Notes:</p> <ul> <li>Shows up to 5 failing items in error message</li> <li>Empty collection always passes (vacuous truth)</li> <li>Use descriptive descriptions for clear error messages</li> </ul>"},{"location":"reference/matchers/collections/#anysatisfy","title":"anySatisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a seq&gt;)</code></p> <p>Matches if at least one item in the collection satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test each item</li> <li><code>description</code> - Human-readable description</li> </ul> <p>Usage:</p> <pre><code>expect collection |&gt; should (anySatisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (anySatisfy (fun x -&gt; x &gt; 3) \"be greater than 3\")\nexpect [\"hello\"; \"world\"; \"!\"] |&gt; should (anySatisfy (fun s -&gt; s.Length = 1) \"be a single character\")\n\n// Searching\ntype Product = { Name: string; Price: decimal; InStock: bool }\nlet products = [\n    { Name = \"Laptop\"; Price = 999.99m; InStock = true }\n    { Name = \"Mouse\"; Price = 29.99m; InStock = false }\n]\nexpect products |&gt; should (anySatisfy (fun p -&gt; p.InStock) \"be in stock\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (anySatisfy (fun x -&gt; x &gt; 10) \"be greater than 10\")\n// =&gt; Expected at least one item to satisfy 'be greater than 10', but none did. Collection: [1; 2; 3]\n</code></pre> <p>Notes:</p> <ul> <li>Fails on empty collection (no items to satisfy)</li> <li>Short-circuits on first match (efficient for large collections)</li> <li>Shows collection contents in error message (up to 10 items)</li> </ul>"},{"location":"reference/matchers/collections/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/collections/#testing-a-shopping-cart","title":"Testing a Shopping Cart","text":"<pre><code>module ShoppingCartSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\ntype CartItem = { ProductId: int; Quantity: int; Price: decimal }\ntype Cart = { Items: CartItem list }\n\n[&lt;Tests&gt;]\nlet shoppingCartSpecs =\n    spec {\n        describe \"ShoppingCart\" [\n            describe \"addItem\" [\n                it \"adds item to empty cart\" (fun () -&gt;\n                    let cart = Cart.empty\n                    let updated = cart.AddItem({ ProductId = 1; Quantity = 2; Price = 10.00m })\n\n                    expectSeq(updated.Items).toHaveLength(1)\n                    expectSeq(updated.Items).toContain({ ProductId = 1; Quantity = 2; Price = 10.00m })\n                )\n\n                it \"increases quantity for existing item\" (fun () -&gt;\n                    let cart = { Items = [{ ProductId = 1; Quantity = 1; Price = 10.00m }] }\n                    let updated = cart.AddItem({ ProductId = 1; Quantity = 2; Price = 10.00m })\n\n                    expectSeq(updated.Items).toHaveLength(1)\n                    expect updated.Items.[0].Quantity |&gt; should (equal 3)\n                )\n            ]\n\n            describe \"removeItem\" [\n                it \"removes item from cart\" (fun () -&gt;\n                    let cart = {\n                        Items = [\n                            { ProductId = 1; Quantity = 1; Price = 10.00m }\n                            { ProductId = 2; Quantity = 1; Price = 20.00m }\n                        ]\n                    }\n                    let updated = cart.RemoveItem(1)\n\n                    expectSeq(updated.Items).toHaveLength(1)\n                    expect updated.Items |&gt; should (anySatisfy (fun item -&gt; item.ProductId = 2) \"contain product 2\")\n                    expect updated.Items |&gt; shouldNot (anySatisfy (fun item -&gt; item.ProductId = 1) \"contain product 1\")\n                )\n            ]\n\n            describe \"total\" [\n                it \"calculates total price\" (fun () -&gt;\n                    let cart = {\n                        Items = [\n                            { ProductId = 1; Quantity = 2; Price = 10.00m }  // $20\n                            { ProductId = 2; Quantity = 1; Price = 30.00m }  // $30\n                        ]\n                    }\n                    let total = cart.Total()\n\n                    expect total |&gt; should (equal 50.00m)\n                )\n\n                it \"returns zero for empty cart\" (fun () -&gt;\n                    let cart = Cart.empty\n                    expect cart.Total() |&gt; should (equal 0.00m)\n                    expectSeq(cart.Items).toBeEmpty()\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/collections/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality and type matchers</li> <li>String Matchers - String-specific matchers</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Quick Start - Get started with FxSpec</li> </ul>"},{"location":"reference/matchers/core/","title":"Core Expectations","text":"<p>Basic equality checks, booleans, Option, Result, and common assertions.</p>"},{"location":"reference/matchers/core/#expectation-functions","title":"Expectation Functions","text":"<p>FxSpec provides type-specific expectation functions that return fluent wrappers with relevant assertion methods.</p>"},{"location":"reference/matchers/core/#expect","title":"expect","text":"<p>Type: <code>'a -&gt; Expectation&lt;'a&gt;</code></p> <p>Creates a generic expectation for any type.</p> <p>Usage:</p> <pre><code>expect(actual).toEqual(expected)\nexpect(actual).notToEqual(unexpected)\n</code></pre> <p>Example:</p> <pre><code>expect(2 + 2).toEqual(4)\nexpect(\"hello\").notToEqual(\"world\")\nexpect([1; 2; 3]).toEqual([1; 2; 3])\n</code></pre> <p>Available Methods: - <code>.toEqual(expected)</code> - Asserts equality using F#'s structural equality - <code>.notToEqual(unexpected)</code> - Asserts inequality</p>"},{"location":"reference/matchers/core/#expectbool","title":"expectBool","text":"<p>Type: <code>bool -&gt; BoolExpectation</code></p> <p>Creates an expectation for boolean values.</p> <p>Usage:</p> <pre><code>expectBool(actual).toBeTrue()\nexpectBool(actual).toBeFalse()\n</code></pre> <p>Examples:</p> <pre><code>expectBool(true).toBeTrue()\nexpectBool(false).toBeFalse()\nexpectBool(10 &gt; 5).toBeTrue()\nexpectBool(\"\".Length = 0).toBeTrue()\n</code></pre> <p>Available Methods: - <code>.toBeTrue()</code> - Asserts the value is true - <code>.toBeFalse()</code> - Asserts the value is false</p>"},{"location":"reference/matchers/core/#expectoption","title":"expectOption","text":"<p>Type: <code>'a option -&gt; OptionExpectation&lt;'a&gt;</code></p> <p>Creates an expectation for Option values.</p> <p>Usage:</p> <pre><code>expectOption(actual).toBeSome(expected)\nexpectOption(actual).toBeNone()\n</code></pre> <p>Examples:</p> <pre><code>expectOption(Some 42).toBeSome(42)\nexpectOption(None).toBeNone()\n\nlet result = tryParse \"123\"\nexpectOption(result).toBeSome(123)\n\nlet notFound = Map.tryFind \"key\" emptyMap\nexpectOption(notFound).toBeNone()\n</code></pre> <p>Available Methods: - <code>.toBeSome(expected)</code> - Asserts the Option is Some with the expected value - <code>.toBeNone()</code> - Asserts the Option is None</p>"},{"location":"reference/matchers/core/#expectresult","title":"expectResult","text":"<p>Type: <code>Result&lt;'a, 'b&gt; -&gt; ResultExpectation&lt;'a, 'b&gt;</code></p> <p>Creates an expectation for Result values.</p> <p>Usage:</p> <pre><code>expectResult(actual).toBeOk(expected)\nexpectResult(actual).toBeError(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectResult(Ok \"success\").toBeOk(\"success\")\nexpectResult(Error \"failed\").toBeError(\"failed\")\n\nlet parseResult = Int32.TryParse(\"42\")\nexpectResult(parseResult).toBeOk(42)\n\nlet divisionResult = divide 10 0\nexpectResult(divisionResult).toBeError(\"Division by zero\")\n</code></pre> <p>Available Methods: - <code>.toBeOk(expected)</code> - Asserts the Result is Ok with the expected value - <code>.toBeError(expected)</code> - Asserts the Result is Error with the expected error</p>"},{"location":"reference/matchers/core/#equality-assertions","title":"Equality Assertions","text":"<p>The <code>expect()</code> function provides basic equality checking:</p> <p>Examples:</p> <pre><code>// Primitives\nexpect(42).toEqual(42)\nexpect(\"hello\").toEqual(\"hello\")\nexpect(true).toEqual(true)\n\n// Collections (structural equality)\nexpect([1; 2; 3]).toEqual([1; 2; 3])\nexpect({| Name = \"Alice\"; Age = 30 |}).toEqual({| Name = \"Alice\"; Age = 30 |})\n\n// Records and DUs\ntype Person = { Name: string; Age: int }\nlet person1 = { Name = \"Alice\"; Age = 30 }\nlet person2 = { Name = \"Alice\"; Age = 30 }\nexpect(person1).toEqual(person2)  // Passes\n\n// Negative assertions\nexpect(5).notToEqual(10)\nexpect(\"hello\").notToEqual(\"world\")\n</code></pre> <p>Notes:</p> <ul> <li>Uses F# <code>=</code> operator (structural equality)</li> <li>Works with any type that supports equality</li> <li>Provides clear diff output on failure</li> </ul> <p>let result = validateAge(-1) expect result |&gt; should (beError \"Age must be positive\") <pre><code>**Failure Messages:**\n\n```fsharp\n// If actual is Ok\nexpect (Ok 42) |&gt; should (beError \"failed\")\n// =&gt; Expected Error \"failed\", but found Ok 42\n\n// If actual is Error with different value\nexpect (Error \"error1\") |&gt; should (beError \"error2\")\n// =&gt; Expected Error \"error2\", but found Error \"error1\"\n</code></pre></p>"},{"location":"reference/matchers/core/#type-checking","title":"Type Checking","text":""},{"location":"reference/matchers/core/#beoftype","title":"beOfType","text":"<p>Type: <code>Matcher&lt;obj&gt;</code></p> <p>Matches if the actual value is of the specified type.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should (beOfType&lt;TargetType&gt;)\n</code></pre> <p>Examples:</p> <pre><code>expect (box \"hello\") |&gt; should (beOfType&lt;string&gt;)\nexpect (box 42) |&gt; should (beOfType&lt;int&gt;)\nexpect (box [1; 2; 3]) |&gt; should (beOfType&lt;int list&gt;)\n\n// With inheritance\ntype Animal = { Name: string }\ntype Dog = { Name: string; Breed: string }\n\nlet animal: obj = box { Name = \"Buddy\"; Breed = \"Labrador\" }\nexpect animal |&gt; should (beOfType&lt;Dog&gt;)\n</code></pre> <p>Failure Message:</p> <pre><code>expect (box 42) |&gt; should (beOfType&lt;string&gt;)\n// =&gt; Expected type string, but found type Int32\n</code></pre>"},{"location":"reference/matchers/core/#reference-equality","title":"Reference Equality","text":""},{"location":"reference/matchers/core/#besameas","title":"beSameAs","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt;</code></p> <p>Matches if the actual value is the same reference as the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should (beSameAs expected)\n</code></pre> <p>Examples:</p> <pre><code>let list1 = [1; 2; 3]\nlet list2 = list1\nlet list3 = [1; 2; 3]\n\nexpect list2 |&gt; should (beSameAs list1)  // Passes (same reference)\nexpect list3 |&gt; shouldNot (beSameAs list1)  // Passes (different reference, same value)\n\n// Singletons\nlet singleton = SingletonService.Instance\nexpect (SingletonService.Instance) |&gt; should (beSameAs singleton)\n</code></pre> <p>Notes:</p> <ul> <li>Uses <code>obj.ReferenceEquals</code></li> <li>Different from <code>equal</code> which uses structural equality</li> <li>Useful for testing singletons, caching, or memoization</li> </ul>"},{"location":"reference/matchers/core/#custom-predicates","title":"Custom Predicates","text":""},{"location":"reference/matchers/core/#satisfy","title":"satisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a&gt;)</code></p> <p>Matches if the actual value satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test the value</li> <li><code>description</code> - Human-readable description of the predicate</li> </ul> <p>Usage:</p> <pre><code>expect actual |&gt; should (satisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>// Simple predicate\nexpect 10 |&gt; should (satisfy (fun x -&gt; x &gt; 5) \"be greater than 5\")\n\n// Complex predicate\nexpect \"hello\" |&gt; should (satisfy\n    (fun s -&gt; s.Length &gt; 3 &amp;&amp; s.StartsWith(\"h\"))\n    \"be longer than 3 chars and start with 'h'\"\n)\n\n// Domain validation\ntype Email = Email of string\nlet isValidEmail (Email email) =\n    email.Contains(\"@\") &amp;&amp; email.Contains(\".\")\n\nexpect (Email \"test@example.com\") |&gt; should (satisfy isValidEmail \"be a valid email\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect 3 |&gt; should (satisfy (fun x -&gt; x &gt; 5) \"be greater than 5\")\n// =&gt; Expected value to satisfy 'be greater than 5', but 3 did not\n</code></pre> <p>Notes:</p> <ul> <li>Use for custom validation logic</li> <li>Description is shown in failure messages</li> <li>Consider creating a dedicated matcher for commonly used predicates</li> </ul>"},{"location":"reference/matchers/core/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/core/#testing-a-user-registration-function","title":"Testing a User Registration Function","text":"<pre><code>module UserRegistrationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\ntype ValidationError =\n    | EmailInvalid\n    | PasswordTooShort\n    | UsernameTaken\n\ntype User = { Id: int; Email: string; Username: string }\n\n[&lt;Tests&gt;]\nlet userRegistrationSpecs =\n    spec {\n        describe \"UserService.Register\" [\n            context \"when valid data is provided\" [\n                it \"returns Ok with new user\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"alice@example.com\", \"password123\")\n\n                    match result with\n                    | Ok user -&gt;\n                        expect user.Username |&gt; should (equal \"alice\")\n                        expect user.Email |&gt; should (equal \"alice@example.com\")\n                        expect user.Id |&gt; should (beGreaterThan 0)\n                    | Error _ -&gt;\n                        failwith \"Expected Ok but got Error\"\n                )\n            ]\n\n            context \"when email is invalid\" [\n                it \"returns Error EmailInvalid\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"not-an-email\", \"password123\")\n                    expect result |&gt; should (beError EmailInvalid)\n                )\n            ]\n\n            context \"when password is too short\" [\n                it \"returns Error PasswordTooShort\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"alice@example.com\", \"123\")\n                    expect result |&gt; should (beError PasswordTooShort)\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/core/#see-also","title":"See Also","text":"<ul> <li>Collection Matchers - Matchers for lists, arrays, and sequences</li> <li>String Matchers - String-specific matchers</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Exception Matchers - Exception testing</li> <li>Quick Start - Get started with FxSpec</li> </ul>"},{"location":"reference/matchers/exceptions/","title":"Exception Matchers","text":"<p>Matchers for testing exception throwing behavior.</p>"},{"location":"reference/matchers/exceptions/#basic-exception-testing","title":"Basic Exception Testing","text":""},{"location":"reference/matchers/exceptions/#raiseexception","title":"raiseException","text":"<p>Type: <code>Matcher&lt;unit -&gt; unit&gt; when 'T :&gt; exn</code></p> <p>Matches if the function raises an exception of the specified type.</p> <p>Usage:</p> <pre><code>expectThrows&lt;ExceptionType&gt;(action)\n</code></pre> <p>Examples:</p> <pre><code>// Basic exception\nexpectThrows&lt;System.Exception&gt;(fun () -&gt; failwith \"error\")\n\n// Specific exception type\nexpectThrows&lt;System.ArgumentException&gt;(fun () -&gt; invalidArg \"param\" \"error\")\n\n// Division by zero\nexpectThrows&lt;System.DivideByZeroException&gt;(fun () -&gt; 1 / 0 |&gt; ignore)\n\n// Custom exceptions\ntype ValidationException() = inherit exn()\nexpect (fun () -&gt; raise (ValidationException())) |&gt; should raiseException&lt;ValidationException&gt;\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception thrown\nexpectThrows&lt;Exception&gt;(fun () -&gt; 1 + 1)\n// =&gt; Expected an exception of type Exception to be thrown, but nothing was thrown\n\n// Wrong exception type\nexpectThrows&lt;InvalidOperationException&gt;(fun () -&gt; invalidArg \"x\" \"error\")\n// =&gt; Expected an exception of type InvalidOperationException, but an exception of type ArgumentException was thrown: error\n</code></pre> <p>Notes:</p> <ul> <li>Use generic type parameter to specify expected exception type</li> <li>Catches exact type and derived types</li> <li>Use most specific exception type possible for clarity</li> </ul>"},{"location":"reference/matchers/exceptions/#message-matching","title":"Message Matching","text":""},{"location":"reference/matchers/exceptions/#raiseexceptionwithmessage","title":"raiseExceptionWithMessage","text":"<p>Type: <code>string -&gt; Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function raises an exception with the specified message (exact match).</p> <p>Usage:</p> <pre><code>expectThrowsWithMessage(action, \"expected message\")\n</code></pre> <p>Examples:</p> <pre><code>expectThrowsWithMessage(fun () -&gt; failwith \"error\", \"error\")\nexpectThrowsWithMessage(fun () -&gt; invalidArg \"x\" \"must be positive\", \"must be positive (Parameter 'x')\")\n\n// Custom error messages\nlet validateAge age =\n    if age &lt; 0 then\n        invalidArg (nameof age) \"Age cannot be negative\"\n\nexpectThrowsWithMessage(fun () -&gt; validateAge -5, \"Age cannot be negative (Parameter 'age')\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception\nexpectThrowsWithMessage(fun () -&gt; 1 + 1, \"error\")\n// =&gt; Expected an exception with message 'error' to be thrown, but nothing was thrown\n\n// Different message\nexpectThrowsWithMessage(fun () -&gt; failwith \"wrong\", \"error\")\n// =&gt; Expected exception message 'error', but found 'wrong'\n</code></pre> <p>Notes:</p> <ul> <li>Message must match exactly (case-sensitive)</li> <li>For partial matching, use <code>raiseExceptionContaining</code></li> <li>Be aware of .NET exception message formatting (e.g., ArgumentException adds parameter name)</li> </ul>"},{"location":"reference/matchers/exceptions/#raiseexceptioncontaining","title":"raiseExceptionContaining","text":"<p>Type: <code>string -&gt; Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function raises an exception containing the specified substring.</p> <p>Usage:</p> <pre><code>expect action |&gt; should (raiseExceptionContaining \"substring\")\n</code></pre> <p>Examples:</p> <pre><code>expect (fun () -&gt; failwith \"file not found\") |&gt; should (raiseExceptionContaining \"not found\")\nexpect (fun () -&gt; failwith \"error: invalid input\") |&gt; should (raiseExceptionContaining \"error:\")\n\n// Partial message matching\nlet validateEmail email =\n    if not (email.Contains(\"@\")) then\n        invalidOp \"Email must contain @\"\n\nexpect (fun () -&gt; validateEmail \"invalid\") |&gt; should (raiseExceptionContaining \"@\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception\nexpect (fun () -&gt; 1 + 1) |&gt; should (raiseExceptionContaining \"error\")\n// =&gt; Expected an exception containing 'error' to be thrown, but nothing was thrown\n\n// Substring not found\nexpect (fun () -&gt; failwith \"wrong\") |&gt; should (raiseExceptionContaining \"error\")\n// =&gt; Expected exception message to contain 'error', but found 'wrong'\n</code></pre> <p>Notes:</p> <ul> <li>Case-sensitive substring matching</li> <li>More flexible than exact message matching</li> <li>Good for testing error messages that include dynamic content (IDs, timestamps, etc.)</li> </ul>"},{"location":"reference/matchers/exceptions/#advanced-exception-testing","title":"Advanced Exception Testing","text":""},{"location":"reference/matchers/exceptions/#raiseexceptionmatching","title":"raiseExceptionMatching","text":"<p>Type: <code>('T -&gt; bool) -&gt; string -&gt; Matcher&lt;unit -&gt; unit&gt; when 'T :&gt; exn</code></p> <p>Matches if the function raises an exception of the specified type that satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test the exception</li> <li><code>description</code> - Human-readable description of the predicate</li> </ul> <p>Usage:</p> <pre><code>expect action |&gt; should (raiseExceptionMatching&lt;ExceptionType&gt; predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>// Check exception property\ntype CustomException(code: int) =\n    inherit exn()\n    member _.ErrorCode = code\n\nexpect (fun () -&gt; raise (CustomException(404))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode = 404)\n        \"have error code 404\")\n\n// ArgumentException with specific parameter name\nexpect (fun () -&gt; invalidArg \"userId\" \"error\") |&gt; to'\n    (raiseExceptionMatching&lt;ArgumentException&gt;\n        (fun ex -&gt; ex.ParamName = \"userId\")\n        \"have parameter name 'userId'\")\n\n// Multiple conditions\nexpect (fun () -&gt; raise (CustomException(500))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode &gt;= 500 &amp;&amp; ex.ErrorCode &lt; 600)\n        \"have 5xx error code\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// Exception doesn't match predicate\nexpect (fun () -&gt; raise (CustomException(200))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode = 404)\n        \"have error code 404\")\n// =&gt; Expected exception to match 'have error code 404', but it did not: [exception message]\n\n// Wrong exception type\nexpect (fun () -&gt; failwith \"error\") |&gt; to'\n    (raiseExceptionMatching&lt;ArgumentException&gt;\n        (fun ex -&gt; ex.ParamName = \"x\")\n        \"have parameter name 'x'\")\n// =&gt; Expected an exception of type ArgumentException, but an exception of type Exception was thrown\n</code></pre> <p>Notes:</p> <ul> <li>Combines type checking and predicate matching</li> <li>Description appears in error messages</li> <li>Use for complex exception validation</li> <li>Predicate receives strongly-typed exception</li> </ul>"},{"location":"reference/matchers/exceptions/#negative-testing","title":"Negative Testing","text":""},{"location":"reference/matchers/exceptions/#notraiseexception","title":"notRaiseException","text":"<p>Type: <code>Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function does not raise any exception.</p> <p>Usage:</p> <pre><code>expect action |&gt; should notRaiseException\n</code></pre> <p>Examples:</p> <pre><code>expect (fun () -&gt; 1 + 1) |&gt; should notRaiseException\nexpect (fun () -&gt; printfn \"hello\") |&gt; should notRaiseException\n\n// Safe operations\nlet safeDivide x y =\n    if y = 0 then 0\n    else x / y\n\nexpect (fun () -&gt; safeDivide 10 0 |&gt; ignore) |&gt; should notRaiseException\n</code></pre> <p>Failure Message:</p> <pre><code>expect (fun () -&gt; failwith \"error\") |&gt; should notRaiseException\n// =&gt; Expected no exception to be thrown, but Exception was thrown: error\n\nexpect (fun () -&gt; 1 / 0 |&gt; ignore) |&gt; should notRaiseException\n// =&gt; Expected no exception to be thrown, but DivideByZeroException was thrown: Attempted to divide by zero.\n</code></pre> <p>Notes:</p> <ul> <li>Useful for testing error handling code</li> <li>Can also use <code>notTo' raiseException&lt;exn&gt;</code></li> <li>Shows exception type and message in failure</li> </ul>"},{"location":"reference/matchers/exceptions/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/exceptions/#testing-input-validation","title":"Testing Input Validation","text":"<pre><code>module ValidationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\nopen System\n\ntype ValidationError =\n    | Required of field: string\n    | InvalidFormat of field: string\n    | OutOfRange of field: string * min: int * max: int\n\nexception ValidationException of ValidationError\n\nmodule Validator =\n    let validateAge age =\n        if age &lt; 0 then\n            invalidArg (nameof age) \"Age cannot be negative\"\n        elif age &gt; 150 then\n            invalidArg (nameof age) \"Age must be less than 150\"\n        else\n            age\n\n    let validateEmail email =\n        if String.IsNullOrWhiteSpace(email) then\n            raise (ValidationException(Required \"email\"))\n        elif not (email.Contains(\"@\")) then\n            raise (ValidationException(InvalidFormat \"email\"))\n        else\n            email\n\n[&lt;Tests&gt;]\nlet validationSpecs =\n    spec {\n        describe \"Validator\" [\n            describe \"validateAge\" [\n                context \"when age is valid\" [\n                    it \"returns age without exception\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge 25 |&gt; ignore) |&gt; should notRaiseException\n                    )\n                ]\n\n                context \"when age is negative\" [\n                    it \"raises ArgumentException\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            raiseException&lt;ArgumentException&gt;\n                    )\n\n                    it \"has descriptive error message\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            (raiseExceptionContaining \"cannot be negative\")\n                    )\n\n                    it \"includes parameter name\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            (raiseExceptionMatching&lt;ArgumentException&gt;\n                                (fun ex -&gt; ex.ParamName = \"age\")\n                                \"have parameter name 'age'\")\n                    )\n                ]\n\n                context \"when age is too large\" [\n                    it \"raises ArgumentException with message\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge 200 |&gt; ignore) |&gt; to'\n                            (raiseExceptionContaining \"less than 150\")\n                    )\n                ]\n            ]\n\n            describe \"validateEmail\" [\n                context \"when email is null or empty\" [\n                    it \"raises ValidationException with Required error\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"\" |&gt; ignore) |&gt; to'\n                            (raiseExceptionMatching&lt;ValidationException&gt;\n                                (fun ex -&gt;\n                                    match ex.Data0 with\n                                    | Required field -&gt; field = \"email\"\n                                    | _ -&gt; false)\n                                \"have Required error for email field\")\n                    )\n                ]\n\n                context \"when email format is invalid\" [\n                    it \"raises ValidationException with InvalidFormat error\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"notanemail\" |&gt; ignore) |&gt; to'\n                            raiseException&lt;ValidationException&gt;\n                    )\n                ]\n\n                context \"when email is valid\" [\n                    it \"does not raise exception\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"test@example.com\" |&gt; ignore) |&gt; to'\n                            notRaiseException\n                    )\n                ]\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/exceptions/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>module ErrorHandlingSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\nopen System\nopen System.IO\n\nmodule FileService =\n    let readFile path =\n        if not (File.Exists(path)) then\n            raise (FileNotFoundException($\"File not found: {path}\"))\n        File.ReadAllText(path)\n\n    let safeReadFile path =\n        try\n            Ok (readFile path)\n        with\n        | :? FileNotFoundException as ex -&gt; Error ex.Message\n        | ex -&gt; Error $\"Unexpected error: {ex.Message}\"\n\n[&lt;Tests&gt;]\nlet errorHandlingSpecs =\n    spec {\n        describe \"FileService\" [\n            describe \"readFile\" [\n                it \"raises FileNotFoundException for missing file\" (fun () -&gt;\n                    expect (fun () -&gt; FileService.readFile \"nonexistent.txt\" |&gt; ignore) |&gt; to'\n                        raiseException&lt;FileNotFoundException&gt;\n                )\n\n                it \"includes filename in exception message\" (fun () -&gt;\n                    let path = \"missing.txt\"\n                    expect (fun () -&gt; FileService.readFile path |&gt; ignore) |&gt; to'\n                        (raiseExceptionContaining path)\n                )\n            ]\n\n            describe \"safeReadFile\" [\n                it \"returns Error for missing file\" (fun () -&gt;\n                    let result = FileService.safeReadFile \"nonexistent.txt\"\n                    expect result |&gt; should (satisfy Result.isError \"be Error\")\n                )\n\n                it \"does not raise exception\" (fun () -&gt;\n                    expect (fun () -&gt; FileService.safeReadFile \"nonexistent.txt\" |&gt; ignore) |&gt; to'\n                        notRaiseException\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/exceptions/#best-practices","title":"Best Practices","text":""},{"location":"reference/matchers/exceptions/#be-specific","title":"Be Specific","text":"<pre><code>// Good - specific exception type\nexpectThrows&lt;ArgumentNullException&gt;(action)\n\n// Less good - generic exception type\nexpectThrows&lt;Exception&gt;(action)\n</code></pre>"},{"location":"reference/matchers/exceptions/#test-exception-messages","title":"Test Exception Messages","text":"<pre><code>// Good - validates error communication\nexpect action |&gt; should (raiseExceptionContaining \"must be positive\")\n\n// Less good - only checks exception type\nexpectThrows&lt;ArgumentException&gt;(action)\n</code></pre>"},{"location":"reference/matchers/exceptions/#use-lambdas-for-lazy-evaluation","title":"Use Lambdas for Lazy Evaluation","text":"<pre><code>// Good - lazy evaluation\nexpect (fun () -&gt; riskyOperation()) |&gt; should raiseException&lt;Exception&gt;\n\n// Wrong - evaluates immediately, exception thrown before matcher\nexpect riskyOperation() |&gt; should raiseException&lt;Exception&gt;  // Compilation error\n</code></pre>"},{"location":"reference/matchers/exceptions/#prefer-result-types-for-errors","title":"Prefer Result Types for Errors","text":"<pre><code>// Consider using Result types instead of exceptions for expected errors\ntype ValidationResult = Result&lt;ValidatedData, ValidationError&gt;\n\nlet validate data : ValidationResult =\n    if isValid data then\n        Ok (ValidatedData data)\n    else\n        Error (ValidationError \"Invalid data\")\n\n// Test with Result matchers\nexpect (validate invalidData) |&gt; should (beError (ValidationError \"Invalid data\"))\n</code></pre>"},{"location":"reference/matchers/exceptions/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic matchers including Result matchers</li> <li>Quick Start - Get started with FxSpec</li> <li>DSL API - Complete DSL reference</li> </ul>"},{"location":"reference/matchers/numeric/","title":"Numeric Matchers","text":"<p>Numeric comparisons and range checks for numbers.</p>"},{"location":"reference/matchers/numeric/#comparisons","title":"Comparisons","text":""},{"location":"reference/matchers/numeric/#begreaterthan","title":"beGreaterThan","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is greater than the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeGreaterThan(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(10).toBeGreaterThan(5)\nexpectNum(3.14).toBeGreaterThan(3.0)\nexpectNum(100L).toBeGreaterThan(50L)\n\n// After calculations\nlet score = calculateScore()\nexpectNum(score).toBeGreaterThan(0)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeGreaterThan(10)\n// =&gt; Expected value to be greater than 10, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#begreaterthanorequal","title":"beGreaterThanOrEqual","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is greater than or equal to the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeGreaterThanOrEqual(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(10).toBeGreaterThanOrEqual(10)  // Equal case\nexpectNum(10).toBeGreaterThanOrEqual(5)   // Greater case\nexpectNum(5.0).toBeGreaterThanOrEqual(5.0)\n\n// Minimum validation\nlet age = user.Age\nexpectNum(age).toBeGreaterThanOrEqual(18)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeGreaterThanOrEqual(10)\n// =&gt; Expected value to be greater than or equal to 10, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#belessthan","title":"beLessThan","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is less than the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeLessThan(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBeLessThan(10)\nexpectNum(2.5).toBeLessThan(3.0)\nexpectNum(-10).toBeLessThan(0)\n\n// Maximum validation\nlet count = list.Length\nexpectNum(count).toBeLessThan(100)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(15).toBeLessThan(10)\n// =&gt; Expected value to be less than 10, but found 15\n</code></pre>"},{"location":"reference/matchers/numeric/#belessthanorequal","title":"beLessThanOrEqual","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is less than or equal to the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeLessThanOrEqual(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBeLessThanOrEqual(5)   // Equal case\nexpectNum(5).toBeLessThanOrEqual(10)  // Less case\nexpectNum(3.14).toBeLessThanOrEqual(4.0)\n\n// Maximum limit\nlet responseTime = measureResponseTime()\nexpectNum(responseTime).toBeLessThanOrEqual(1000)  // Max 1000ms\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(15).toBeLessThanOrEqual(10)\n// =&gt; Expected value to be less than or equal to 10, but found 15\n</code></pre>"},{"location":"reference/matchers/numeric/#ranges","title":"Ranges","text":""},{"location":"reference/matchers/numeric/#bebetween","title":"beBetween","text":"<p>Type: <code>'a -&gt; 'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is between min and max (inclusive).</p> <p>Parameters:</p> <ul> <li><code>min</code> - Minimum value (inclusive)</li> <li><code>max</code> - Maximum value (inclusive)</li> </ul> <p>Usage:</p> <pre><code>expectNum(actual).toBeBetween(min, max)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBeBetween(1, 10)    // Within range\nexpectNum(1).toBeBetween(1, 10)    // Minimum (inclusive)\nexpectNum(10).toBeBetween(1, 10)   // Maximum (inclusive)\n\n// Age validation\nlet age = user.Age\nexpectNum(age).toBeBetween(18, 65)\n\n// Percentage\nlet score = getScore()\nexpectNum(score).toBeBetween(0.0, 100.0)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(15).toBeBetween(1, 10)\n// =&gt; Expected value to be between 1 and 10, but found 15\n</code></pre> <p>Notes:</p> <ul> <li>Both bounds are inclusive</li> <li>Validates that <code>min &lt;= max</code> at creation time</li> <li>Works with any comparable type (int, float, DateTime, etc.)</li> </ul>"},{"location":"reference/matchers/numeric/#floating-point","title":"Floating Point","text":""},{"location":"reference/matchers/numeric/#becloseto","title":"beCloseTo","text":"<p>Type: <code>float -&gt; float -&gt; Matcher&lt;float&gt;</code></p> <p>Matches if the actual floating-point value is close to the expected value within a tolerance.</p> <p>Parameters:</p> <ul> <li><code>expected</code> - Expected value</li> <li><code>tolerance</code> - Maximum allowed difference</li> </ul> <p>Usage:</p> <pre><code>expectFloat(actual).toBeCloseTo(expected, tolerance)\n</code></pre> <p>Examples:</p> <pre><code>expectFloat(3.14159).toBeCloseTo(3.14, 0.01)     // Within tolerance\nexpectFloat(3.14159).toBeCloseTo(3.14159, 0.0)   // Exact match\n\n// Calculation precision\nlet result = Math.PI * 2.0\nexpectFloat(result).toBeCloseTo(6.283, 0.001)\n\n// Financial calculations\nlet total = calculateTotal()\nexpectFloat(total).toBeCloseTo(99.99, 0.01)\n</code></pre> <p>Failure Message:</p> <pre><code>expectFloat(3.5).toBeCloseTo(3.14, 0.1)\n// =&gt; Expected value to be close to 3.14 (\u00b10.1), but found 3.5 (diff: 0.36)\n</code></pre> <p>Notes:</p> <ul> <li>Tolerance must be non-negative</li> <li>Does not accept NaN or Infinity</li> <li>Use for comparing floating-point results where exact equality is unreliable</li> <li>Default to smallest reasonable tolerance</li> </ul>"},{"location":"reference/matchers/numeric/#sign-checks","title":"Sign Checks","text":""},{"location":"reference/matchers/numeric/#bepositive","title":"bePositive","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : comparison and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is positive (&gt; 0).</p> <p>Usage:</p> <pre><code>expectNum(actual).toBePositive()\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBePositive()\nexpectNum(0.1).toBePositive()\nexpectNum(100L).toBePositive()\n\n// After calculations\nlet profit = revenue - expenses\nexpectNum(profit).toBePositive()\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(-5).toBePositive()\n// =&gt; Expected positive value, but found -5\n\nexpectNum(0).toBePositive()\n// =&gt; Expected positive value, but found 0\n</code></pre> <p>Notes:</p> <ul> <li>Zero is not positive (use <code>beGreaterThanOrEqual 0</code> to include zero)</li> <li>Works with any numeric type that has a <code>Zero</code> member</li> </ul>"},{"location":"reference/matchers/numeric/#benegative","title":"beNegative","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : comparison and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is negative (&lt; 0).</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeNegative()\n</code></pre> <p>Examples:</p> <pre><code>expectNum(-5).toBeNegative()\nexpectNum(-0.1).toBeNegative()\nexpectNum(-100L).toBeNegative()\n\n// Testing debt\nlet balance = account.Balance\nif balance &lt; 0 then\n    expectNum(balance).toBeNegative()\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeNegative()\n// =&gt; Expected negative value, but found 5\n\nexpectNum(0).toBeNegative()\n// =&gt; Expected negative value, but found 0\n</code></pre>"},{"location":"reference/matchers/numeric/#bezero","title":"beZero","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : equality and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is zero.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeZero()\n</code></pre> <p>Examples:</p> <pre><code>expectNum(0).toBeZero()\nexpectNum(0.0).toBeZero()\nexpectNum(0L).toBeZero()\n\n// After operations\nlet remainder = 10 % 2\nexpectNum(remainder).toBeZero()\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeZero()\n// =&gt; Expected zero, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#integer-properties","title":"Integer Properties","text":""},{"location":"reference/matchers/numeric/#beeven","title":"beEven","text":"<p>Type: <code>Matcher&lt;int&gt;</code></p> <p>Matches if the actual integer is even.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should beEven\n</code></pre> <p>Examples:</p> <pre><code>expect 2 |&gt; should beEven\nexpect 0 |&gt; should beEven\nexpect -4 |&gt; should beEven\n\n// Testing parity\nlet count = list.Length\nif shouldBeEven(count) then\n    expect count |&gt; should beEven\n</code></pre> <p>Failure Message:</p> <pre><code>expect 3 |&gt; should beEven\n// =&gt; Expected even number, but found 3\n</code></pre>"},{"location":"reference/matchers/numeric/#beodd","title":"beOdd","text":"<p>Type: <code>Matcher&lt;int&gt;</code></p> <p>Matches if the actual integer is odd.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should beOdd\n</code></pre> <p>Examples:</p> <pre><code>expect 1 |&gt; should beOdd\nexpect 3 |&gt; should beOdd\nexpect -5 |&gt; should beOdd\n\n// Testing alternating pattern\nlet index = getCurrentIndex()\nif shouldBeOnOddIndex(index) then\n    expect index |&gt; should beOdd\n</code></pre> <p>Failure Message:</p> <pre><code>expect 4 |&gt; should beOdd\n// =&gt; Expected odd number, but found 4\n</code></pre>"},{"location":"reference/matchers/numeric/#bedivisibleby","title":"beDivisibleBy","text":"<p>Type: <code>int -&gt; Matcher&lt;int&gt;</code></p> <p>Matches if the actual value is divisible by the expected divisor.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should (beDivisibleBy divisor)\n</code></pre> <p>Examples:</p> <pre><code>expect 15 |&gt; should (beDivisibleBy 5)\nexpect 12 |&gt; should (beDivisibleBy 3)\nexpect 100 |&gt; should (beDivisibleBy 10)\n\n// Page size validation\nlet itemCount = items.Length\nexpect itemCount |&gt; should (beDivisibleBy pageSize)\n\n// Even numbers are divisible by 2\nexpect 8 |&gt; should (beDivisibleBy 2)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 7 |&gt; should (beDivisibleBy 3)\n// =&gt; Expected 7 to be divisible by 3, but it is not\n</code></pre> <p>Notes:</p> <ul> <li>Divisor cannot be zero (throws <code>ArgumentException</code>)</li> <li>Works with negative numbers</li> <li><code>beDivisibleBy 2</code> is equivalent to <code>beEven</code></li> </ul>"},{"location":"reference/matchers/numeric/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/numeric/#testing-a-math-library","title":"Testing a Math Library","text":"<pre><code>module MathLibrarySpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\nopen System\n\n[&lt;Tests&gt;]\nlet mathLibrarySpecs =\n    spec {\n        describe \"MathHelpers\" [\n            describe \"average\" [\n                it \"calculates average of numbers\" (fun () -&gt;\n                    let result = MathHelpers.average [1.0; 2.0; 3.0; 4.0; 5.0]\n                    expect result |&gt; should (equal 3.0)\n                    expectNum(result).toBeGreaterThan(0.0)\n                )\n\n                it \"handles floating-point precision\" (fun () -&gt;\n                    let result = MathHelpers.average [1.0/3.0; 2.0/3.0; 3.0/3.0]\n                    expectFloat(result).toBeCloseTo(0.666, 0.001)\n                )\n            ]\n\n            describe \"factorial\" [\n                it \"calculates factorial of positive number\" (fun () -&gt;\n                    let result = MathHelpers.factorial 5\n                    expect result |&gt; should (equal 120)\n                    expectNum(result).toBePositive()\n                )\n\n                it \"returns 1 for zero\" (fun () -&gt;\n                    let result = MathHelpers.factorial 0\n                    expect result |&gt; should (equal 1)\n                )\n            ]\n\n            describe \"isPrime\" [\n                it \"identifies prime numbers\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 2) |&gt; should beTrue\n                    expect (MathHelpers.isPrime 7) |&gt; should beTrue\n                    expect (MathHelpers.isPrime 13) |&gt; should beTrue\n                )\n\n                it \"rejects composite numbers\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 4) |&gt; should beFalse\n                    expect (MathHelpers.isPrime 9) |&gt; should beFalse\n                )\n\n                it \"rejects numbers less than 2\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 1) |&gt; should beFalse\n                    expect (MathHelpers.isPrime 0) |&gt; should beFalse\n                    expect (MathHelpers.isPrime -5) |&gt; should beFalse\n                )\n            ]\n\n            describe \"clamp\" [\n                it \"keeps value within range\" (fun () -&gt;\n                    let result = MathHelpers.clamp 5 1 10\n                    expect result |&gt; should (equal 5)\n                    expectNum(result).toBeBetween(1, 10)\n                )\n\n                it \"clamps to minimum\" (fun () -&gt;\n                    let result = MathHelpers.clamp -5 1 10\n                    expect result |&gt; should (equal 1)\n                    expectNum(result).toBeGreaterThanOrEqual(1)\n                )\n\n                it \"clamps to maximum\" (fun () -&gt;\n                    let result = MathHelpers.clamp 15 1 10\n                    expect result |&gt; should (equal 10)\n                    expectNum(result).toBeLessThanOrEqual(10)\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/numeric/#testing-financial-calculations","title":"Testing Financial Calculations","text":"<pre><code>module FinancialSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet financialSpecs =\n    spec {\n        describe \"Financial Calculations\" [\n            describe \"calculateInterest\" [\n                it \"calculates simple interest\" (fun () -&gt;\n                    let principal = 1000.0\n                    let rate = 0.05  // 5%\n                    let time = 2.0   // 2 years\n\n                    let interest = Financial.calculateSimpleInterest principal rate time\n                    expectFloat(interest).toBeCloseTo(100.0, 0.01)\n                    expectNum(interest).toBePositive()\n                )\n\n                it \"handles edge case of zero rate\" (fun () -&gt;\n                    let interest = Financial.calculateSimpleInterest 1000.0 0.0 2.0\n                    expectNum(interest).toBeZero()\n                )\n            ]\n\n            describe \"calculateTax\" [\n                it \"calculates tax for income bracket\" (fun () -&gt;\n                    let income = 50000.0\n                    let tax = Financial.calculateTax income\n\n                    expectNum(tax).toBePositive()\n                    expectNum(tax).toBeLessThan(income)\n                    expectFloat(tax).toBeCloseTo(7500.0, 100.0)  // Approximate\n                )\n\n                it \"returns zero tax for income below threshold\" (fun () -&gt;\n                    let income = 5000.0\n                    let tax = Financial.calculateTax income\n                    expectNum(tax).toBeZero()\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/numeric/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality matchers</li> <li>Collection Matchers - Collection matchers</li> <li>String Matchers - String matchers</li> <li>Quick Start - Get started with FxSpec</li> </ul>"},{"location":"reference/matchers/result/","title":"Result Matchers","text":"<p>FxSpec provides comprehensive matchers for testing F#'s <code>Result&lt;'T, 'E&gt;</code> type, which is the idiomatic way to handle errors in functional F# code.</p>"},{"location":"reference/matchers/result/#overview","title":"Overview","text":"<p>The <code>Result&lt;'T, 'E&gt;</code> type represents either success (<code>Ok 'T</code>) or failure (<code>Error 'E</code>). FxSpec's Result matchers allow you to assert on both the state and the value of Result types.</p> <pre><code>open FxSpec.Matchers\n\n// State-only matchers\nexpectResult(result).toBeOk()     // Just check it succeeded\nexpectResult(result).toBeError()  // Just check it failed\n\n// Value-specific matchers\nexpectResult(result).toBeOk(42)           // Check success with specific value\nexpectResult(result).toBeError(\"failed\")  // Check error with specific message\n</code></pre>"},{"location":"reference/matchers/result/#result-matchers_1","title":"Result Matchers","text":""},{"location":"reference/matchers/result/#expectresultresult","title":"expectResult(result)","text":"<p>Creates a Result expectation wrapper that provides Result-specific assertion methods.</p> <pre><code>let result: Result&lt;int, string&gt; = Ok 42\nexpectResult(result).toBeOk(42)\n</code></pre>"},{"location":"reference/matchers/result/#state-only-matchers","title":"State-Only Matchers","text":"<p>These matchers only check whether the Result is <code>Ok</code> or <code>Error</code>, without caring about the specific value.</p>"},{"location":"reference/matchers/result/#tobeok","title":"toBeOk()","text":"<p>Asserts that the Result is <code>Ok</code> with any value.</p> <p>Use Cases: - Checking operation success without caring about the specific return value - Validating that no errors occurred - Testing scenarios where the exact value is unpredictable</p> <pre><code>describe \"Authentication\" [\n    it \"successfully authenticates valid user\" (fun () -&gt;\n        let result = authenticate(validToken)\n        expectResult(result).toBeOk()  // Don't care about the specific user data\n    )\n\n    it \"grants access to authorized user\" (fun () -&gt;\n        let result = authorizeUser(userId, permission)\n        expectResult(result).toBeOk()  // Just check authorization succeeded\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#tobeerror","title":"toBeError()","text":"<p>Asserts that the Result is <code>Error</code> with any error value.</p> <p>Use Cases: - Checking that validation failed without specifying the exact error - Testing error handling paths - Verifying that security checks rejected invalid input</p> <pre><code>describe \"Validation\" [\n    it \"rejects invalid email format\" (fun () -&gt;\n        let result = validateEmail(\"not-an-email\")\n        expectResult(result).toBeError()  // Don't care about specific error message\n    )\n\n    it \"fails when database is unavailable\" (fun () -&gt;\n        let result = connectToDatabase(invalidConnectionString)\n        expectResult(result).toBeError()  // Just verify it failed\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#value-specific-matchers","title":"Value-Specific Matchers","text":"<p>These matchers check both the Result state and the specific value contained within.</p>"},{"location":"reference/matchers/result/#tobeokexpected-t","title":"toBeOk(expected: 'T)","text":"<p>Asserts that the Result is <code>Ok</code> with a specific value.</p> <pre><code>describe \"Calculator\" [\n    it \"adds numbers correctly\" (fun () -&gt;\n        let result = calculate \"2 + 2\"\n        expectResult(result).toBeOk(4)\n    )\n\n    it \"returns correct user data\" (fun () -&gt;\n        let result = findUser(123)\n        expectResult(result).toBeOk({ Id = 123; Name = \"John\" })\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#tobeerrorexpected-e","title":"toBeError(expected: 'E)","text":"<p>Asserts that the Result is <code>Error</code> with a specific error value.</p> <pre><code>describe \"Error Handling\" [\n    it \"returns specific validation error\" (fun () -&gt;\n        let result = validateAge(-5)\n        expectResult(result).toBeError(\"Age must be positive\")\n    )\n\n    type ValidationError = { Field: string; Message: string }\n\n    it \"returns structured error\" (fun () -&gt;\n        let result = validateUser(invalidUser)\n        expectResult(result).toBeError({ \n            Field = \"Email\"\n            Message = \"Invalid email format\" \n        })\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#common-patterns","title":"Common Patterns","text":""},{"location":"reference/matchers/result/#web-api-error-handling","title":"Web API Error Handling","text":"<p>Result types are commonly used in web APIs for handling validation, authentication, and business logic errors:</p> <pre><code>describe \"User Registration API\" [\n    it \"succeeds with valid data\" (fun () -&gt;\n        let result = registerUser(validUser)\n        expectResult(result).toBeOk()  // Just verify registration succeeded\n    )\n\n    it \"fails with duplicate email\" (fun () -&gt;\n        let result = registerUser(existingEmailUser)\n        expectResult(result).toBeError()  // Verify it fails\n    )\n\n    it \"returns specific validation error for missing fields\" (fun () -&gt;\n        let result = registerUser(incompleteUser)\n        expectResult(result).toBeError(\"Email is required\")\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#database-operations","title":"Database Operations","text":"<pre><code>type DbError = NotFound | ConnectionError | Timeout\n\ndescribe \"Database Repository\" [\n    it \"successfully retrieves existing record\" (fun () -&gt;\n        let result = repository.Get(validId)\n        expectResult(result).toBeOk()  // Don't need to verify entire record\n    )\n\n    it \"returns NotFound for missing record\" (fun () -&gt;\n        let result = repository.Get(missingId)\n        expectResult(result).toBeError(NotFound)\n    )\n\n    it \"handles connection errors\" (fun () -&gt;\n        disconnectDatabase()\n        let result = repository.Get(anyId)\n        expectResult(result).toBeError(ConnectionError)\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#authorization-and-security","title":"Authorization and Security","text":"<pre><code>type AuthError = Unauthorized | Forbidden | TokenExpired\n\ndescribe \"Authorization Service\" [\n    it \"grants access to authorized user\" (fun () -&gt;\n        let result = authorize(validToken, resource)\n        expectResult(result).toBeOk()  // Access granted\n    )\n\n    it \"denies access to unauthorized user\" (fun () -&gt;\n        let result = authorize(invalidToken, resource)\n        expectResult(result).toBeError()  // Access denied\n    )\n\n    it \"returns specific error for expired token\" (fun () -&gt;\n        let result = authorize(expiredToken, resource)\n        expectResult(result).toBeError(TokenExpired)\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#async-result-patterns","title":"Async Result Patterns","text":"<p>Result types work seamlessly with async workflows:</p> <pre><code>describe \"Async Operations\" [\n    itAsync \"fetches data successfully\" (async {\n        let! result = fetchDataAsync(validId)\n        expectResult(result).toBeOk()\n    })\n\n    itAsync \"handles async errors\" (async {\n        let! result = fetchDataAsync(invalidId)\n        expectResult(result).toBeError()\n    })\n\n    itAsync \"validates async operation result\" (async {\n        let! result = processPaymentAsync(payment)\n        expectResult(result).toBeOk({ \n            TransactionId = \"txn_123\"\n            Status = \"Completed\" \n        })\n    })\n]\n</code></pre>"},{"location":"reference/matchers/result/#railway-oriented-programming","title":"Railway-Oriented Programming","text":"<p>Result types enable railway-oriented programming (ROP) patterns:</p> <pre><code>describe \"Pipeline Processing\" [\n    it \"succeeds when all steps pass\" (fun () -&gt;\n        let result = \n            validateInput(data)\n            |&gt; Result.bind processData\n            |&gt; Result.bind saveToDatabase\n            |&gt; Result.map formatOutput\n\n        expectResult(result).toBeOk()\n    )\n\n    it \"fails at validation step\" (fun () -&gt;\n        let result = \n            validateInput(invalidData)\n            |&gt; Result.bind processData  // Won't execute\n            |&gt; Result.bind saveToDatabase  // Won't execute\n\n        expectResult(result).toBeError()\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#discriminated-union-errors","title":"Discriminated Union Errors","text":"<p>F# discriminated unions make excellent error types:</p> <pre><code>type ValidationError =\n    | EmptyField of field: string\n    | InvalidFormat of field: string * message: string\n    | OutOfRange of field: string * min: int * max: int\n\ndescribe \"Validation with DU Errors\" [\n    it \"detects empty required field\" (fun () -&gt;\n        let result = validateName(\"\")\n        expectResult(result).toBeError(EmptyField \"Name\")\n    )\n\n    it \"detects invalid email format\" (fun () -&gt;\n        let result = validateEmail(\"not-valid\")\n        expectResult(result).toBeError(\n            InvalidFormat(\"Email\", \"Must contain @\")\n        )\n    )\n\n    it \"detects out of range value\" (fun () -&gt;\n        let result = validateAge(150)\n        expectResult(result).toBeError(\n            OutOfRange(\"Age\", 0, 120)\n        )\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#error-messages","title":"Error Messages","text":"<p>FxSpec provides clear error messages for Result assertions:</p>"},{"location":"reference/matchers/result/#tobeok-failure","title":"toBeOk() Failure","text":"<pre><code>Expected Ok, but found Error \"something went wrong\"\nExpected: Ok\nActual: Error \"something went wrong\"\n</code></pre>"},{"location":"reference/matchers/result/#tobeokvalue-failure","title":"toBeOk(value) Failure","text":"<pre><code>Expected Ok 42, but found Ok 100\nExpected: 42\nActual: 100\n</code></pre>"},{"location":"reference/matchers/result/#tobeerror-failure","title":"toBeError() Failure","text":"<pre><code>Expected Error, but found Ok 42\nExpected: Error\nActual: Ok 42\n</code></pre>"},{"location":"reference/matchers/result/#tobeerrorvalue-failure","title":"toBeError(value) Failure","text":"<pre><code>Expected Error \"Unauthorized\", but found Error \"Forbidden\"\nExpected: \"Unauthorized\"\nActual: \"Forbidden\"\n</code></pre>"},{"location":"reference/matchers/result/#best-practices","title":"Best Practices","text":""},{"location":"reference/matchers/result/#1-use-state-only-matchers-when-appropriate","title":"1. Use State-Only Matchers When Appropriate","text":"<p>When you don't need to verify the specific value, use state-only matchers:</p> <pre><code>// Good - just checking success\nexpectResult(result).toBeOk()\n\n// Unnecessary - don't care about the specific value\nexpectResult(result).toBeOk(someValue)  // If you don't need to verify value\n</code></pre>"},{"location":"reference/matchers/result/#2-use-value-specific-matchers-for-critical-values","title":"2. Use Value-Specific Matchers for Critical Values","text":"<p>When the exact value matters, verify it:</p> <pre><code>// Good - verifying specific error\nexpectResult(result).toBeError(NotFound)\n\n// Risky - might miss wrong error type\nexpectResult(result).toBeError()\n</code></pre>"},{"location":"reference/matchers/result/#3-combine-with-other-matchers","title":"3. Combine with Other Matchers","text":"<p>Result matchers work well with other FxSpec features:</p> <pre><code>describe \"Complex Validation\" [\n    it \"validates and processes data\" (fun () -&gt;\n        let result = validateAndProcess(data)\n\n        // First check it succeeded\n        expectResult(result).toBeOk()\n\n        // Then verify the result value\n        match result with\n        | Ok value -&gt; expectNum(value.Score).toBeGreaterThan(0)\n        | Error _ -&gt; failwith \"Unexpected error\"\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#4-test-both-success-and-failure-paths","title":"4. Test Both Success and Failure Paths","text":"<p>Always test both happy path and error scenarios:</p> <pre><code>describe \"User Service\" [\n    context \"with valid input\" [\n        it \"creates user successfully\" (fun () -&gt;\n            let result = createUser(validData)\n            expectResult(result).toBeOk()\n        )\n    ]\n\n    context \"with invalid input\" [\n        it \"rejects empty name\" (fun () -&gt;\n            let result = createUser({ validData with Name = \"\" })\n            expectResult(result).toBeError()\n        )\n\n        it \"rejects invalid email\" (fun () -&gt;\n            let result = createUser({ validData with Email = \"invalid\" })\n            expectResult(result).toBeError()\n        )\n    ]\n]\n</code></pre>"},{"location":"reference/matchers/result/#type-signatures","title":"Type Signatures","text":"<pre><code>// Create Result expectation\nexpectResult : Result&lt;'T, 'E&gt; -&gt; ResultExpectation&lt;'T, 'E&gt;\n    when 'T : equality and 'E : equality\n\n// State-only matchers\ntoBeOk : unit -&gt; unit\ntoBeError : unit -&gt; unit\n\n// Value-specific matchers\ntoBeOk : expected:'T -&gt; unit\ntoBeError : expected:'E -&gt; unit\n</code></pre>"},{"location":"reference/matchers/result/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core Matchers - Basic equality and type matchers</li> <li>Async Support - Using <code>itAsync</code> with Result types</li> <li>HTTP Testing - HTTP responses often use Result patterns</li> <li>Quick Start - Getting started with FxSpec</li> </ul>"},{"location":"reference/matchers/result/#see-also","title":"See Also","text":"<ul> <li>Railway Oriented Programming - Scott Wlaschin's ROP pattern</li> <li>F# Result Type - Official F# documentation</li> </ul>"},{"location":"reference/matchers/strings/","title":"String Matchers","text":"<p>String-specific matchers for prefixes, suffixes, patterns, and more.</p>"},{"location":"reference/matchers/strings/#prefixes-suffixes","title":"Prefixes &amp; Suffixes","text":""},{"location":"reference/matchers/strings/#startwith","title":"startWith","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string starts with the expected prefix.</p> <p>Usage:</p> <pre><code>expectStr(string).toStartWith(prefix)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello world\").toStartWith(\"hello\")\nexpectStr(\"FxSpec\").toStartWith(\"Fx\")\nexpectStr(\"https://example.com\").toStartWith(\"https://\")\n\n// Case-sensitive\nexpectStr(\"Hello\").notToStartWith(\"hello\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello world\").toStartWith(\"goodbye\")\n// =&gt; Expected string to start with 'goodbye', but found 'hello world'\n</code></pre> <p>Notes:</p> <ul> <li>Case-sensitive by default</li> <li>Returns error for null strings</li> <li>For case-insensitive matching, use custom logic or convert to lowercase first</li> </ul>"},{"location":"reference/matchers/strings/#endwith","title":"endWith","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string ends with the expected suffix.</p> <p>Usage:</p> <pre><code>expectStr(string).toEndWith(suffix)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello world\").toEndWith(\"world\")\nexpectStr(\"test.txt\").toEndWith(\".txt\")\nexpectStr(\"FxSpec\").toEndWith(\"Spec\")\n\n// File extensions\nlet filename = \"document.pdf\"\nexpectStr(filename).toEndWith(\".pdf\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello world\").toEndWith(\".txt\")\n// =&gt; Expected string to end with '.txt', but found 'hello world'\n</code></pre>"},{"location":"reference/matchers/strings/#substrings","title":"Substrings","text":""},{"location":"reference/matchers/strings/#containsubstring","title":"containSubstring","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string contains the expected substring.</p> <p>Usage:</p> <pre><code>expectStr(string).toContainSubstring(substring)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello world\").toContainSubstring(\"lo wo\")\nexpectStr(\"FxSpec is great\").toContainSubstring(\"Spec\")\nexpectStr(\"error: file not found\").toContainSubstring(\"error:\")\n\n// Search in logs\nlet logMessage = \"2025-01-01 10:00:00 INFO User logged in\"\nexpectStr(logMessage).toContainSubstring(\"INFO\")\nexpectStr(logMessage).toContainSubstring(\"logged in\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello world\").toContainSubstring(\"goodbye\")\n// =&gt; Expected string to contain 'goodbye', but found 'hello world'\n</code></pre>"},{"location":"reference/matchers/strings/#patterns","title":"Patterns","text":""},{"location":"reference/matchers/strings/#matchregex","title":"matchRegex","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string matches the regular expression pattern.</p> <p>Usage:</p> <pre><code>expectStr(string).toMatchRegex(pattern)\n</code></pre> <p>Examples:</p> <pre><code>// Email validation\nexpectStr(\"test@example.com\").toMatchRegex(@\"^\\w+@\\w+\\.\\w+$\")\n\n// Phone numbers\nexpectStr(\"555-1234\").toMatchRegex(@\"^\\d{3}-\\d{4}$\")\n\n// Dates\nexpectStr(\"2025-01-01\").toMatchRegex(@\"^\\d{4}-\\d{2}-\\d{2}$\")\n\n// Contains digits\nexpectStr(\"hello123\").toMatchRegex(@\"\\d+\")\n\n// Starts with uppercase\nexpectStr(\"Hello\").toMatchRegex(@\"^[A-Z]\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello\").toMatchRegex(@\"^\\d+$\")\n// =&gt; Expected string to match pattern '^\\d+$', but found 'hello'\n</code></pre> <p>Notes:</p> <ul> <li>Uses .NET <code>Regex.IsMatch</code></li> <li>Patterns are case-sensitive by default</li> <li>Use <code>(?i)</code> flag for case-insensitive matching: <code>matchRegex @\"(?i)hello\"</code></li> </ul>"},{"location":"reference/matchers/strings/#empty-checks","title":"Empty Checks","text":""},{"location":"reference/matchers/strings/#beemptystring","title":"beEmptyString","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is empty (<code>\"\"</code>).</p> <p>Usage:</p> <pre><code>expectStr(string).toBeEmpty()\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"\").toBeEmpty()\nexpectStr(String.Empty).toBeEmpty()\n\n// After operations\nlet trimmed = \"   \".Trim()\nexpectStr(trimmed).toBeEmpty()\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello\").toBeEmpty()\n// =&gt; Expected empty string, but found 'hello'\n\nexpectStr(null).toBeEmpty()\n// =&gt; Expected empty string, but found null\n</code></pre>"},{"location":"reference/matchers/strings/#benullorempty","title":"beNullOrEmpty","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is null or empty.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beNullOrEmpty\n</code></pre> <p>Examples:</p> <pre><code>expect null |&gt; should beNullOrEmpty\nexpect \"\" |&gt; should beNullOrEmpty\nexpect String.Empty |&gt; should beNullOrEmpty\n\n// Validation\nlet userInput = getUserInput()\nif String.IsNullOrEmpty(userInput) then\n    expect userInput |&gt; should beNullOrEmpty\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; should beNullOrEmpty\n// =&gt; Expected null or empty string, but found 'hello'\n</code></pre>"},{"location":"reference/matchers/strings/#benullorwhitespace","title":"beNullOrWhitespace","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is null, empty, or contains only whitespace.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beNullOrWhitespace\n</code></pre> <p>Examples:</p> <pre><code>expect null |&gt; should beNullOrWhitespace\nexpect \"\" |&gt; should beNullOrWhitespace\nexpect \"   \" |&gt; should beNullOrWhitespace\nexpect \"\\t\\n\" |&gt; should beNullOrWhitespace\n\n// User input validation\nlet comment = getCommentText()\nif String.IsNullOrWhiteSpace(comment) then\n    expect comment |&gt; should beNullOrWhitespace\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; should beNullOrWhitespace\n// =&gt; Expected null, empty, or whitespace string, but found 'hello'\n</code></pre>"},{"location":"reference/matchers/strings/#length","title":"Length","text":""},{"location":"reference/matchers/strings/#havestringlength","title":"haveStringLength","text":"<p>Type: <code>int -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string has the expected length.</p> <p>Usage:</p> <pre><code>expectStr(string).toHaveLength(length)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello\").toHaveLength(5)\nexpectStr(\"\").toHaveLength(0)\nexpectStr(\"FxSpec\").toHaveLength(6)\n\n// Password validation\nlet password = \"secret123\"\nexpectStr(password).toHaveLength(9)\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello\").toHaveLength(10)\n// =&gt; Expected string of length 10, but found length 5 ('hello')\n\nexpectStr(null).toHaveLength(5)\n// =&gt; Expected string of length 5, but found null\n</code></pre>"},{"location":"reference/matchers/strings/#case-insensitive","title":"Case Insensitive","text":""},{"location":"reference/matchers/strings/#equalignorecase","title":"equalIgnoreCase","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string equals the expected value (case-insensitive).</p> <p>Usage:</p> <pre><code>expect string |&gt; should (equalIgnoreCase expected)\n</code></pre> <p>Examples:</p> <pre><code>expect \"HELLO\" |&gt; should (equalIgnoreCase \"hello\")\nexpect \"FxSpec\" |&gt; should (equalIgnoreCase \"fxspec\")\nexpect \"TeSt\" |&gt; should (equalIgnoreCase \"test\")\n\n// Configuration keys\nlet configKey = \"DatabaseConnectionString\"\nexpect configKey |&gt; should (equalIgnoreCase \"databaseconnectionstring\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"HELLO\" |&gt; should (equalIgnoreCase \"goodbye\")\n// =&gt; Expected 'goodbye' (case-insensitive), but found 'HELLO'\n</code></pre> <p>Notes:</p> <ul> <li>Uses <code>StringComparison.OrdinalIgnoreCase</code></li> <li>Handles null correctly</li> <li>For exact case match, use <code>equal</code> from core matchers</li> </ul>"},{"location":"reference/matchers/strings/#character-types","title":"Character Types","text":""},{"location":"reference/matchers/strings/#bealphabetic","title":"beAlphabetic","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string contains only letters.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beAlphabetic\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello\" |&gt; should beAlphabetic\nexpect \"FxSpec\" |&gt; should beAlphabetic\nexpect \"ABC\" |&gt; should beAlphabetic\n\n// Fails\nexpect \"hello123\" |&gt; shouldNot beAlphabetic  // Contains digits\nexpect \"hello world\" |&gt; shouldNot beAlphabetic  // Contains space\nexpect \"\" |&gt; shouldNot beAlphabetic  // Empty string\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello123\" |&gt; should beAlphabetic\n// =&gt; Expected alphabetic string, but found 'hello123'\n\nexpect \"\" |&gt; should beAlphabetic\n// =&gt; Expected alphabetic string, but found empty string\n</code></pre>"},{"location":"reference/matchers/strings/#benumeric","title":"beNumeric","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string contains only digits.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beNumeric\n</code></pre> <p>Examples:</p> <pre><code>expect \"12345\" |&gt; should beNumeric\nexpect \"0\" |&gt; should beNumeric\nexpect \"999\" |&gt; should beNumeric\n\n// Fails\nexpect \"123.45\" |&gt; shouldNot beNumeric  // Contains decimal point\nexpect \"12 34\" |&gt; shouldNot beNumeric  // Contains space\nexpect \"\" |&gt; shouldNot beNumeric  // Empty string\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"12.34\" |&gt; should beNumeric\n// =&gt; Expected numeric string, but found '12.34'\n</code></pre> <p>Notes:</p> <ul> <li>Only accepts digits 0-9</li> <li>Does not accept decimal points, minus signs, or spaces</li> <li>For parsing numbers, use <code>Int32.TryParse</code> or similar</li> </ul>"},{"location":"reference/matchers/strings/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/strings/#testing-url-validation","title":"Testing URL Validation","text":"<pre><code>module UrlValidationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet urlValidationSpecs =\n    spec {\n        describe \"URL Validator\" [\n            describe \"validateUrl\" [\n                context \"when URL is valid\" [\n                    it \"accepts https URLs\" (fun () -&gt;\n                        let url = \"https://example.com\"\n                        expectStr(url).toStartWith(\"https://\")\n                        expectStr(url).toMatchRegex(@\"^https?://[\\w\\-]+(\\.[\\w\\-]+)+[/#?]?.*$\")\n                    )\n\n                    it \"accepts http URLs\" (fun () -&gt;\n                        let url = \"http://example.com/path?query=value\"\n                        expectStr(url).toStartWith(\"http://\")\n                        expectStr(url).toContainSubstring(\"example.com\")\n                    )\n\n                    it \"accepts URLs with paths\" (fun () -&gt;\n                        let url = \"https://example.com/api/users\"\n                        expectStr(url).toContainSubstring(\"/api/users\")\n                        expectStr(url).toEndWith(\"/users\")\n                    )\n                ]\n\n                context \"when URL is invalid\" [\n                    it \"rejects empty strings\" (fun () -&gt;\n                        expectStr(\"\").toBeEmpty()\n                        expectStr(\"\").notToStartWith(\"http\")\n                    )\n\n                    it \"rejects non-URL strings\" (fun () -&gt;\n                        expectStr(\"not a url\").notToMatchRegex(@\"^https?://\")\n                    )\n                ]\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/strings/#testing-string-transformations","title":"Testing String Transformations","text":"<pre><code>module StringTransformationSpecs\n\nopen FxSpec.Core\nopen FxSpec.Matchers\n\n[&lt;Tests&gt;]\nlet stringTransformationSpecs =\n    spec {\n        describe \"StringHelpers\" [\n            describe \"slugify\" [\n                it \"converts to lowercase\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"Hello World\"\n                    expect result |&gt; should (equalIgnoreCase \"hello-world\")\n                    expect result |&gt; should (equal \"hello-world\")\n                )\n\n                it \"replaces spaces with hyphens\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"My Blog Post\"\n                    expect result |&gt; should (equal \"my-blog-post\")\n                    expectStr(result).notToContainSubstring(\" \")\n                )\n\n                it \"removes special characters\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"Hello, World!\"\n                    expect result |&gt; should (equal \"hello-world\")\n                    expect result |&gt; should beAlphabetic  // False, contains hyphen\n                    expectStr(result).toMatchRegex(@\"^[a-z\\-]+$\")\n                )\n            ]\n\n            describe \"sanitize\" [\n                it \"trims whitespace\" (fun () -&gt;\n                    let result = StringHelpers.sanitize \"  hello  \"\n                    expect result |&gt; should (equal \"hello\")\n                    expectStr(result).notToStartWith(\" \")\n                    expectStr(result).notToEndWith(\" \")\n                )\n\n                it \"returns empty string for whitespace-only input\" (fun () -&gt;\n                    let result = StringHelpers.sanitize \"   \"\n                    expectStr(result).toBeEmpty()\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/strings/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality matchers</li> <li>Collection Matchers - Collection matchers (strings are sequences of chars)</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Quick Start - Get started with FxSpec</li> </ul>"}]}