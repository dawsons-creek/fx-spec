{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FX.Spec","text":"<ul> <li> <p> Write Specifications That Test and Document Your F# Code</p> <p>A type-safe BDD framework that creates executable documentation with exceptional debugging support.</p> <p>Tests that describe behavior, compile-time safety, and filtered stack traces that accelerate development.</p> </li> </ul> <p>Get Started in 5 Minutes View on GitHub</p>"},{"location":"#why-fxspec","title":"Why FX.Spec?","text":"<ul> <li> <p> Specifications as Documentation</p> <p>Tests describe expected behavior in plain language, creating living documentation that stays synchronized with your code.</p> <p>When behavior changes, your documentation updates automatically.</p> </li> <li> <p> Type-Safe Expectations</p> <p>Leverage F#'s type system with context-aware matchers and IntelliSense support.</p> <p>Type-specific expectations prevent runtime errors and guide you to the right assertions.</p> </li> <li> <p> Exceptional Debugging</p> <p>Filtered stack traces show only YOUR code, not framework internals. Clickable file links jump directly to errors.</p> <p>Hierarchical output preserves test context, pinpointing issues instantly.</p> </li> <li> <p> Pure Functional Design</p> <p>Immutable test trees, composable structures, no hidden state. Pure F# with clean, functional syntax.</p> <p>Built by F# developers, for F# developers.</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Write tests that read like specifications:</p> <pre><code>module UserAccountSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet userAccountSpecs =\n    describe \"User account lifecycle\" [\n        context \"during registration\" [\n            it \"requires a valid email address\" (fun () -&gt;\n                let result = User.register \"invalid-email\"\n                expectResult(result).toBeError(\"Invalid email format\")\n            )\n\n            it \"prevents duplicate email registration\" (fun () -&gt;\n                let existing = \"user@example.com\"\n                Database.seed(existing)\n                let result = User.register existing\n                expectResult(result).toBeError(\"Email already registered\")\n            )\n        ]\n\n        context \"after successful registration\" [\n            it \"creates an inactive account requiring email verification\" (fun () -&gt;\n                let user = User.register \"new@example.com\" |&gt; Result.get\n                expectBool(user.IsActive).toBeFalse()\n                expectOption(user.VerificationToken).toBeSome()\n            )\n        ]\n    ]\n</code></pre> <p>Output: <pre><code>User account lifecycle\n  during registration\n    \u2713 requires a valid email address\n    \u2713 prevents duplicate email registration\n  after successful registration\n    \u2713 creates an inactive account requiring email verification\n\n3 examples, 0 failures\n</code></pre></p>"},{"location":"#writing-specifications","title":"Writing Specifications","text":""},{"location":"#hierarchical-organization","title":"Hierarchical Organization","text":"<p>Structure tests to mirror your system's behavior and requirements:</p> <pre><code>describe \"Payment Processing\" [\n    context \"when payment method is credit card\" [\n        context \"with sufficient funds\" [\n            it \"processes payment successfully\" (fun () -&gt; ...)\n            it \"sends confirmation email to customer\" (fun () -&gt; ...)\n        ]\n\n        context \"with insufficient funds\" [\n            it \"declines the transaction\" (fun () -&gt; ...)\n            it \"notifies customer of declined payment\" (fun () -&gt; ...)\n        ]\n    ]\n]\n</code></pre> <p>The hierarchical structure creates documentation that stakeholders can read and understand.</p>"},{"location":"#natural-language-descriptions","title":"Natural Language Descriptions","text":"<p>Tests describe what the system should do, not how it does it:</p> <pre><code>it \"preserves user data during session timeout\" (fun () -&gt; ...)\nit \"encrypts sensitive information before storage\" (fun () -&gt; ...)\nit \"validates input against business rules\" (fun () -&gt; ...)\n</code></pre>"},{"location":"#ensuring-correctness","title":"Ensuring Correctness","text":""},{"location":"#type-specific-matchers","title":"Type-Specific Matchers","text":"<p>FX.Spec provides specialized matchers that prevent runtime errors:</p> <pre><code>// IntelliSense shows only applicable methods\nexpectNum(42).toBeGreaterThan(0)      // Works with any numeric type\nexpectFloat(3.14).toBeCloseTo(3.1, 0.1)  // Float-specific precision\nexpectStr(\"hello\").toStartWith(\"h\")    // String-specific operations\nexpectSeq([1; 2]).toContain(1)        // Collection-specific checks\nexpectOption(result).toBeSome(42)     // Option-specific assertions\nexpectResult(result).toBeOk()         // Result type handling\n</code></pre> <p>Compile-time validation ensures you can't use the wrong matcher for your data type.</p>"},{"location":"#comprehensive-assertion-library","title":"Comprehensive Assertion Library","text":"<p>50+ assertion methods covering all common scenarios:</p> <ul> <li>Core: <code>toEqual</code>, <code>notToEqual</code></li> <li>Collections: <code>toContain</code>, <code>toBeEmpty</code>, <code>toHaveLength</code>, <code>toContainAll</code></li> <li>Numeric: <code>toBeGreaterThan</code>, <code>toBeLessThan</code>, <code>toBeCloseTo</code>, <code>toBePositive</code>, <code>toBeNegative</code></li> <li>Strings: <code>toStartWith</code>, <code>toEndWith</code>, <code>toMatchRegex</code>, <code>toHaveLength</code></li> <li>Exceptions: <code>expectThrows&lt;T&gt;</code>, <code>expectThrowsWithMessage&lt;T&gt;</code>, <code>expectNotToThrow</code></li> <li>HTTP: <code>toHaveStatus</code>, <code>toHaveStatusOk</code>, <code>toHaveHeader</code>, <code>toHaveJsonBody</code></li> </ul>"},{"location":"#debugging-failures","title":"Debugging Failures","text":""},{"location":"#filtered-stack-traces","title":"Filtered Stack Traces","text":"<p>When errors occur, FX.Spec shows only the relevant parts of your code:</p> <pre><code>\u2717 processes user data\n\n  Calculator &gt; processes user data\n\n  DivideByZeroException: Attempted to divide by zero.\n\n  Stack trace:\n    at Calculator.divide(Int32 x, Int32 y)\n       in Calculator.fs:42 (Calculator)\n    at Calculator.processUserData(User user)\n       in Calculator.fs:67 (Calculator)\n</code></pre> <p>What's filtered out: - Framework internals (FX.Spec.Core, FX.Spec.Runner) - .NET runtime frames (System.Reflection, System.Runtime) - F# compiler-generated noise</p> <p>What you see: - Clear exception type and message - Only YOUR code in the stack trace - Precise line numbers - Project names for context</p>"},{"location":"#clickable-file-links","title":"Clickable File Links","text":"<p>Cmd/Ctrl+Click on file paths to jump directly to the error location in VS Code. No hunting through source files.</p>"},{"location":"#hierarchical-context","title":"Hierarchical Context","text":"<p>Test output preserves the full path to failures:</p> <pre><code>User account lifecycle\n  during registration\n    \u2717 requires a valid email address\n\n      User account lifecycle &gt; during registration &gt; requires a valid email address\n\n      Expected: Error \"Invalid email format\"\n      Actual:   Ok User { Email = \"invalid-email\"; ... }\n</code></pre> <p>The full test path helps you understand exactly which scenario failed.</p>"},{"location":"#diff-visualization","title":"Diff Visualization","text":"<p>See exactly what's different when assertions fail:</p> <pre><code>Expected vs Actual:\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Expected: { Name = \"Alice\"; Age = 30 }      \u2502\n\u2502 Actual:   { Name = \"Alice\"; Age = 31 }      \u2502\n\u2502                                      ^^      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"#managing-test-execution","title":"Managing Test Execution","text":""},{"location":"#focus-on-specific-tests","title":"Focus on Specific Tests","text":"<p>During development, run only the tests you're working on:</p> <pre><code>describe \"Feature\" [\n    fit \"work on this test\" (fun () -&gt;  // Only this runs\n        expect(2 + 2).toEqual(4)\n    )\n\n    it \"this test is skipped\" (fun () -&gt;\n        expectBool(true).toBeTrue()\n    )\n]\n</code></pre> <p>Use <code>fit</code> for individual tests or <code>fdescribe</code> for entire groups.</p>"},{"location":"#mark-pending-work","title":"Mark Pending Work","text":"<p>Track incomplete tests without breaking your build:</p> <pre><code>describe \"Feature\" [\n    it \"completed test\" (fun () -&gt;\n        expectBool(true).toBeTrue()\n    )\n\n    xit \"not ready yet\" (fun () -&gt;\n        // This doesn't run\n    )\n\n    pending \"TODO: implement validation test\" (fun () -&gt;\n        ()\n    )\n]\n</code></pre> <p>Pending tests appear in the summary so you don't forget them.</p>"},{"location":"#setup-and-teardown","title":"Setup and Teardown","text":"<p>Manage test lifecycle with hooks:</p> <pre><code>describe \"Database operations\" [\n    let mutable connection = null\n\n    beforeEach (fun () -&gt;\n        connection &lt;- Database.connect()\n        connection.BeginTransaction()\n    )\n\n    afterEach (fun () -&gt;\n        connection.RollbackTransaction()\n        connection.Dispose()\n    )\n\n    it \"saves user data\" (fun () -&gt;\n        let result = connection.Save(newUser)\n        expectResult(result).toBeOk()\n    )\n]\n</code></pre> <p>Hooks ensure test isolation and proper resource cleanup.</p>"},{"location":"#technical-architecture","title":"Technical Architecture","text":"<p>FX.Spec builds an immutable test tree at compile time, separating test declaration from execution. This functional approach enables:</p> <ul> <li>Test filtering - Run specific tests without re-compiling</li> <li>Multiple output formats - Same tests, different presentations</li> <li>Guaranteed test isolation - Tests can't affect each other</li> <li>Composable test structures - Build tests from smaller pieces</li> </ul> <p>The fluent API uses F#'s type system to provide context-aware methods. IntelliSense shows only assertions that make sense for your data type, preventing mismatches at compile time.</p> <pre><code>// Type system prevents misuse\nexpectNum(42).toBeGreaterThan(0)      // \u2713 Valid\nexpectNum(42).toStartWith(\"4\")        // \u2717 Compile error - no such method\n\nexpectStr(\"hello\").toStartWith(\"h\")   // \u2713 Valid\nexpectStr(\"hello\").toBeGreaterThan(5) // \u2717 Compile error - no such method\n</code></pre>"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":""},{"location":"#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Hierarchical test organization with <code>describe</code>/<code>context</code>/<code>it</code></li> <li>50+ type-specific assertion methods</li> <li>Async/await support with <code>itAsync</code></li> <li>HTTP testing matchers for web APIs</li> <li>Lifecycle hooks (<code>beforeEach</code>, <code>afterEach</code>, <code>beforeAll</code>, <code>afterAll</code>)</li> <li>Focus and pending tests (<code>fit</code>, <code>xit</code>, <code>pending</code>)</li> </ul>"},{"location":"#developer-experience","title":"Developer Experience","text":"<ul> <li>Filtered stack traces showing only your code</li> <li>Clickable file links (Cmd/Ctrl+Click to jump to errors)</li> <li>Colored, hierarchical console output</li> <li>Diff visualization for mismatched values</li> <li>IntelliSense support for type-specific matchers</li> <li>Self-hosting (FX.Spec tests itself with 71+ passing tests)</li> </ul>"},{"location":"#pure-f-design","title":"Pure F# Design","text":"<ul> <li>No dependencies on xUnit, NUnit, or MSTest</li> <li>Immutable test trees with functional composition</li> <li>Pure functions throughout</li> <li>Custom test discovery and execution</li> <li>Independent CLI runner</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p> Quick Start</p> <p>Get your first test running in 5 minutes.</p> </li> <li> <p> DSL Reference</p> <p>Learn about <code>describe</code>, <code>it</code>, and all DSL functions.</p> </li> <li> <p> Matchers</p> <p>Explore the complete matcher library.</p> </li> <li> <p> Contributing</p> <p>Join the community and contribute to FX.Spec.</p> </li> </ul>"},{"location":"#for-developers-familiar-with-other-frameworks","title":"For Developers Familiar with Other Frameworks","text":"<p>If you've used BDD frameworks before, you'll recognize the describe/it syntax. FX.Spec adapts these patterns to F#'s functional paradigm:</p> <p>Key differences from other BDD frameworks:</p> <ul> <li>F# uses lists <code>[]</code> instead of blocks <code>{}</code></li> <li>Tests are wrapped in <code>fun () -&gt;</code> for lazy evaluation</li> <li>Type-specific expectations: <code>expectSeq</code>, <code>expectStr</code>, <code>expectNum</code>, etc.</li> <li>Fluent API with method chaining: <code>expect(x).toEqual(y)</code></li> <li>Immutable test trees enable powerful filtering and composition</li> </ul> <p>Example:</p> <pre><code>describe \"Calculator\" [\n    it \"adds numbers\" (fun () -&gt;\n        expect(2 + 2).toEqual(4)\n    )\n]\n</code></pre> <p>The syntax is straightforward and leverages F#'s strengths: type safety, immutability, and functional composition.</p>"},{"location":"#whats-next","title":"What's Next?","text":"<p>Ready to dive in?</p> <ol> <li>Quick Start - Install FX.Spec and write your first test</li> <li>DSL API - Learn all the DSL functions</li> <li>Matchers - Explore the matcher library</li> <li>HTTP Testing - Test web APIs with fluent matchers</li> </ol> <p>Questions or feedback? Open an issue on GitHub</p>"},{"location":"#inspired-by","title":"Inspired By","text":"<p>FX.Spec draws inspiration from the best in class:</p> <ul> <li>RSpec - The gold standard for BDD testing in Ruby</li> <li>Expecto - F# testing framework philosophy</li> <li>Spectre.Console - Beautiful console output</li> <li>F# for Fun and Profit - Functional programming insights</li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Get your first FX.Spec specification running in 5 minutes and start documenting your code's behavior.</p>"},{"location":"quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8.0 or .NET 9.0 SDK</li> <li>F# 8.0+ (included with .NET SDK)</li> <li>Basic F# knowledge</li> </ul>"},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#step-1-create-a-test-project","title":"Step 1: Create a Test Project","text":"<p>Create a new F# console project for your tests:</p> <pre><code>dotnet new console -lang F# -n MyProject.Tests\ncd MyProject.Tests\n</code></pre>"},{"location":"quick-start/#step-2-add-fxspec-packages","title":"Step 2: Add FX.Spec Packages","text":"<p>Add the FX.Spec packages to your project:</p> <pre><code>dotnet add package FX.Spec.Core\ndotnet add package FX.Spec.Matchers\ndotnet add package FX.Spec.Runner\n</code></pre> <p>Package Status</p> <p>FX.Spec packages are not yet published to NuGet. For now, you'll need to build from source or reference the local projects.</p>"},{"location":"quick-start/#your-first-specification","title":"Your First Specification","text":""},{"location":"quick-start/#step-1-create-a-specification-file","title":"Step 1: Create a Specification File","text":"<p>Create a new file called <code>CalculatorSpecs.fs</code> in your test project. Note how the tests read like documentation:</p> <pre><code>module CalculatorSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet calculatorSpecs =\n    describe \"Calculator arithmetic operations\" [\n        context \"when adding numbers\" [\n            it \"returns the sum of two positive integers\" (fun () -&gt;\n                let result = 2 + 3\n                expect(result).toEqual(5)\n            )\n\n            it \"handles negative numbers correctly\" (fun () -&gt;\n                let result = -5 + 3\n                expect(result).toEqual(-2)\n            )\n        ]\n\n        context \"when dividing numbers\" [\n            it \"raises an exception when dividing by zero\" (fun () -&gt;\n                expectThrows&lt;System.DivideByZeroException&gt;(fun () -&gt;\n                    let _ = 10 / 0\n                    ()\n                )\n            )\n        ]\n    ]\n</code></pre>"},{"location":"quick-start/#step-2-update-your-fsproj","title":"Step 2: Update Your .fsproj","text":"<p>Make sure your specification file is included in the project:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;Compile Include=\"CalculatorSpecs.fs\" /&gt;\n  &lt;Compile Include=\"Program.fs\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"quick-start/#step-3-update-programfs","title":"Step 3: Update Program.fs","text":"<p>Replace the contents of <code>Program.fs</code> with:</p> <pre><code>[&lt;EntryPoint&gt;]\nlet main args =\n    // FX.Spec will automatically discover tests\n    0\n</code></pre>"},{"location":"quick-start/#step-4-run-your-tests","title":"Step 4: Run Your Tests","text":"<p>Run the tests using the FX.Spec runner:</p> <pre><code>dotnet build\ndotnet run\n</code></pre> <p>You should see beautiful, hierarchical output that documents your calculator's behavior:</p> <pre><code>Calculator arithmetic operations\n  when adding numbers\n    \u2713 returns the sum of two positive integers (2ms)\n    \u2713 handles negative numbers correctly (1ms)\n  when dividing numbers\n    \u2713 raises an exception when dividing by zero (1ms)\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ... \u2502 Passed \u2502 Failed \u2502 Skipped \u2502 Duration \u2502\n\u2502  3  \u2502   3    \u2502   0    \u2502    0    \u2502  0.01s   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Congratulations!</p> <p>You've just created executable documentation for your code! These specifications serve as both tests and documentation.</p>"},{"location":"quick-start/#understanding-the-basics","title":"Understanding the Basics","text":"<p>Let's break down what you just wrote:</p>"},{"location":"quick-start/#the-specification-structure","title":"The Specification Structure","text":"<pre><code>[&lt;Tests&gt;]\nlet calculatorSpecs =\n    describe \"Calculator arithmetic operations\" [\n        // Individual specifications go here\n    ]\n</code></pre> <p>FX.Spec specifications are simple values marked with the <code>[&lt;Tests&gt;]</code> attribute. The test discovery system finds these automatically.</p>"},{"location":"quick-start/#the-describe-function","title":"The <code>describe</code> Function","text":"<pre><code>describe \"Calculator arithmetic operations\" [\n    // Specifications for this feature\n]\n</code></pre> <p><code>describe</code> groups related specifications together. It names the feature or behavior you're documenting. You can nest multiple <code>describe</code> blocks to create hierarchical documentation.</p>"},{"location":"quick-start/#the-context-function","title":"The <code>context</code> Function","text":"<pre><code>context \"when adding numbers\" [\n    // Specifications for this specific scenario\n]\n</code></pre> <p><code>context</code> describes specific conditions or scenarios. Use it to organize specifications by state, input, or situation.</p>"},{"location":"quick-start/#the-it-function","title":"The <code>it</code> Function","text":"<pre><code>it \"returns the sum of two positive integers\" (fun () -&gt;\n    let result = 2 + 3\n    expect(result).toEqual(5)\n)\n</code></pre> <p><code>it</code> defines an individual specification:</p> <ul> <li>First parameter: Describes the expected behavior (reads like documentation)</li> <li>Second parameter: Function that verifies the behavior</li> </ul> <p>Tip: Write <code>it</code> descriptions as complete sentences describing what the code should do.</p>"},{"location":"quick-start/#the-fluent-expectation-api","title":"The Fluent Expectation API","text":"<pre><code>expect(actual).toEqual(expected)\nexpectBool(value).toBeTrue()\nexpectSeq(list).toContain(item)\n</code></pre> <p>FX.Spec provides type-specific expectation functions that return fluent wrappers:</p> <ul> <li><code>expect(value)</code> - Generic expectations for any type</li> <li><code>expectBool(value)</code> - Boolean assertions</li> <li><code>expectNum(value)</code> - Numeric comparisons</li> <li><code>expectSeq(value)</code> - Collection assertions</li> <li><code>expectStr(value)</code> - String matching</li> <li>And more...</li> </ul>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have FX.Spec running, explore more features:</p>"},{"location":"quick-start/#organize-with-context","title":"Organize with Context","text":"<p>Use <code>context</code> to add more structure:</p> <pre><code>describe \"Calculator\" [\n    context \"when adding positive numbers\" [\n        it \"returns the sum\" (fun () -&gt;\n            expect(2 + 3).toEqual(5)\n        )\n    ]\n\n    context \"when adding negative numbers\" [\n        it \"handles negatives correctly\" (fun () -&gt;\n            expect(-2 + -3).toEqual(-5)\n        )\n    ]\n]\n</code></pre>"},{"location":"quick-start/#use-type-specific-expectations","title":"Use Type-Specific Expectations","text":"<p>Explore the type-specific expectation functions:</p> <pre><code>// Collections\nexpectSeq([1; 2; 3]).toContain(2)\nexpectSeq([]).toBeEmpty()\nexpectSeq([1; 2; 3]).toHaveLength(3)\n\n// Strings\nexpectStr(\"hello world\").toEndWith(\"world\")\nexpectStr(\"test@example.com\").toMatchRegex(@\"^\\w+@\\w+\\.\\w+$\")\n\n// Numeric\nexpectNum(10).toBeGreaterThan(5)\nexpectFloat(3.14159).toBeCloseTo(3.14, 0.01)\n\n// Options\nexpectOption(Some 42).toBeSome(42)\nexpectOption(None).toBeNone()\n\n// Results\nexpectResult(Ok \"success\").toBeOk(\"success\")\nexpectResult(Error \"failed\").toBeError(\"failed\")\n\n// Exceptions\nexpectThrows&lt;System.ArgumentException&gt;(fun () -&gt; \n    invalidArg \"param\" \"message\"\n)\n</code></pre>"},{"location":"quick-start/#negative-assertions","title":"Negative Assertions","text":"<p>Use <code>.notTo...</code> methods for negative assertions:</p> <pre><code>expect(5).notToEqual(10)\nexpectStr(\"hello\").notToStartWith(\"bye\")\nexpectSeq([1; 2; 3]).notToBeEmpty()\n</code></pre>"},{"location":"quick-start/#focus-on-specific-tests","title":"Focus on Specific Tests","text":"<p>During development, focus on specific tests:</p> <pre><code>describe \"My Suite\" [\n    fit \"only run this test\" (fun () -&gt;  // (1)!\n        expectBool(true).toBeTrue()\n    )\n\n    it \"this test will be skipped\" (fun () -&gt;\n        expectBool(false).toBeTrue()\n    )\n]\n</code></pre> <ol> <li><code>fit</code> (focused it) runs only this test. Use <code>fdescribe</code> to focus an entire group.</li> </ol>"},{"location":"quick-start/#skip-tests-temporarily","title":"Skip Tests Temporarily","text":"<p>Mark tests as pending:</p> <pre><code>describe \"My Suite\" [\n    it \"working test\" (fun () -&gt;\n        expectBool(true).toBeTrue()\n    )\n\n    xit \"not ready yet\" (fun () -&gt;  // (1)!\n        expectBool(false).toBeTrue()\n    )\n\n    pending \"TODO: implement this test\" (fun () -&gt;  // (2)!\n        ()\n    )\n]\n</code></pre> <ol> <li><code>xit</code> (excluded it) skips this test</li> <li><code>pending</code> is an alias for <code>xit</code> that reads better for unfinished tests</li> </ol>"},{"location":"quick-start/#setup-and-teardown","title":"Setup and Teardown","text":"<p>Use hooks for test setup:</p> <pre><code>describe \"Database Tests\" [\n    let mutable connection = null\n\n    beforeEach (fun () -&gt;\n        connection &lt;- Database.connect()\n    )\n\n    afterEach (fun () -&gt;\n        connection.Dispose()\n    )\n\n    it \"queries the database\" (fun () -&gt;\n        let result = connection.Query(\"SELECT 1\")\n        expectSeq(result).notToBeEmpty()\n    )\n]\n</code></pre>"},{"location":"quick-start/#testing-your-own-code","title":"Testing Your Own Code","text":"<p>Here's a complete example testing a simple calculator:</p> <pre><code>// Calculator.fs\nmodule Calculator\n\nlet add x y = x + y\nlet subtract x y = x - y\nlet multiply x y = x * y\nlet divide x y =\n    if y = 0 then\n        invalidArg (nameof y) \"Cannot divide by zero\"\n    else\n        x / y\n</code></pre> <pre><code>// CalculatorSpecs.fs\nmodule CalculatorSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet calculatorSpecs =\n    describe \"Calculator\" [\n        describe \"add\" [\n            it \"adds positive numbers\" (fun () -&gt;\n                expect(Calculator.add 2 3).toEqual(5)\n            )\n\n            it \"adds negative numbers\" (fun () -&gt;\n                expect(Calculator.add -1 -2).toEqual(-3)\n            )\n\n            it \"adds mixed numbers\" (fun () -&gt;\n                expect(Calculator.add 10 -5).toEqual(5)\n            )\n        ]\n\n        describe \"divide\" [\n            it \"divides evenly\" (fun () -&gt;\n                expect(Calculator.divide 10 2).toEqual(5)\n            )\n\n            it \"raises exception on division by zero\" (fun () -&gt;\n                expectThrows&lt;System.ArgumentException&gt;(fun () -&gt; \n                    Calculator.divide 10 0 |&gt; ignore\n                )\n            )\n        ]\n    ]\n</code></pre>"},{"location":"quick-start/#running-tests","title":"Running Tests","text":""},{"location":"quick-start/#basic-run","title":"Basic Run","text":"<pre><code>dotnet run\n</code></pre>"},{"location":"quick-start/#run-specific-tests","title":"Run Specific Tests","text":"<pre><code>dotnet run -- --filter \"Calculator\"\n</code></pre>"},{"location":"quick-start/#choose-output-format","title":"Choose Output Format","text":"<pre><code># Documentation format (default, colorful)\ndotnet run -- --format documentation\n\n# Simple format (plain text)\ndotnet run -- --format simple\n</code></pre>"},{"location":"quick-start/#async-testing","title":"Async Testing","text":"<p>FX.Spec supports asynchronous tests using <code>itAsync</code>:</p> <pre><code>open System.Net.Http\n\n[&lt;Tests&gt;]\nlet asyncSpecs =\n    describe \"Async Operations\" [\n        itAsync \"fetches data from API\" (async {\n            use client = new HttpClient()\n            let! response = client.GetAsync(\"https://api.github.com\") |&gt; Async.AwaitTask\n            expectHttp(response).toHaveStatusOk()\n        })\n\n        itAsync \"handles async computations\" (async {\n            let! result = async {\n                return 42\n            }\n            expect(result).toEqual(42)\n        })\n    ]\n</code></pre> <p>Key Points: - Use <code>itAsync</code> instead of <code>it</code> for async tests - Wrap test in <code>async { }</code> computation expression - Use <code>let!</code> to await async operations - Use <code>Async.AwaitTask</code> to convert .NET Tasks to F# Async</p> <p>For more details, see DSL API Reference.</p>"},{"location":"quick-start/#result-testing","title":"Result Testing","text":"<p>Test F# Result types with state-only or value-specific matchers:</p> <pre><code>[&lt;Tests&gt;]\nlet resultSpecs =\n    describe \"Result Matchers\" [\n        it \"checks success state\" (fun () -&gt;\n            let result = Ok 42\n            expectResult(result).toBeOk()  // Just check it succeeded\n        )\n\n        it \"checks specific success value\" (fun () -&gt;\n            let result = Ok \"success\"\n            expectResult(result).toBeOk(\"success\")  // Check value too\n        )\n\n        it \"checks error state\" (fun () -&gt;\n            let result = Error \"failed\"\n            expectResult(result).toBeError()  // Just check it failed\n        )\n    ]\n</code></pre> <p>For more details, see Result Matchers.</p>"},{"location":"quick-start/#http-testing","title":"HTTP Testing","text":"<p>Test HTTP responses with the fluent HTTP API:</p> <pre><code>open FX.Spec.Http\nopen System.Net.Http\n\n[&lt;Tests&gt;]\nlet httpSpecs =\n    describe \"HTTP API Tests\" [\n        itAsync \"validates API response\" (async {\n            use client = new HttpClient()\n            let! response = client.GetAsync(\"https://api.example.com/users\") |&gt; Async.AwaitTask\n\n            expectHttp(response).toHaveStatusOk()\n            expectHttp(response).toHaveContentType(\"application/json\")\n            expectHttp(response).toHaveBodyContaining(\"users\")\n        })\n    ]\n</code></pre> <p>For more details, see HTTP Testing.</p>"},{"location":"quick-start/#whats-next","title":"What's Next?","text":"<p>You now have a solid foundation in FX.Spec. Continue learning:</p> <ul> <li> <p> DSL API Reference</p> <p>Complete reference for all DSL functions</p> </li> <li> <p> Core Matchers</p> <p>Learn about all available matchers</p> </li> <li> <p> Contributing</p> <p>Help improve FX.Spec</p> </li> </ul>"},{"location":"quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quick-start/#tests-not-discovered","title":"Tests Not Discovered","text":"<p>Make sure your test module has the <code>[&lt;Tests&gt;]</code> attribute:</p> <pre><code>[&lt;Tests&gt;]  // Don't forget this!\nlet mySpecs = describe \"...\" [...]\n</code></pre>"},{"location":"quick-start/#compilation-errors","title":"Compilation Errors","text":"<p>Common issues:</p> <ol> <li>Missing opens: Make sure you have both <code>open FX.Spec.Core</code> and <code>open FX.Spec.Matchers</code></li> <li>Wrong expectation type: Use the appropriate type-specific function (e.g., <code>expectSeq</code> for collections, <code>expectStr</code> for strings)</li> <li>Missing parentheses: Remember to wrap your test in <code>fun () -&gt;</code> for lazy evaluation</li> <li>Method not available: IntelliSense will show you the available methods for each expectation type</li> </ol>"},{"location":"quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Open an issue on GitHub</li> <li>Check existing issues for similar problems</li> <li>Read the Contributing Guide to submit bug reports</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions when using FX.Spec.</p>"},{"location":"troubleshooting/#test-discovery-issues","title":"Test Discovery Issues","text":""},{"location":"troubleshooting/#no-tests-found-in-assembly","title":"\"No tests found in assembly\"","text":"<p>Symptoms:</p> <pre><code>FX.Spec Test Runner\n==================\n\nNo tests found in assembly\n</code></pre> <p>Causes &amp; Solutions:</p>"},{"location":"troubleshooting/#missing-tests-attribute","title":"Missing <code>[&lt;Tests&gt;]</code> Attribute","text":"<p>Problem: Test module doesn't have the <code>[&lt;Tests&gt;]</code> attribute.</p> <pre><code>//  Wrong - no attribute\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre> <p>Solution: Add the <code>[&lt;Tests&gt;]</code> attribute:</p> <pre><code>//  Correct\n[&lt;Tests&gt;]\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#wrong-return-type","title":"Wrong Return Type","text":"<p>Problem: Test member doesn't return <code>TestNode list</code>.</p> <pre><code>//  Wrong - returns unit\n[&lt;Tests&gt;]\nlet mySpecs () =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre> <p>Solution: Return <code>TestNode list</code>:</p> <pre><code>//  Correct\n[&lt;Tests&gt;]\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#non-static-member","title":"Non-Static Member","text":"<p>Problem: Test member is not static.</p> <pre><code>//  Wrong - instance member\ntype MyTests() =\n    [&lt;Tests&gt;]\n    member this.Specs =\n        spec { ... }\n</code></pre> <p>Solution: Make it static:</p> <pre><code>//  Correct\ntype MyTests =\n    [&lt;Tests&gt;]\n    static member Specs =\n        spec { ... }\n\n// Or use module-level let binding\nmodule MyTests\n\n[&lt;Tests&gt;]\nlet specs =\n    spec { ... }\n</code></pre>"},{"location":"troubleshooting/#compilation-errors","title":"Compilation Errors","text":""},{"location":"troubleshooting/#the-value-or-constructor-spec-is-not-defined","title":"\"The value or constructor 'spec' is not defined\"","text":"<p>Problem: Missing <code>open FX.Spec.Core</code>.</p> <p>Solution:</p> <pre><code>open FX.Spec.Core  // \u2190 Add this\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet mySpecs = spec { ... }\n</code></pre>"},{"location":"troubleshooting/#the-value-or-constructor-expect-is-not-defined","title":"\"The value or constructor 'expect' is not defined\"","text":"<p>Problem: Missing <code>open FX.Spec.Matchers</code>.</p> <p>Solution:</p> <pre><code>open FX.Spec.Core\nopen FX.Spec.Matchers  // \u2190 Add this\n\n[&lt;Tests&gt;]\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"test\" (fun () -&gt;\n                expect true |&gt; should beTrue\n            )\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#this-expression-was-expected-to-have-type-testnode-list-but-here-has-type-testnode","title":"\"This expression was expected to have type 'TestNode list' but here has type 'TestNode'\"","text":"<p>Problem: Missing <code>yield</code> keyword in spec block.</p> <pre><code>//  Wrong\nspec {\n    describe \"Feature\" [  // Missing yield\n        it \"test\" (fun () -&gt; ...)\n    ]\n}\n</code></pre> <p>Solution: Add <code>yield</code>:</p> <pre><code>//  Correct\nspec {\n    yield describe \"Feature\" [\n        it \"test\" (fun () -&gt; ...)\n    ]\n}\n</code></pre>"},{"location":"troubleshooting/#this-expression-was-expected-to-have-type-unit-unit-but-here-has-type-unit","title":"\"This expression was expected to have type 'unit -&gt; unit' but here has type 'unit'\"","text":"<p>Problem: Test code not wrapped in a function.</p> <pre><code>//  Wrong\nit \"test\" (\n    expect true |&gt; should beTrue  // Not wrapped\n)\n</code></pre> <p>Solution: Wrap in <code>(fun () -&gt; ...)</code>:</p> <pre><code>//  Correct\nit \"test\" (fun () -&gt;\n    expect true |&gt; should beTrue\n)\n</code></pre>"},{"location":"troubleshooting/#matcher-type-errors","title":"Matcher Type Errors","text":""},{"location":"troubleshooting/#type-mismatch-with-matchers","title":"\"Type mismatch\" with Matchers","text":"<p>Problem: Matcher type doesn't match actual value type.</p> <pre><code>//  Wrong - comparing int to string\nexpect 42 |&gt; should (equal \"42\")\n</code></pre> <p>Solution: Ensure types match:</p> <pre><code>//  Correct\nexpect 42 |&gt; should (equal 42)\nexpect \"42\" |&gt; should (equal \"42\")\n</code></pre>"},{"location":"troubleshooting/#this-expression-was-expected-to-have-type-matchera-but-here-has-type-matchresult","title":"\"This expression was expected to have type 'Matcher&lt;'a&gt;' but here has type 'MatchResult'\"","text":"<p>Problem: Calling matcher function instead of passing it.</p> <pre><code>//  Wrong - calling equal with ()\nexpect 42 |&gt; should (equal 42 ())\n</code></pre> <p>Solution: Don't call the matcher:</p> <pre><code>//  Correct\nexpect 42 |&gt; should (equal 42)\n</code></pre>"},{"location":"troubleshooting/#the-type-string-does-not-support-the-comparison-constraint","title":"\"The type 'string' does not support the comparison constraint\"","text":"<p>Problem: Using numeric matchers on non-comparable types.</p> <pre><code>//  Wrong - can't compare functions\nlet f = fun x -&gt; x + 1\nexpect f |&gt; should (beGreaterThan (fun x -&gt; x))\n</code></pre> <p>Solution: Use appropriate matchers for the type:</p> <pre><code>//  Correct - use equality for functions\nlet f = fun x -&gt; x + 1\nexpect (f 5) |&gt; should (equal 6)\n</code></pre>"},{"location":"troubleshooting/#runtime-errors","title":"Runtime Errors","text":""},{"location":"troubleshooting/#assembly-not-found-or-could-not-load-file-or-assembly","title":"\"Assembly not found\" or \"Could not load file or assembly\"","text":"<p>Problem: Assembly path is incorrect or assembly not built.</p> <p>Solution:</p> <pre><code># 1. Build the test project first\ndotnet build tests/MyProject.Tests/MyProject.Tests.fsproj\n\n# 2. Use the correct path to the built assembly\ndotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- \\\n  tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n</code></pre>"},{"location":"troubleshooting/#no-tests-match-the-filter","title":"\"No tests match the filter\"","text":"<p>Problem: Filter pattern doesn't match any test descriptions.</p> <p>Symptoms:</p> <pre><code>Filtering tests by: MyTest\nRunning 0 filtered examples\n\nNo tests match the filter\n</code></pre> <p>Solutions:</p> <ol> <li>Check case sensitivity - filters are case-sensitive:</li> </ol> <pre><code>#  Wrong\n./run-tests.sh --filter \"calculator\"\n\n#  Correct\n./run-tests.sh --filter \"Calculator\"\n</code></pre> <ol> <li>Use partial matches:</li> </ol> <pre><code>#  Too specific\n./run-tests.sh --filter \"Calculator &gt; addition &gt; adds two numbers\"\n\n#  Better\n./run-tests.sh --filter \"addition\"\n</code></pre> <ol> <li>Remove filter to see all test names:</li> </ol> <pre><code>./run-tests.sh\n</code></pre>"},{"location":"troubleshooting/#tests-run-but-all-fail-with-object-reference-not-set","title":"Tests Run But All Fail with \"Object reference not set\"","text":"<p>Problem: Hooks or test setup not running correctly.</p> <p>Common Causes:</p> <ol> <li>Using mutable variables without initialization:</li> </ol> <pre><code>//  Wrong\ndescribe \"Database\" [\n    let mutable connection = null  // null reference\n\n    it \"queries data\" (fun () -&gt;\n        connection.Query(\"SELECT 1\")  // NullReferenceException\n    )\n]\n</code></pre> <p>Solution: Use <code>beforeEach</code> to initialize:</p> <pre><code>//  Correct\ndescribe \"Database\" [\n    let mutable connection = null\n\n    beforeEach (fun () -&gt;\n        connection &lt;- Database.connect()\n    )\n\n    it \"queries data\" (fun () -&gt;\n        connection.Query(\"SELECT 1\")\n    )\n]\n</code></pre>"},{"location":"troubleshooting/#test-execution-issues","title":"Test Execution Issues","text":""},{"location":"troubleshooting/#tests-pass-individually-but-fail-when-run-together","title":"Tests Pass Individually But Fail When Run Together","text":"<p>Problem: Tests are not isolated - they share state.</p> <p>Solution: Use <code>beforeEach</code> and <code>afterEach</code> for proper isolation:</p> <pre><code>describe \"User Tests\" [\n    let mutable user = null\n\n    beforeEach (fun () -&gt;\n        user &lt;- createUser()  // Fresh user for each test\n    )\n\n    afterEach (fun () -&gt;\n        deleteUser(user)  // Clean up after each test\n    )\n\n    it \"test 1\" (fun () -&gt; ...)\n    it \"test 2\" (fun () -&gt; ...)\n]\n</code></pre>"},{"location":"troubleshooting/#focused-tests-not-running","title":"Focused Tests Not Running","text":"<p>Problem: Using <code>fit</code> or <code>fdescribe</code> but all tests still run.</p> <p>Cause: Focused filtering only works when tests are discovered together.</p> <p>Solution: Ensure all tests are in the same assembly and discovered together:</p> <pre><code>//  Correct - both in same spec\n[&lt;Tests&gt;]\nlet specs =\n    spec {\n        yield describe \"Suite\" [\n            fit \"only this runs\" (fun () -&gt; ...)\n            it \"this is skipped\" (fun () -&gt; ...)\n        ]\n    }\n</code></pre>"},{"location":"troubleshooting/#pending-tests-still-running","title":"Pending Tests Still Running","text":"<p>Problem: Using <code>xit</code> but test still executes.</p> <p>Cause: Typo in function name.</p> <pre><code>//  Wrong - typo\nxIt \"test\" (fun () -&gt; ...)  // Capital I\n</code></pre> <p>Solution: Use correct function name:</p> <pre><code>//  Correct\nxit \"test\" (fun () -&gt; ...)  // lowercase i\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#tests-running-slowly","title":"Tests Running Slowly","text":"<p>Causes &amp; Solutions:</p>"},{"location":"troubleshooting/#using-beforeeach-for-expensive-setup","title":"Using <code>beforeEach</code> for Expensive Setup","text":"<p>Problem: Expensive setup runs before every test.</p> <pre><code>//  Slow - database created for each test\nbeforeEach (fun () -&gt;\n    createDatabase()  // Expensive!\n)\n</code></pre> <p>Solution: Use <code>beforeAll</code> for expensive setup:</p> <pre><code>//  Fast - database created once\nbeforeAll (fun () -&gt;\n    createDatabase()\n)\n\nbeforeEach (fun () -&gt;\n    clearData()  // Fast cleanup\n)\n</code></pre>"},{"location":"troubleshooting/#not-cleaning-up-resources","title":"Not Cleaning Up Resources","text":"<p>Problem: Resources accumulate during test run.</p> <p>Solution: Use <code>afterEach</code> or <code>afterAll</code>:</p> <pre><code>describe \"File Tests\" [\n    let mutable tempFile = \"\"\n\n    beforeEach (fun () -&gt;\n        tempFile &lt;- Path.GetTempFileName()\n    )\n\n    afterEach (fun () -&gt;\n        File.Delete(tempFile)  // Clean up\n    )\n\n    it \"test\" (fun () -&gt; ...)\n]\n</code></pre>"},{"location":"troubleshooting/#ide-integration-issues","title":"IDE Integration Issues","text":""},{"location":"troubleshooting/#tests-not-discovered-in-ide","title":"Tests Not Discovered in IDE","text":"<p>Problem: FX.Spec doesn't integrate with standard .NET test explorers.</p> <p>Explanation: FX.Spec uses its own test runner, not the standard .NET test framework.</p> <p>Workaround: Run tests from command line:</p> <pre><code>./run-tests.sh\n</code></pre> <p>Future: IDE integration is planned for future releases.</p>"},{"location":"troubleshooting/#syntax-highlighting-issues","title":"Syntax Highlighting Issues","text":"<p>Problem: F# syntax highlighting doesn't work well with FX.Spec DSL.</p> <p>Solution: This is a limitation of current F# tooling. The code is valid F# even if highlighting is imperfect.</p>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you encounter an issue not covered here:</p> <ol> <li>Check the documentation:</li> <li>Quick Start Guide</li> <li>DSL API Reference</li> <li> <p>Test Runner</p> </li> <li> <p>Search existing issues: GitHub Issues</p> </li> <li> <p>Ask for help:</p> </li> <li> <p>Open a new issue with:</p> <ul> <li>FX.Spec version</li> <li>.NET version</li> <li>Minimal reproduction code</li> <li>Error messages</li> <li>What you've tried</li> </ul> </li> <li> <p>Contribute: Found a bug? Submit a PR!</p> </li> </ol>"},{"location":"troubleshooting/#common-gotchas","title":"Common Gotchas","text":""},{"location":"troubleshooting/#1-forgetting-yield","title":"1. Forgetting <code>yield</code>","text":"<pre><code>//  Won't compile\nspec {\n    describe \"Test\" [ ... ]\n}\n\n//  Correct\nspec {\n    yield describe \"Test\" [ ... ]\n}\n</code></pre>"},{"location":"troubleshooting/#2-not-wrapping-test-code-in-function","title":"2. Not Wrapping Test Code in Function","text":"<pre><code>//  Won't compile\nit \"test\" (expect true |&gt; should beTrue)\n\n//  Correct\nit \"test\" (fun () -&gt; expect true |&gt; should beTrue)\n</code></pre>"},{"location":"troubleshooting/#3-using-instead-of","title":"3. Using <code>{}</code> Instead of <code>[]</code>","text":"<pre><code>//  Wrong syntax\ndescribe \"Test\" {\n    it \"test\" { ... }\n}\n\n//  Correct syntax\ndescribe \"Test\" [\n    it \"test\" (fun () -&gt; ...)\n]\n</code></pre>"},{"location":"troubleshooting/#4-forgetting-tests-attribute","title":"4. Forgetting <code>[&lt;Tests&gt;]</code> Attribute","text":"<pre><code>//  Tests won't be discovered\nlet mySpecs = spec { ... }\n\n//  Tests will be discovered\n[&lt;Tests&gt;]\nlet mySpecs = spec { ... }\n</code></pre>"},{"location":"troubleshooting/#5-wrong-open-statements","title":"5. Wrong <code>open</code> Statements","text":"<pre><code>//  Missing opens\nlet specs = spec { ... }  // Error: 'spec' not defined\n\n//  Correct opens\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\nlet specs = spec { ... }\n</code></pre>"},{"location":"troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Quick Start Guide - Getting started</li> <li>DSL API Reference - Complete DSL documentation</li> <li>Test Runner - Runner options and usage</li> <li>Contributing - How to contribute</li> </ul>"},{"location":"community/contributing/","title":"Contributing to FX.Spec","text":"<p>Thank you for your interest in contributing to FxSpec! This document provides guidelines and instructions for contributing.</p>"},{"location":"community/contributing/#getting-started","title":"Getting Started","text":""},{"location":"community/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8.0 or .NET 9.0 SDK</li> <li>F# 8.0+ (included with .NET SDK)</li> <li>Git</li> <li>Basic F# knowledge</li> <li>Familiarity with BDD testing concepts</li> </ul>"},{"location":"community/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li>Fork and clone the repository:</li> </ol> <pre><code>git clone https://github.com/dawsons-creek/fx-spec.git\ncd fx-spec\n</code></pre> <ol> <li>Build the solution:</li> </ol> <pre><code>dotnet build\n</code></pre> <ol> <li>Run the tests:</li> </ol> <pre><code>./run-tests.sh\n</code></pre> <p>You should see all tests passing. FX.Spec uses itself for testing (dogfooding).</p>"},{"location":"community/contributing/#building-the-project","title":"Building the Project","text":""},{"location":"community/contributing/#project-structure","title":"Project Structure","text":"<pre><code>fx-spec/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 FX.Spec.Core/          # Core DSL and test tree\n\u2502   \u251c\u2500\u2500 FX.Spec.Matchers/      # Assertion matchers\n\u2502   \u2514\u2500\u2500 FX.Spec.Runner/        # Test discovery and execution\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 FX.Spec.Core.Tests/    # Tests for Core\n\u2502   \u2514\u2500\u2500 FX.Spec.Matchers.Tests/# Tests for Matchers\n\u251c\u2500\u2500 examples/                  # Example usage\n\u2514\u2500\u2500 docs/                      # Documentation\n</code></pre>"},{"location":"community/contributing/#build-commands","title":"Build Commands","text":"<pre><code># Build everything\ndotnet build\n\n# Build specific project\ndotnet build src/FX.Spec.Core/FX.Spec.Core.fsproj\n\n# Clean build\ndotnet clean\ndotnet build\n\n# Release build\ndotnet build -c Release\n</code></pre>"},{"location":"community/contributing/#running-tests","title":"Running Tests","text":"<p>FX.Spec tests itself using its own framework.</p>"},{"location":"community/contributing/#run-all-tests","title":"Run All Tests","text":"<pre><code>./run-tests.sh\n</code></pre>"},{"location":"community/contributing/#run-specific-tests","title":"Run Specific Tests","text":"<pre><code># Filter by test description\n./run-tests.sh --filter \"SpecBuilder\"\n\n# Use simple formatter\n./run-tests.sh --format simple\n</code></pre>"},{"location":"community/contributing/#run-tests-manually","title":"Run Tests Manually","text":"<pre><code># Build and run\ndotnet build tests/FX.Spec.Core.Tests/FX.Spec.Core.Tests.fsproj\ndotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- \\\n  tests/FX.Spec.Core.Tests/bin/Debug/net9.0/FX.Spec.Core.Tests.dll\n</code></pre>"},{"location":"community/contributing/#code-style","title":"Code Style","text":""},{"location":"community/contributing/#f-conventions","title":"F# Conventions","text":"<p>FX.Spec follows standard F# conventions:</p> <ul> <li>Naming:</li> <li><code>camelCase</code> for functions and values</li> <li><code>PascalCase</code> for types, modules, and DU cases</li> <li> <p>Prefix private functions with <code>private</code> keyword</p> </li> <li> <p>Code Organization:</p> </li> <li>Group related functions together</li> <li>Use <code>/// XML comments</code> for public APIs</li> <li> <p>Keep functions focused and small (prefer &lt; 25 lines)</p> </li> <li> <p>Pattern Matching:</p> </li> <li>Use <code>function</code> shorthand for single-argument pattern matching</li> <li>Match exhaustively (compiler enforces this)</li> <li>Put most common cases first</li> </ul>"},{"location":"community/contributing/#example","title":"Example","text":"<pre><code>/// Builds the full path to a test node.\nlet rec buildTestPath (path: string list) (node: TestResultNode) : (string * TestResult * TimeSpan) list =\n    match node with\n    | ExampleResult (desc, result, duration) -&gt;\n        let fullPath = (path @ [desc]) |&gt; String.concat \" &gt; \"\n        [(fullPath, result, duration)]\n    | GroupResult (desc, children) -&gt;\n        let newPath = path @ [desc]\n        children |&gt; List.collect (buildTestPath newPath)\n</code></pre>"},{"location":"community/contributing/#code-quality","title":"Code Quality","text":"<ul> <li>No compiler warnings: Code must compile without warnings</li> <li>Follow best practices:</li> <li>Prefer pure functions</li> <li>Minimize mutable state</li> <li>Use type constraints appropriately</li> <li>Avoid magic numbers (use named constants)</li> <li>Write tests: All new features must have tests</li> <li>Document public APIs: Use XML comments for all public functions</li> </ul>"},{"location":"community/contributing/#making-changes","title":"Making Changes","text":""},{"location":"community/contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n# or\ngit checkout -b fix/bug-description\n</code></pre>"},{"location":"community/contributing/#branch-naming","title":"Branch Naming","text":"<ul> <li><code>feature/</code> - New features</li> <li><code>fix/</code> - Bug fixes</li> <li><code>docs/</code> - Documentation changes</li> <li><code>refactor/</code> - Code refactoring</li> </ul>"},{"location":"community/contributing/#2-write-code","title":"2. Write Code","text":"<ul> <li>Follow F# conventions and code style</li> <li>Add tests for new functionality</li> <li>Update documentation if needed</li> </ul>"},{"location":"community/contributing/#3-write-tests","title":"3. Write Tests","text":"<p>All code changes must include tests. FX.Spec tests itself:</p> <pre><code>module MyNewFeatureSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet myNewFeatureSpecs =\n    spec {\n        describe \"MyNewFeature\" [\n            it \"works as expected\" (fun () -&gt;\n                let result = MyNewFeature.doSomething()\n                expect result |&gt; should (equal expectedValue)\n            )\n        ]\n    }\n</code></pre>"},{"location":"community/contributing/#4-run-tests","title":"4. Run Tests","text":"<pre><code>./run-tests.sh\n</code></pre> <p>All tests must pass before submitting a pull request.</p>"},{"location":"community/contributing/#5-commit-changes","title":"5. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"feat: add new feature description\"\n</code></pre>"},{"location":"community/contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commits format:</p> <pre><code>type(scope): description\n\n[optional body]\n</code></pre> <p>Types: - <code>feat:</code> - New feature - <code>fix:</code> - Bug fix - <code>docs:</code> - Documentation changes - <code>refactor:</code> - Code refactoring - <code>test:</code> - Adding or updating tests - <code>chore:</code> - Maintenance tasks</p> <p>Examples:</p> <pre><code>feat(matchers): add bePositive and beNegative matchers\nfix(runner): handle null test descriptions correctly\ndocs(quick-start): update installation instructions\nrefactor(core): simplify test tree building\n</code></pre>"},{"location":"community/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"community/contributing/#1-push-your-branch","title":"1. Push Your Branch","text":"<pre><code>git push origin feature/my-new-feature\n</code></pre>"},{"location":"community/contributing/#2-open-pull-request","title":"2. Open Pull Request","text":"<ul> <li>Go to GitHub and open a pull request</li> <li>Fill in the PR template</li> <li>Link any related issues</li> </ul>"},{"location":"community/contributing/#pr-title","title":"PR Title","text":"<p>Follow the same format as commit messages:</p> <pre><code>feat(matchers): add numeric comparison matchers\nfix(runner): prevent crash on empty test suite\n</code></pre>"},{"location":"community/contributing/#pr-description","title":"PR Description","text":"<p>Include:</p> <ul> <li>What: What changes did you make?</li> <li>Why: Why are these changes needed?</li> <li>How: How did you implement the changes?</li> <li>Testing: How did you test the changes?</li> </ul>"},{"location":"community/contributing/#example-pr-description","title":"Example PR Description","text":"<pre><code>## What\n\nAdd `bePositive`, `beNegative`, and `beZero` matchers for numeric comparisons.\n\n## Why\n\nUsers need a convenient way to test if numbers are positive, negative, or zero without writing custom matchers or using comparison operators.\n\n## How\n\n- Added three new matchers in `NumericMatchers.fs`\n- Used inline functions with generic numeric constraints\n- Leveraged `LanguagePrimitives.GenericZero`\n\n## Testing\n\n- Added comprehensive tests in `NumericMatchersSpecs.fs`\n- Tested with int, float, and decimal types\n- All 166 tests passing\n</code></pre>"},{"location":"community/contributing/#3-code-review","title":"3. Code Review","text":"<ul> <li>Address reviewer feedback</li> <li>Update code as needed</li> <li>Push changes to the same branch</li> <li>PR will update automatically</li> </ul>"},{"location":"community/contributing/#4-merge","title":"4. Merge","text":"<p>Once approved: - Squash and merge (preferred) - Merge commit (for multi-commit features) - Rebase and merge (for clean history)</p>"},{"location":"community/contributing/#areas-to-contribute","title":"Areas to Contribute","text":""},{"location":"community/contributing/#matchers","title":"Matchers","text":"<p>We always welcome new matchers! Ideas:</p> <ul> <li>DateTime matchers: <code>beToday</code>, <code>beBefore</code>, <code>beAfter</code>, <code>beInYear</code></li> <li>Async matchers: Matchers for <code>Async&lt;'T&gt;</code> and <code>Task&lt;'T&gt;</code></li> <li>File/IO matchers: <code>fileExist</code>, <code>directoryExist</code>, <code>haveExtension</code></li> <li>JSON matchers: Matchers for JSON comparison</li> </ul>"},{"location":"community/contributing/#formatters","title":"Formatters","text":"<ul> <li>Alternative output formats (JSON, JUnit XML, TAP)</li> <li>Integration with test reporting tools</li> <li>VS Code extension support</li> </ul>"},{"location":"community/contributing/#documentation","title":"Documentation","text":"<ul> <li>Tutorial content</li> <li>How-to guides</li> <li>Example projects</li> <li>Blog posts</li> </ul>"},{"location":"community/contributing/#bug-fixes","title":"Bug Fixes","text":"<p>Check open issues for bugs to fix.</p>"},{"location":"community/contributing/#documentation_1","title":"Documentation","text":""},{"location":"community/contributing/#building-documentation","title":"Building Documentation","text":"<p>Documentation uses Material for MkDocs:</p> <pre><code># Install dependencies (first time only)\nuv venv\nuv pip install mkdocs-material mkdocs-mermaid2-plugin\n\n# Serve locally\nuv run mkdocs serve\n\n# Open http://127.0.0.1:8000\n</code></pre>"},{"location":"community/contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Add practical use cases</li> <li>Follow existing structure</li> </ul> <p>Documentation structure follows the Di\u00e1taxis framework:</p> <ul> <li>Tutorials: Learning-oriented lessons</li> <li>How-To Guides: Task-oriented directions</li> <li>Reference: Information-oriented descriptions</li> <li>Explanation: Understanding-oriented discussions</li> </ul>"},{"location":"community/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"community/contributing/#test-organization","title":"Test Organization","text":"<pre><code>spec {\n    describe \"FeatureName\" [\n        context \"when specific condition\" [\n            it \"behaves in expected way\" (fun () -&gt;\n                // Arrange\n                let input = setupTestData()\n\n                // Act\n                let result = performOperation(input)\n\n                // Assert\n                expect result |&gt; should (equal expectedValue)\n            )\n        ]\n    ]\n}\n</code></pre>"},{"location":"community/contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Test happy paths</li> <li>Test edge cases</li> <li>Test error conditions</li> <li>Test boundary values</li> </ul>"},{"location":"community/contributing/#good-test-examples","title":"Good Test Examples","text":"<pre><code>// Good: Clear, focused, descriptive\nit \"adds two positive numbers\" (fun () -&gt;\n    expect (Calculator.add 2 3) |&gt; should (equal 5)\n)\n\n// Good: Tests edge case\nit \"handles division by zero\" (fun () -&gt;\n    expect (fun () -&gt; Calculator.divide 10 0) |&gt; should raiseException\n)\n\n// Less good: Unclear what's being tested\nit \"test1\" (fun () -&gt;\n    expect (doSomething()) |&gt; should (equal 42)\n)\n</code></pre>"},{"location":"community/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Questions: Open a discussion</li> <li>Bugs: Open an issue</li> <li>Chat: Join our community chat (link TBD)</li> </ul>"},{"location":"community/contributing/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"community/contributing/#our-standards","title":"Our Standards","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Accept constructive criticism</li> <li>Focus on what's best for the community</li> <li>Show empathy</li> </ul>"},{"location":"community/contributing/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>Harassment or discrimination</li> <li>Trolling or insulting comments</li> <li>Personal or political attacks</li> <li>Publishing others' private information</li> </ul>"},{"location":"community/contributing/#enforcement","title":"Enforcement","text":"<p>Violations may result in temporary or permanent ban from the project.</p>"},{"location":"community/contributing/#license","title":"License","text":"<p>By contributing to FxSpec, you agree that your contributions will be licensed under the same license as the project (MIT License).</p>"},{"location":"community/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>GitHub contributors list</li> <li>Release notes</li> <li>Project documentation</li> </ul> <p>Thank you for contributing to FxSpec!</p>"},{"location":"reference/","title":"Reference Documentation","text":"<p>Complete API reference for FX.Spec.</p>"},{"location":"reference/#quick-links","title":"Quick Links","text":"<ul> <li> <p> DSL API</p> <p>Complete reference for <code>describe</code>, <code>it</code>, <code>context</code>, and all DSL functions.</p> </li> <li> <p> Matchers</p> <p>All available matchers organized by category.</p> </li> </ul>"},{"location":"reference/#api-categories","title":"API Categories","text":""},{"location":"reference/#core-dsl","title":"Core DSL","text":"<ul> <li>describe - Group related tests</li> <li>context - Add context to test groups (alias for <code>describe</code>)</li> <li>it - Define individual test cases</li> </ul>"},{"location":"reference/#focus-pending","title":"Focus &amp; Pending","text":"<ul> <li>fit - Focus on specific test</li> <li>fdescribe - Focus on test group</li> <li>xit - Skip a test</li> <li>pending - Mark test as pending (alias for <code>xit</code>)</li> </ul>"},{"location":"reference/#hooks","title":"Hooks","text":"<ul> <li>beforeEach - Run before each test</li> <li>afterEach - Run after each test</li> <li>beforeAll - Run once before all tests in group</li> <li>afterAll - Run once after all tests in group</li> </ul>"},{"location":"reference/#expectations","title":"Expectations","text":"<ul> <li>expect - Create a generic expectation</li> <li>expectBool - Create a boolean expectation</li> <li>expectOption - Create an Option expectation</li> <li>expectResult - Create a Result expectation</li> <li>expectSeq - Create a collection expectation</li> <li>expectStr - Create a string expectation</li> <li>expectNum - Create a numeric expectation</li> <li>expectInt - Create an integer expectation</li> <li>expectFloat - Create a float expectation</li> <li>expectThrows - Assert an exception is thrown</li> <li>expectHttp - Create an HTTP response expectation</li> <li>expectJson - Create a JSON expectation</li> <li>expectJsonApi - Create a JSON:API expectation</li> </ul>"},{"location":"reference/#matcher-categories","title":"Matcher Categories","text":""},{"location":"reference/#core-matchers","title":"Core Matchers","text":"<p>Basic equality, null checks, boolean, and option matchers.</p>"},{"location":"reference/#collection-matchers","title":"Collection Matchers","text":"<p>Matchers for lists, arrays, sequences, and other collections.</p>"},{"location":"reference/#string-matchers","title":"String Matchers","text":"<p>String-specific matchers for prefixes, suffixes, patterns, and more.</p>"},{"location":"reference/#numeric-matchers","title":"Numeric Matchers","text":"<p>Numeric comparisons and range checks.</p>"},{"location":"reference/#exception-matchers","title":"Exception Matchers","text":"<p>Testing exception throwing behavior.</p>"},{"location":"reference/#http-matchers","title":"HTTP Matchers","text":"<p>Testing HTTP responses (status, headers, body).</p>"},{"location":"reference/#json-matchers","title":"JSON Matchers","text":"<p>Testing JSON content with path-based navigation.</p>"},{"location":"reference/#jsonapi-matchers","title":"JSON:API Matchers","text":"<p>Testing JSON:API documents (resources, relationships, includes).</p>"},{"location":"reference/#integration-testing","title":"Integration Testing","text":""},{"location":"reference/#aspnet-core","title":"ASP.NET Core","text":"<p>Helpers for testing ASP.NET Core handlers and middleware with in-memory contexts.</p>"},{"location":"reference/aspnetcore/","title":"ASP.NET Core Testing","text":"<p>FX.Spec.AspNetCore provides a set of functional helpers for integration testing ASP.NET Core applications by manipulating <code>HttpContext</code> directly. This allows for fast, in-memory testing of handlers and middleware without spinning up a full test server.</p>"},{"location":"reference/aspnetcore/#overview","title":"Overview","text":"<p>The library focuses on a \"Context-first\" approach:</p> <ol> <li>Create a test <code>HttpContext</code>.</li> <li>Configure the request (method, path, headers, body).</li> <li>Execute your handler/middleware against the context.</li> <li>Inspect the response on the context.</li> </ol> <pre><code>open FX.Spec.AspNetCore\nopen FX.Spec.Json\n\nit \"creates a user\" (fun () -&gt;\n    let ctx = \n        createTestContext()\n        |&gt; setRequest \"POST\" \"/users\"\n        |&gt; setJsonBody (toJson {| name = \"John\" |})\n\n    // Execute your handler (implementation specific)\n    // do! myHandler ctx\n\n    expect(ctx.Response.StatusCode).toEqual(201)\n\n    let response = parseResponseJson&lt;User&gt;(ctx)\n    expect(response.Name).toEqual(\"John\")\n)\n</code></pre>"},{"location":"reference/aspnetcore/#installation","title":"Installation","text":"<p>Add the ASP.NET Core package to your test project:</p> <pre><code>dotnet add package FX.Spec.AspNetCore\n</code></pre>"},{"location":"reference/aspnetcore/#context-helpers","title":"Context Helpers","text":"<p>The <code>FxContextHelpers</code> module is automatically opened when you import the namespace.</p>"},{"location":"reference/aspnetcore/#creating-contexts","title":"Creating Contexts","text":""},{"location":"reference/aspnetcore/#createtestcontext","title":"<code>createTestContext()</code>","text":"<p>Creates a lightweight <code>DefaultHttpContext</code> with: -   Initialized <code>RequestServices</code> (empty <code>ServiceCollection</code>). -   Buffered <code>Response.Body</code> (MemoryStream). -   Logging configured (Debug level).</p>"},{"location":"reference/aspnetcore/#createtestcontextwithconfigureservices","title":"<code>createTestContextWith(configureServices)</code>","text":"<p>Creates a context with custom dependency injection services.</p> <pre><code>let ctx = createTestContextWith (fun services -&gt;\n    services.AddSingleton&lt;IUserRepository, MockUserRepository&gt;() |&gt; ignore\n)\n</code></pre>"},{"location":"reference/aspnetcore/#request-configuration","title":"Request Configuration","text":"<p>These functions match the fluent style, returning the modified <code>HttpContext</code>.</p>"},{"location":"reference/aspnetcore/#setrequestmethod-string-path-string","title":"<code>setRequest(method: string) (path: string)</code>","text":"<p>Sets the HTTP method and request path.</p> <pre><code>ctx |&gt; setRequest \"GET\" \"/api/items/1\"\n</code></pre>"},{"location":"reference/aspnetcore/#setjsonbodyjson-string","title":"<code>setJsonBody(json: string)</code>","text":"<p>Sets the request body content and sets <code>Content-Type</code> to <code>application/json</code>. Use with <code>toJson</code> helper from <code>FX.Spec.Json</code>.</p> <pre><code>ctx |&gt; setJsonBody (toJson {| id = 1; name = \"Test\" |})\n</code></pre>"},{"location":"reference/aspnetcore/#setrequestbodycontent-string","title":"<code>setRequestBody(content: string)</code>","text":"<p>Sets the raw string content of the request body without modifying headers.</p>"},{"location":"reference/aspnetcore/#header-helpers","title":"Header Helpers","text":"<ul> <li><code>setAcceptHeader(mediaType: string)</code></li> <li><code>setContentType(mediaType: string)</code></li> </ul>"},{"location":"reference/aspnetcore/#response-inspection","title":"Response Inspection","text":""},{"location":"reference/aspnetcore/#getresponsebodyctx","title":"<code>getResponseBody(ctx)</code>","text":"<p>Reads the response stream as a UTF-8 string without consuming it (resets stream position). Safe to call multiple times.</p> <pre><code>let body = getResponseBody ctx\nexpectStr(body).toContain(\"error\")\n</code></pre>"},{"location":"reference/aspnetcore/#parseresponsejsontctx","title":"<code>parseResponseJson&lt;'T&gt;(ctx)</code>","text":"<p>Deserializes the response body to type <code>'T</code> using <code>FX.Spec.Json</code> defaults (F# type support enabled).</p> <pre><code>let result = parseResponseJson&lt;MyResult&gt;(ctx)\nexpect(result.Id).toEqual(1)\n</code></pre>"},{"location":"reference/aspnetcore/#router-helpers","title":"Router Helpers","text":"<p>If you are using the <code>FX.Core</code> functional router, you can use <code>FxRouterHelpers</code> to dispatch requests directly to your route definitions.</p>"},{"location":"reference/aspnetcore/#executeroute","title":"<code>executeRoute</code>","text":"<p>Matches the request against a <code>Router</code> and executes the corresponding handler.</p> <p>Signature: <code>executeRoute (router: Router) (method: HttpMethod) (path: string) (ctx: HttpContext) : Task&lt;HttpContext&gt;</code></p> <pre><code>open FX.Core\n\n// Define your router\nlet appRouter = \n    router [\n        get \"/users\" listUsers\n        post \"/users\" createUser\n    ]\n\n// Test a route\nitAsync \"routes to create user\" (async {\n    let ctx = \n        createTestContext() \n        |&gt; setRequest \"POST\" \"/users\"\n\n    // Execute the router against the context\n    let! resultCtx = \n        executeRoute appRouter HttpMethod.POST \"/users\" ctx \n        |&gt; Async.AwaitTask\n\n    expect(resultCtx.Response.StatusCode).toEqual(200)\n})\n</code></pre>"},{"location":"reference/dsl-api/","title":"DSL API Reference","text":"<p>Complete reference for FxSpec's Domain-Specific Language functions.</p>"},{"location":"reference/dsl-api/#overview","title":"Overview","text":"<p>FX.Spec uses a clean, functional DSL to build specification trees. The DSL provides functions for organizing specifications, defining behavioral requirements, and managing test lifecycle with hooks.</p> <p>Think of your tests as living documentation - they describe what your system does, not just verify it works.</p>"},{"location":"reference/dsl-api/#core-functions","title":"Core Functions","text":""},{"location":"reference/dsl-api/#test-structure","title":"Test Structure","text":"<p>FX.Spec tests are simple values marked with the <code>[&lt;Tests&gt;]</code> attribute. No wrapper is needed.</p> <p>Usage:</p> <pre><code>[&lt;Tests&gt;]\nlet myTests =\n    describe \"Feature\" [\n        it \"works\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n</code></pre> <p>Example:</p> <pre><code>[&lt;Tests&gt;]\nlet myTests =\n    describe \"Feature\" [\n        it \"works\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Tests are immutable tree structures built at declaration time</li> <li>Tests are not executed during building, only when the runner executes them</li> <li>Mark test functions with <code>[&lt;Tests&gt;]</code> attribute for discovery</li> <li>Test discovery works with both <code>TestNode</code> and <code>TestNode list</code> types</li> </ul>"},{"location":"reference/dsl-api/#describe","title":"describe","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Groups related tests together with a description.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the group</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>describe \"description\" [\n    // child tests\n]\n</code></pre> <p>Example:</p> <pre><code>describe \"Calculator\" [\n    describe \"addition\" [\n        it \"adds positive numbers\" (fun () -&gt;\n            expect(2 + 3).toEqual(5)\n        )\n    ]\n\n    describe \"subtraction\" [\n        it \"subtracts numbers\" (fun () -&gt;\n            expect(5 - 3).toEqual(2)\n        )\n    ]\n]\n</code></pre> <p>Output:</p> <pre><code>Calculator\n  addition\n    \u2713 adds positive numbers\n  subtraction\n    \u2713 subtracts numbers\n</code></pre> <p>Notes:</p> <ul> <li><code>describe</code> blocks can be nested arbitrarily deep</li> <li>Use <code>describe</code> for grouping by feature, class, or module</li> <li>Descriptions should be clear and descriptive</li> </ul>"},{"location":"reference/dsl-api/#context","title":"context","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Alias for <code>describe</code> that reads better when describing context or state.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the context</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>context \"when something is true\" [\n    // tests in this context\n]\n</code></pre> <p>Example:</p> <pre><code>describe \"Stack\" [\n    context \"when empty\" [\n        it \"has zero count\" (fun () -&gt;\n            let stack = Stack&lt;int&gt;()\n            expect(stack.Count).toEqual(0)\n        )\n    ]\n\n    context \"when not empty\" [\n        it \"has non-zero count\" (fun () -&gt;\n            let stack = Stack&lt;int&gt;()\n            stack.Push(1)\n            expect(stack.Count).toEqual(1)\n        )\n    ]\n]\n</code></pre> <p>Notes:</p> <ul> <li>Functionally identical to <code>describe</code></li> <li>Use <code>context</code> for \"when\" or \"with\" scenarios</li> <li>Improves readability in BDD-style tests</li> </ul>"},{"location":"reference/dsl-api/#it","title":"it","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Defines an individual specification that describes a single behavior.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the expected behavior (reads like documentation)</li> <li><code>test</code> - Function that verifies the behavior</li> </ul> <p>Usage:</p> <pre><code>it \"description of expected behavior\" (fun () -&gt;\n    // verification code\n)\n</code></pre> <p>Example:</p> <pre><code>it \"calculates the sum of two positive integers\" (fun () -&gt;\n    let result = Calculator.add 2 3\n    expect(result).toEqual(5)\n)\n\nit \"raises an exception when input is invalid\" (fun () -&gt;\n    expectThrows&lt;ArgumentException&gt;(fun () -&gt;\n        Calculator.divide 10 0 |&gt; ignore\n    )\n)\n</code></pre> <p>Writing Good Specifications:</p> <ul> <li>Describe what the code does, not how it does it</li> <li>Write complete sentences: \"returns X when Y\" not just \"test add\"</li> <li>Focus on one behavior per specification</li> <li>Use business/domain language, not technical jargon</li> </ul> <p>Notes:</p> <ul> <li>Test function must be wrapped in <code>fun () -&gt;</code> for lazy evaluation</li> <li>Descriptions should start with a verb (e.g., \"returns\", \"throws\", \"creates\", \"validates\")</li> <li>If the test function throws an exception, the test fails</li> </ul>"},{"location":"reference/dsl-api/#itasync","title":"itAsync","text":"<p>Type: <code>string -&gt; Async&lt;unit&gt; -&gt; TestNode</code></p> <p>Defines an asynchronous test case that runs in an async workflow.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing what the test does</li> <li><code>test</code> - Async computation that performs assertions</li> </ul> <p>Usage:</p> <pre><code>itAsync \"description\" (async {\n    // async test code\n})\n</code></pre> <p>Example:</p> <pre><code>itAsync \"fetches user data\" (async {\n    let! user = getUserAsync 123\n    expectOption(user).toBeSome()\n})\n</code></pre> <p>With Task Interop:</p> <pre><code>itAsync \"calls HTTP API\" (async {\n    use client = new HttpClient()\n    let! response = client.GetAsync(\"https://api.example.com/users\") |&gt; Async.AwaitTask\n    expectHttp(response).toHaveStatusOk()\n})\n</code></pre> <p>With Result Types:</p> <pre><code>itAsync \"validates async operation\" (async {\n    let! result = processDataAsync(data)\n    expectResult(result).toBeOk()\n})\n</code></pre> <p>Notes:</p> <ul> <li>Use for tests that perform I/O operations (database, HTTP, file system)</li> <li>Test runs using <code>Async.RunSynchronously</code> internally</li> <li>Can use <code>let!</code> to await async operations</li> <li>Can use <code>Async.AwaitTask</code> to work with .NET Task-based APIs</li> <li>Compatible with all FX.Spec matchers and hooks</li> <li>Can mix <code>it</code> and <code>itAsync</code> in the same test suite</li> </ul>"},{"location":"reference/dsl-api/#async-testing-patterns","title":"Async Testing Patterns","text":""},{"location":"reference/dsl-api/#http-api-testing","title":"HTTP API Testing","text":"<pre><code>open System.Net.Http\nopen FX.Spec.Http\n\ndescribe \"User API\" [\n    let client = new HttpClient(BaseAddress = Uri(\"http://localhost:5000\"))\n\n    itAsync \"creates user successfully\" (async {\n        let json = \"\"\"{\"name\":\"John\",\"email\":\"john@example.com\"}\"\"\"\n        let content = new StringContent(json, Encoding.UTF8, \"application/json\")\n        let! response = client.PostAsync(\"/api/users\", content) |&gt; Async.AwaitTask\n\n        expectHttp(response).toHaveStatusCreated()\n        expectHttp(response).toHaveJsonBody({| id = 1; name = \"John\" |})\n    })\n\n    itAsync \"retrieves user by ID\" (async {\n        let! response = client.GetAsync(\"/api/users/1\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#database-operations","title":"Database Operations","text":"<pre><code>describe \"User Repository\" [\n    let connectionString = \"Server=localhost;Database=test\"\n\n    itAsync \"saves user to database\" (async {\n        use! connection = openConnectionAsync(connectionString)\n        let! result = repository.SaveAsync(connection, newUser)\n        expectResult(result).toBeOk()\n    })\n\n    itAsync \"retrieves user from database\" (async {\n        use! connection = openConnectionAsync(connectionString)\n        let! user = repository.GetAsync(connection, userId)\n        expectOption(user).toBeSome()\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#async-result-patterns","title":"Async Result Patterns","text":"<pre><code>describe \"Async Result Workflows\" [\n    itAsync \"handles successful async operation\" (async {\n        let! result = fetchDataAsync(validId)\n        expectResult(result).toBeOk()\n    })\n\n    itAsync \"handles async errors\" (async {\n        let! result = fetchDataAsync(invalidId)\n        expectResult(result).toBeError()\n    })\n\n    itAsync \"chains async Result operations\" (async {\n        let! result = \n            validateInputAsync(data)\n            |&gt; AsyncResult.bind processDataAsync\n            |&gt; AsyncResult.bind saveToDbAsync\n\n        expectResult(result).toBeOk()\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#parallel-async-operations","title":"Parallel Async Operations","text":"<pre><code>describe \"Parallel Operations\" [\n    itAsync \"runs multiple operations in parallel\" (async {\n        let! results = \n            [1..10]\n            |&gt; List.map (fun id -&gt; fetchUserAsync id)\n            |&gt; Async.Parallel\n\n        expectSeq(results).toHaveLength(10)\n    })\n\n    itAsync \"handles parallel failures gracefully\" (async {\n        let operations = [\n            fetchUserAsync 1\n            fetchUserAsync 999  // This will fail\n            fetchUserAsync 3\n        ]\n\n        let! results = Async.Parallel operations\n        expectSeq(results |&gt; Array.filter Result.isOk).toHaveLength(2)\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#file-io","title":"File I/O","text":"<pre><code>describe \"File Operations\" [\n    itAsync \"reads file asynchronously\" (async {\n        let! content = File.ReadAllTextAsync(\"test.txt\") |&gt; Async.AwaitTask\n        expectStr(content).toContain(\"expected text\")\n    })\n\n    itAsync \"writes file asynchronously\" (async {\n        let! _ = File.WriteAllTextAsync(\"output.txt\", \"test\") |&gt; Async.AwaitTask\n        let! content = File.ReadAllTextAsync(\"output.txt\") |&gt; Async.AwaitTask\n        expectStr(content).toEqual(\"test\")\n    })\n]\n</code></pre>"},{"location":"reference/dsl-api/#async-hooks","title":"Async Hooks","text":"<p>Hooks can be async-aware when working with async tests:</p> <pre><code>describe \"Integration Tests\" [\n    let mutable client = Unchecked.defaultof&lt;HttpClient&gt;\n\n    beforeEach (fun () -&gt;\n        client &lt;- new HttpClient(BaseAddress = Uri(\"http://localhost:5000\"))\n    )\n\n    afterEach (fun () -&gt;\n        client.Dispose()\n    )\n\n    itAsync \"test 1\" (async {\n        let! response = client.GetAsync(\"/health\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n\n    itAsync \"test 2\" (async {\n        let! response = client.GetAsync(\"/api/users\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n]\n</code></pre> <p>Notes on Async Testing: - <code>itAsync</code> internally uses <code>Async.RunSynchronously</code>, so tests still run synchronously at the top level - Use <code>Async.AwaitTask</code> to convert .NET Tasks to F# Async - Async tests can be focused with <code>fitAsync</code> or skipped with <code>xitAsync</code> - Async tests work with all lifecycle hooks (<code>beforeEach</code>, <code>afterEach</code>, etc.) - Mix sync and async tests freely in the same suite</p>"},{"location":"reference/dsl-api/#focus-pending","title":"Focus &amp; Pending","text":""},{"location":"reference/dsl-api/#fit","title":"fit","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Focused test - runs only this test when focused tests exist.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function that performs assertions</li> </ul> <p>Usage:</p> <pre><code>fit \"only run this test\" (fun () -&gt;\n    expectBool(true).toBeTrue()\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"My Suite\" [\n    fit \"work on this test\" (fun () -&gt;  // Only this runs\n        expect(2 + 2).toEqual(4)\n    )\n\n    it \"this is skipped\" (fun () -&gt;    // Skipped\n        expectBool(true).toBeTrue()\n    )\n]\n</code></pre> <p>Output:</p> <pre><code>My Suite\n  \u2713 work on this test\n  \u2298 this is skipped (not focused)\n</code></pre> <p>Notes:</p> <ul> <li>Use during development to focus on specific tests</li> <li>When any <code>fit</code> or <code>fdescribe</code> exists, unfocused tests are skipped</li> <li>Remove all <code>fit</code> before committing code</li> <li>Multiple <code>fit</code> tests can exist - all focused tests run</li> </ul>"},{"location":"reference/dsl-api/#fdescribe","title":"fdescribe","text":"<p>Type: <code>string -&gt; TestNode list -&gt; TestNode</code></p> <p>Focused group - runs only tests in focused groups.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the group</li> <li><code>tests</code> - List of child test nodes</li> </ul> <p>Usage:</p> <pre><code>fdescribe \"only run this group\" [\n    // all tests in this group run\n]\n</code></pre> <p>Example:</p> <pre><code>spec {\n    fdescribe \"Work on Calculator\" [  // This group runs\n        it \"test 1\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n        it \"test 2\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n\n    describe \"Other Feature\" [        // This group is skipped\n        it \"test 3\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n    ]\n}\n</code></pre> <p>Notes:</p> <ul> <li>All tests within <code>fdescribe</code> run</li> <li>Tests outside <code>fdescribe</code> are skipped</li> <li>Can be nested - inner <code>fdescribe</code> focuses further</li> <li>Remove before committing</li> </ul>"},{"location":"reference/dsl-api/#xit","title":"xit","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Excluded test - skips this test.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function (not executed)</li> </ul> <p>Usage:</p> <pre><code>xit \"not ready yet\" (fun () -&gt;\n    // this code doesn't run\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Feature\" [\n    it \"working test\" (fun () -&gt;\n        expectBool(true).toBeTrue()\n    )\n\n    xit \"broken test\" (fun () -&gt;  // Skipped\n        expectBool(false).toBeTrue()\n    )\n]\n</code></pre> <p>Output:</p> <pre><code>Feature\n  \u2713 working test\n  \u2298 broken test\n</code></pre> <p>Notes:</p> <ul> <li>Use for temporarily disabling broken tests</li> <li>Test function is never executed</li> <li>Skipped tests are reported in the summary</li> <li>Better than commenting out tests (maintains test count)</li> </ul>"},{"location":"reference/dsl-api/#xitasync","title":"xitAsync","text":"<p>Type: <code>string -&gt; Async&lt;unit&gt; -&gt; TestNode</code></p> <p>Excluded async test - skips this async test.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Async computation (not executed)</li> </ul> <p>Usage:</p> <pre><code>xitAsync \"not ready yet\" (async {\n    // this code doesn't run\n})\n</code></pre> <p>Example:</p> <pre><code>describe \"API Tests\" [\n    itAsync \"working test\" (async {\n        let! response = client.GetAsync(\"/api/users\") |&gt; Async.AwaitTask\n        expectHttp(response).toHaveStatusOk()\n    })\n\n    xitAsync \"broken async test\" (async {  // Skipped\n        let! data = failingOperationAsync()\n        expectResult(data).toBeOk()\n    })\n]\n</code></pre> <p>Notes:</p> <ul> <li>Same behavior as <code>xit</code> but for async tests</li> <li>Use for temporarily disabling broken async tests</li> <li>Test computation is never executed</li> </ul>"},{"location":"reference/dsl-api/#pending","title":"pending","text":"<p>Type: <code>string -&gt; (unit -&gt; unit) -&gt; TestNode</code></p> <p>Alias for <code>xit</code> that reads better for unfinished tests.</p> <p>Parameters:</p> <ul> <li><code>description</code> - String describing the test</li> <li><code>test</code> - Function (not executed)</li> </ul> <p>Usage:</p> <pre><code>pending \"TODO: implement this test\" (fun () -&gt;\n    ()\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Feature\" [\n        it \"implemented test\" (fun () -&gt;\n            expectBool(true).toBeTrue()\n        )\n\n        pending \"write test for edge case\" (fun () -&gt;\n            ()\n        )\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Functionally identical to <code>xit</code></li> <li>Use for planned but unimplemented tests</li> <li>Can pass empty function <code>(fun () -&gt; ())</code></li> </ul>"},{"location":"reference/dsl-api/#lifecycle-hooks","title":"Lifecycle Hooks","text":""},{"location":"reference/dsl-api/#beforeeach","title":"beforeEach","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs before each test in the current group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run before each test</li> </ul> <p>Usage:</p> <pre><code>beforeEach (fun () -&gt;\n    // setup code\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Database Tests\" [\n        let mutable connection = null\n\n        beforeEach (fun () -&gt;\n            connection &lt;- Database.connect()\n            connection.BeginTransaction()\n        )\n\n        afterEach (fun () -&gt;\n            connection.RollbackTransaction()\n            connection.Dispose()\n        )\n\n        it \"queries data\" (fun () -&gt;\n            let result = connection.Query(\"SELECT 1\")\n            expect result |&gt; shouldNot beEmpty\n        )\n\n        it \"inserts data\" (fun () -&gt;\n            connection.Execute(\"INSERT INTO users VALUES (1, 'test')\")\n            let count = connection.Query(\"SELECT COUNT(*) FROM users\")\n            expect(count).toEqual(1)\n        )\n    ]\n</code></pre> <p>Execution Order:</p> <pre><code>beforeEach \u2192 test 1 \u2192 afterEach\nbeforeEach \u2192 test 2 \u2192 afterEach\n</code></pre> <p>Notes:</p> <ul> <li>Runs before each test in the group</li> <li>Useful for test isolation and setup</li> <li>Can access mutable variables from outer scope</li> <li>Multiple <code>beforeEach</code> hooks run in order of definition</li> </ul>"},{"location":"reference/dsl-api/#aftereach","title":"afterEach","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs after each test in the current group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run after each test</li> </ul> <p>Usage:</p> <pre><code>afterEach (fun () -&gt;\n    // cleanup code\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"File Tests\" [\n        let testFile = \"test.txt\"\n\n        beforeEach (fun () -&gt;\n            File.WriteAllText(testFile, \"test content\")\n        )\n\n        afterEach (fun () -&gt;\n            if File.Exists(testFile) then\n                File.Delete(testFile)\n        )\n\n        it \"reads file\" (fun () -&gt;\n            let content = File.ReadAllText(testFile)\n            expect(content).toEqual(\"test content\")\n        )\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Runs after each test, even if test fails</li> <li>Use for cleanup and resource disposal</li> <li>Guaranteed to run (unless unhandled exception in beforeEach)</li> </ul>"},{"location":"reference/dsl-api/#beforeall","title":"beforeAll","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs once before all tests in the group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run once before tests</li> </ul> <p>Usage:</p> <pre><code>beforeAll (fun () -&gt;\n    // expensive setup\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"API Tests\" [\n        let mutable server = null\n\n        beforeAll (fun () -&gt;\n            server &lt;- TestServer.start()\n            server.SeedDatabase()\n        )\n\n        afterAll (fun () -&gt;\n            server.Stop()\n        )\n\n        it \"test 1\" (fun () -&gt;\n            let response = server.Get(\"/api/users\")\n            expect(response.Status).toEqual(200)\n        )\n\n        it \"test 2\" (fun () -&gt;\n            let response = server.Post(\"/api/users\", { Name = \"test\" })\n            expect(response.Status).toEqual(201)\n        )\n    ]\n</code></pre> <p>Execution Order:</p> <pre><code>beforeAll \u2192 test 1 \u2192 test 2 \u2192 afterAll\n</code></pre> <p>Notes:</p> <ul> <li>Runs only once before all tests in the group</li> <li>Use for expensive setup (database seeding, server start, etc.)</li> <li>Shared state across tests (be careful of test isolation)</li> </ul>"},{"location":"reference/dsl-api/#afterall","title":"afterAll","text":"<p>Type: <code>(unit -&gt; unit) -&gt; TestNode</code></p> <p>Runs once after all tests in the group.</p> <p>Parameters:</p> <ul> <li><code>action</code> - Function to run once after all tests</li> </ul> <p>Usage:</p> <pre><code>afterAll (fun () -&gt;\n    // cleanup expensive resources\n)\n</code></pre> <p>Example:</p> <pre><code>describe \"Integration Tests\" [\n        let mutable dockerContainer = null\n\n        beforeAll (fun () -&gt;\n            dockerContainer &lt;- Docker.startContainer(\"postgres:15\")\n        )\n\n        afterAll (fun () -&gt;\n            Docker.stopContainer(dockerContainer)\n        )\n\n        // tests...\n    ]\n</code></pre> <p>Notes:</p> <ul> <li>Runs only once after all tests in the group</li> <li>Use for expensive cleanup</li> <li>Guaranteed to run even if tests fail</li> </ul>"},{"location":"reference/dsl-api/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive example using all DSL features with specification-focused descriptions:</p> <pre><code>module UserServiceSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet userServiceSpecs =\n    describe \"UserService user management\" [\n        let mutable service = null\n        let mutable db = null\n\n        beforeAll (fun () -&gt;\n            db &lt;- Database.createInMemory()\n        )\n\n        afterAll (fun () -&gt;\n            db.Dispose()\n        )\n\n        beforeEach (fun () -&gt;\n            db.Clear()\n            service &lt;- UserService(db)\n        )\n\n        context \"when creating a new user account\" [\n            context \"with valid registration data\" [\n                it \"creates a user account with the provided name and email\" (fun () -&gt;\n                    let user = service.CreateUser(\"Alice\", \"alice@example.com\")\n                    expect(user.Name).toEqual(\"Alice\")\n                    expect(user.Email).toEqual(\"alice@example.com\")\n                )\n\n                it \"assigns a unique identifier to the new user\" (fun () -&gt;\n                    let user = service.CreateUser(\"Bob\", \"bob@example.com\")\n                    expectNum(user.Id).toBeGreaterThan(0)\n                )\n            ]\n\n            context \"with invalid registration data\" [\n                it \"rejects registration when name is empty\" (fun () -&gt;\n                    expectThrows&lt;ArgumentException&gt;(fun () -&gt;\n                        service.CreateUser(\"\", \"test@example.com\") |&gt; ignore\n                    )\n                )\n\n                xit \"validates email format before accepting registration\" (fun () -&gt;\n                    // TODO: implement email validation\n                    expectThrows&lt;ArgumentException&gt;(fun () -&gt;\n                        service.CreateUser(\"Test\", \"invalid-email\") |&gt; ignore\n                    )\n                )\n            ]\n        ]\n\n        context \"when retrieving user information\" [\n            it \"returns the user account when ID exists in system\" (fun () -&gt;\n                let created = service.CreateUser(\"Charlie\", \"charlie@example.com\")\n                let retrieved = service.GetUser(created.Id)\n                expectOption(retrieved).toBeSome(created)\n            )\n\n            it \"returns None when requested user ID does not exist\" (fun () -&gt;\n                let result = service.GetUser(9999)\n                expectOption(result).toBeNone()\n            )\n        ]\n    ]\n</code></pre>"},{"location":"reference/dsl-api/#best-practices","title":"Best Practices","text":""},{"location":"reference/dsl-api/#writing-specifications-as-documentation","title":"Writing Specifications as Documentation","text":"<pre><code>// Good - Reads like documentation\ndescribe \"User authentication system\"\nit \"allows login with valid credentials\"\nit \"locks account after three failed login attempts\"\ncontext \"when password has expired\"\n\n// Avoid - Too technical or vague\ndescribe \"AuthService tests\"\nit \"test_login\"\nit \"edge case 1\"\ncontext \"scenario A\"\n</code></pre> <p>Tips for good specifications: - Use business domain language - Write what the system does, not what the code does - Complete sentences that non-developers can understand - Focus on behavior, not implementation</p>"},{"location":"reference/dsl-api/#organizing-specifications","title":"Organizing Specifications","text":"<pre><code>describe \"Feature or Component Name\" [     // Top: What you're documenting\n    context \"under specific conditions\" [  // Middle: When/where\n        it \"expected observable behavior\" (fun () -&gt; ...) // Bottom: What happens\n    ]\n]\n</code></pre> <p>Example hierarchy: <pre><code>describe \"Shopping cart\" [\n    context \"when cart is empty\" [\n        it \"displays a message prompting user to add items\" (fun () -&gt; ...)\n        it \"disables the checkout button\" (fun () -&gt; ...)\n    ]\n\n    context \"when cart contains items\" [\n        it \"calculates the correct total including tax\" (fun () -&gt; ...)\n        it \"enables the checkout button\" (fun () -&gt; ...)\n    ]\n]\n</code></pre></p>"},{"location":"reference/dsl-api/#hook-usage","title":"Hook Usage","text":"<ul> <li>Use <code>beforeEach</code>/<code>afterEach</code> for test isolation</li> <li>Use <code>beforeAll</code>/<code>afterAll</code> for expensive setup</li> <li>Keep hooks simple and focused</li> <li>Avoid complex logic in hooks</li> </ul>"},{"location":"reference/dsl-api/#focus-pending_1","title":"Focus &amp; Pending","text":"<ul> <li>Use <code>fit</code>/<code>fdescribe</code> temporarily during development</li> <li>Always remove before committing</li> <li>Use <code>xit</code>/<code>pending</code> to track incomplete tests</li> <li>Document why tests are pending</li> </ul>"},{"location":"reference/dsl-api/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Get started with FX.Spec</li> <li>Matchers Reference - Learn about assertions</li> <li>Contributing - Contribute to FX.Spec</li> </ul>"},{"location":"reference/http/","title":"HTTP Testing","text":"<p>FX.Spec provides a fluent API for testing HTTP responses with comprehensive matchers for status codes, headers, and body content.</p>"},{"location":"reference/http/#overview","title":"Overview","text":"<p>The <code>expectHttp()</code> function creates an HTTP response expectation that provides type-safe, chainable matchers specifically designed for testing web APIs and HTTP services.</p> <pre><code>open FX.Spec.Http\n\nitAsync \"tests API response\" (async {\n    let! response = client.GetAsync(\"/api/users\")\n    expectHttp(response).toHaveStatusOk()\n})\n</code></pre>"},{"location":"reference/http/#status-code-matchers","title":"Status Code Matchers","text":""},{"location":"reference/http/#tohavestatuscode-int","title":"toHaveStatus(code: int)","text":"<p>Asserts that the HTTP response has the specified status code.</p> <pre><code>expectHttp(response).toHaveStatus(200)\nexpectHttp(response).toHaveStatus(404)\nexpectHttp(response).toHaveStatus(500)\n</code></pre>"},{"location":"reference/http/#semantic-status-matchers","title":"Semantic Status Matchers","text":"<p>FX.Spec provides semantic matchers for common HTTP status codes:</p> Matcher Status Code Description <code>toHaveStatusOk()</code> 200 OK <code>toHaveStatusCreated()</code> 201 Created <code>toHaveStatusNoContent()</code> 204 No Content <code>toHaveStatusBadRequest()</code> 400 Bad Request <code>toHaveStatusUnauthorized()</code> 401 Unauthorized <code>toHaveStatusNotFound()</code> 404 Not Found <code>toHaveStatusUnprocessableEntity()</code> 422 Unprocessable Entity <code>toHaveStatusInternalServerError()</code> 500 Internal Server Error <pre><code>describe \"User API\" [\n    itAsync \"creates user successfully\" (async {\n        let! response = client.PostAsync(\"/api/users\", content)\n        expectHttp(response).toHaveStatusCreated()\n    })\n\n    itAsync \"returns 404 for missing user\" (async {\n        let! response = client.GetAsync(\"/api/users/999\")\n        expectHttp(response).toHaveStatusNotFound()\n    })\n\n    itAsync \"requires authentication\" (async {\n        let! response = client.GetAsync(\"/api/admin\")\n        expectHttp(response).toHaveStatusUnauthorized()\n    })\n]\n</code></pre>"},{"location":"reference/http/#header-matchers","title":"Header Matchers","text":""},{"location":"reference/http/#tohaveheadername-string-value-string","title":"toHaveHeader(name: string, value: string)","text":"<p>Asserts that the response contains a header with the specified name and exact value.</p> <pre><code>expectHttp(response).toHaveHeader(\"Content-Type\", \"application/json\")\nexpectHttp(response).toHaveHeader(\"X-Custom-Header\", \"custom-value\")\n</code></pre>"},{"location":"reference/http/#tohaveheadername-string","title":"toHaveHeader(name: string)","text":"<p>Asserts that the response contains a header with the specified name (regardless of value).</p> <pre><code>expectHttp(response).toHaveHeader(\"ETag\")\nexpectHttp(response).toHaveHeader(\"X-Request-Id\")\n</code></pre>"},{"location":"reference/http/#tohavecontenttypemediatype-string","title":"toHaveContentType(mediaType: string)","text":"<p>Convenience method for asserting the Content-Type header. Automatically handles charset and other parameters.</p> <pre><code>expectHttp(response).toHaveContentType(\"application/json\")\nexpectHttp(response).toHaveContentType(\"text/html\")\nexpectHttp(response).toHaveContentType(\"application/xml\")\n</code></pre> <p>Example:</p> <pre><code>describe \"API Content Types\" [\n    itAsync \"returns JSON for API requests\" (async {\n        let! response = client.GetAsync(\"/api/users\")\n        expectHttp(response)\n            .toHaveStatusOk()\n            .toHaveContentType(\"application/json\")\n    })\n\n    itAsync \"includes custom headers\" (async {\n        let! response = client.GetAsync(\"/api/users\")\n        expectHttp(response)\n            .toHaveHeader(\"X-API-Version\", \"1.0\")\n            .toHaveHeader(\"X-Rate-Limit-Remaining\")\n    })\n]\n</code></pre>"},{"location":"reference/http/#body-matchers","title":"Body Matchers","text":""},{"location":"reference/http/#tohavebodyexpected-string","title":"toHaveBody(expected: string)","text":"<p>Asserts that the response body exactly matches the expected string.</p> <pre><code>expectHttp(response).toHaveBody(\"Hello, World!\")\nexpectHttp(response).toHaveBody(\"\")  // Empty body\n</code></pre>"},{"location":"reference/http/#tohavebodycontainingsubstring-string","title":"toHaveBodyContaining(substring: string)","text":"<p>Asserts that the response body contains the specified substring (case-sensitive).</p> <pre><code>expectHttp(response).toHaveBodyContaining(\"success\")\nexpectHttp(response).toHaveBodyContaining(\"error\")\nexpectHttp(response).toHaveBodyContaining(\"user123\")\n</code></pre>"},{"location":"reference/http/#tohavejsonbodytexpected-t","title":"toHaveJsonBody&lt;'T&gt;(expected: 'T)","text":"<p>Asserts that the response body is valid JSON that deserializes to the expected value. Automatically normalizes JSON formatting for comparison.</p> <pre><code>// Anonymous records\nexpectHttp(response).toHaveJsonBody({| name = \"John\"; age = 30 |})\n\n// Complex objects\nexpectHttp(response).toHaveJsonBody({| \n    users = [| {| id = 1 |}; {| id = 2 |} |]\n    count = 2 \n|})\n\n// Custom types\ntype User = { Id: int; Name: string; Email: string }\nexpectHttp(response).toHaveJsonBody({ Id = 1; Name = \"John\"; Email = \"john@example.com\" })\n</code></pre> <p>Example:</p> <pre><code>describe \"API Response Bodies\" [\n    itAsync \"returns JSON user data\" (async {\n        let! response = client.GetAsync(\"/api/users/1\")\n        expectHttp(response)\n            .toHaveStatusOk()\n            .toHaveJsonBody({| \n                id = 1\n                name = \"John Doe\"\n                email = \"john@example.com\"\n            |})\n    })\n\n    itAsync \"returns error message\" (async {\n        let! response = client.GetAsync(\"/api/users/invalid\")\n        expectHttp(response)\n            .toHaveStatusBadRequest()\n            .toHaveBodyContaining(\"Invalid user ID\")\n    })\n]\n</code></pre>"},{"location":"reference/http/#multiple-assertions","title":"Multiple Assertions","text":"<p>You can call multiple assertions on the same expectation:</p> <pre><code>describe \"Complete API Test\" [\n    itAsync \"validates full response\" (async {\n        let! response = client.PostAsync(\"/api/users\", content)\n\n        let expectation = expectHttp(response)\n        expectation.toHaveStatusCreated()\n        expectation.toHaveHeader(\"Location\", \"/api/users/123\")\n        expectation.toHaveContentType(\"application/json\")\n        expectation.toHaveBodyContaining(\"\\\"id\\\":123\")\n        expectation.toHaveJsonBody({| id = 123; name = \"John\" |})\n    })\n]\n</code></pre>"},{"location":"reference/http/#async-http-testing","title":"Async HTTP Testing","text":"<p>FxSpec's <code>itAsync</code> works seamlessly with F#'s <code>async</code> workflows and .NET's <code>Task</code>-based APIs:</p> <pre><code>open System.Net.Http\nopen System.Text\nopen FX.Spec.Http\n\ndescribe \"User API Integration Tests\" [\n    let client = new HttpClient(BaseAddress = Uri(\"http://localhost:5000\"))\n\n    itAsync \"creates and retrieves user\" (async {\n        // Create user\n        let json = \"\"\"{\"name\":\"Jane\",\"email\":\"jane@example.com\"}\"\"\"\n        let content = new StringContent(json, Encoding.UTF8, \"application/json\")\n        let! createResponse = client.PostAsync(\"/api/users\", content) |&gt; Async.AwaitTask\n\n        expectHttp(createResponse)\n            .toHaveStatusCreated()\n            .toHaveHeader(\"Location\")\n\n        // Retrieve user\n        let! getResponse = client.GetAsync(\"/api/users/1\") |&gt; Async.AwaitTask\n        expectHttp(getResponse)\n            .toHaveStatusOk()\n            .toHaveJsonBody({| id = 1; name = \"Jane\"; email = \"jane@example.com\" |})\n    })\n\n    itAsync \"handles validation errors\" (async {\n        let json = \"\"\"{\"name\":\"\"}\"\"\"  // Invalid: empty name\n        let content = new StringContent(json, Encoding.UTF8, \"application/json\")\n        let! response = client.PostAsync(\"/api/users\", content) |&gt; Async.AwaitTask\n\n        expectHttp(response)\n            .toHaveStatusBadRequest()\n            .toHaveBodyContaining(\"Name is required\")\n    })\n]\n</code></pre>"},{"location":"reference/http/#error-messages","title":"Error Messages","text":"<p>FX.Spec provides clear, actionable error messages when HTTP assertions fail:</p>"},{"location":"reference/http/#status-code-mismatch","title":"Status Code Mismatch","text":"<pre><code>Expected HTTP status 200, but got 404\nExpected: 200\nActual: 404\n</code></pre>"},{"location":"reference/http/#header-mismatch","title":"Header Mismatch","text":"<pre><code>Expected header 'Content-Type' to have value 'application/json', but got 'text/html'\nExpected: application/json\nActual: text/html\n</code></pre>"},{"location":"reference/http/#missing-header","title":"Missing Header","text":"<pre><code>Expected header 'X-Custom-Header' not found in response\nExpected: X-Custom-Header\n</code></pre>"},{"location":"reference/http/#body-mismatch","title":"Body Mismatch","text":"<pre><code>Expected body to contain 'success', but it was not found.\n\nActual body:\n{\"status\":\"error\",\"message\":\"Something went wrong\"}\n</code></pre>"},{"location":"reference/http/#json-body-mismatch","title":"JSON Body Mismatch","text":"<pre><code>Expected JSON body:\n{\"id\":1,\"name\":\"John\"}\n\nActual JSON body:\n{\"id\":1,\"name\":\"Jane\"}\n</code></pre>"},{"location":"reference/http/#migration-guide-old-api-to-new-api","title":"Migration Guide: Old API to New API","text":"<p>FX.Spec previously used a <code>should</code>-based API. The new <code>expectHttp()</code> API is more consistent with the rest of the framework and provides better error messages.</p>"},{"location":"reference/http/#old-api-deprecated","title":"Old API (Deprecated)","text":"<pre><code>// Old style - still works but deprecated\nresponse |&gt; should (haveStatus beOk)\nresponse |&gt; should (haveHeader \"Content-Type\" \"application/json\")\nresponse |&gt; shouldBeOk\nresponse |&gt; shouldHaveJsonBody expected\n</code></pre>"},{"location":"reference/http/#new-api-recommended","title":"New API (Recommended)","text":"<pre><code>// New style - fluent and consistent\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveHeader(\"Content-Type\", \"application/json\")\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveJsonBody(expected)\n</code></pre>"},{"location":"reference/http/#migration-steps","title":"Migration Steps","text":"<ol> <li>Replace <code>response |&gt; should (haveStatus beOk)</code> with <code>expectHttp(response).toHaveStatusOk()</code></li> <li>Replace <code>response |&gt; shouldBeOk</code> with <code>expectHttp(response).toHaveStatusOk()</code></li> <li>Replace <code>response |&gt; should (haveHeader name value)</code> with <code>expectHttp(response).toHaveHeader(name, value)</code></li> <li>Replace <code>response |&gt; shouldHaveJsonBody expected</code> with <code>expectHttp(response).toHaveJsonBody(expected)</code></li> </ol> <p>The old API will be maintained for backward compatibility but may be removed in a future major version.</p>"},{"location":"reference/http/#best-practices","title":"Best Practices","text":""},{"location":"reference/http/#1-use-semantic-status-matchers","title":"1. Use Semantic Status Matchers","text":"<p>Prefer semantic matchers over numeric codes for better readability:</p> <pre><code>// Good\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveStatusNotFound()\n\n// Works, but less expressive\nexpectHttp(response).toHaveStatus(200)\nexpectHttp(response).toHaveStatus(404)\n</code></pre>"},{"location":"reference/http/#2-check-status-before-body","title":"2. Check Status Before Body","text":"<p>Always verify the status code before asserting on body content:</p> <pre><code>// Good\nexpectHttp(response).toHaveStatusOk()\nexpectHttp(response).toHaveBodyContaining(\"success\")\n\n// Risky - might fail on wrong status\nexpectHttp(response).toHaveBodyContaining(\"success\")\n</code></pre>"},{"location":"reference/http/#3-use-tohavejsonbody-for-json-apis","title":"3. Use toHaveJsonBody for JSON APIs","text":"<p>For JSON responses, use <code>toHaveJsonBody</code> instead of string comparisons:</p> <pre><code>// Good - type-safe, handles formatting\nexpectHttp(response).toHaveJsonBody({| id = 1; name = \"John\" |})\n\n// Fragile - whitespace sensitive\nexpectHttp(response).toHaveBody(\"\"\"{\"id\":1,\"name\":\"John\"}\"\"\")\n</code></pre>"},{"location":"reference/http/#4-store-expectation-for-multiple-assertions","title":"4. Store Expectation for Multiple Assertions","text":"<p>When making multiple assertions, store the expectation:</p> <pre><code>let expectation = expectHttp(response)\nexpectation.toHaveStatusOk()\nexpectation.toHaveContentType(\"application/json\")\nexpectation.toHaveBodyContaining(\"data\")\n</code></pre>"},{"location":"reference/http/#see-also","title":"See Also","text":"<ul> <li>Async Support - Using <code>itAsync</code> for asynchronous tests</li> <li>Core Matchers - General-purpose matchers</li> <li>Quick Start - Getting started with FX.Spec</li> </ul>"},{"location":"reference/json-api/","title":"JSON:API Testing","text":"<p>FX.Spec provides dedicated support for testing APIs that adhere to the JSON:API specification.</p>"},{"location":"reference/json-api/#overview","title":"Overview","text":"<p>The <code>FX.Spec.JsonApi</code> package extends the core JSON testing capabilities with semantic matchers for resources, relationships, includes, and sorting. It abstracts away the complex structure of JSON:API documents (data, included, relationships) so you can test the content of your API.</p> <pre><code>open FX.Spec.JsonApi\n\nit \"returns the article with author\" (fun () -&gt;\n    expectJsonApi(json)\n        .toHaveRelationship(\"author\", \"people\", \"9\")\n        .toHaveIncludedResource(\"people\", \"9\")\n)\n</code></pre>"},{"location":"reference/json-api/#installation","title":"Installation","text":"<p>Add the JSON:API package to your test project:</p> <pre><code>dotnet add package FX.Spec.JsonApi\n</code></pre>"},{"location":"reference/json-api/#core-matchers","title":"Core Matchers","text":""},{"location":"reference/json-api/#expectjsonapijson-string","title":"<code>expectJsonApi(json: string)</code>","text":"<p>Creates an expectation wrapper specifically for JSON:API documents.</p>"},{"location":"reference/json-api/#resource-identifiers","title":"Resource Identifiers","text":""},{"location":"reference/json-api/#toberesourceidentifierpath-string-type-string-id-string","title":"<code>toBeResourceIdentifier(path: string, type: string, id: string)</code>","text":"<p>Asserts that the object at the specified path is a valid Resource Identifier Object containing the correct <code>type</code> and <code>id</code>.</p> <pre><code>// Check the primary data\nexpectJsonApi(json).toBeResourceIdentifier(\"data\", \"articles\", \"1\")\n\n// Check nested data\nexpectJsonApi(json).toBeResourceIdentifier(\"data.relationships.author.data\", \"people\", \"9\")\n</code></pre>"},{"location":"reference/json-api/#relationships","title":"Relationships","text":""},{"location":"reference/json-api/#tohaverelationshipname-string-type-string-id-string","title":"<code>toHaveRelationship(name: string, type: string, id: string)</code>","text":"<p>Asserts that the document's primary data has a relationship with the specified name, and that relationship links to a resource with the given type and ID.</p> <p>This shorthand validates the structure <code>data.relationships.{name}.data</code>.</p> <pre><code>// Verifies data.relationships.author.data has type=\"people\" and id=\"9\"\nexpectJsonApi(json).toHaveRelationship(\"author\", \"people\", \"9\")\n</code></pre>"},{"location":"reference/json-api/#includes","title":"Includes","text":""},{"location":"reference/json-api/#tohaveincludedresourcetype-string-id-string","title":"<code>toHaveIncludedResource(type: string, id: string)</code>","text":"<p>Asserts that the <code>included</code> array contains a resource matching the specified type and ID. This is essential for testing compound documents.</p> <pre><code>expectJsonApi(json).toHaveIncludedResource(\"comments\", \"5\")\nexpectJsonApi(json).toHaveIncludedResource(\"people\", \"9\")\n</code></pre>"},{"location":"reference/json-api/#collection-matchers","title":"Collection Matchers","text":""},{"location":"reference/json-api/#expectjsonapiarrayjson-string-path-string","title":"<code>expectJsonApiArray(json: string, path: string)</code>","text":"<p>Creates an expectation for asserting on arrays within a JSON:API document (typically the <code>data</code> array for collection responses).</p>"},{"location":"reference/json-api/#sorting","title":"Sorting","text":""},{"location":"reference/json-api/#tobeorderedbyselector-direction","title":"<code>toBeOrderedBy(selector, direction)</code>","text":"<p>Asserts that the collection is sorted by a specific attribute.</p> <pre><code>open FX.Spec.JsonApi\n\n// Ascending order\nexpectJsonApiArray(json)(\"data\")\n    .toBeOrderedBy((fun item -&gt; item.attributes.created), Ascending)\n\n// Descending order\nexpectJsonApiArray(json)(\"data\")\n    .toBeOrderedBy((fun item -&gt; item.attributes.title), Descending)\n</code></pre>"},{"location":"reference/json-api/#helper-functions","title":"Helper Functions","text":"<p>The <code>JsonApiHelpers</code> module provides strongly-typed parsing and serialization helpers for JSON:API envelopes.</p>"},{"location":"reference/json-api/#parsing","title":"Parsing","text":"<pre><code>open FX.Spec.JsonApi\n\n// Parse single resource response -&gt; returns 'T\nlet article = parseJsonApiData&lt;Article&gt;(json)\n\n// Parse collection response -&gt; returns 'T array\nlet articles = parseJsonApiCollection&lt;Article&gt;(json)\n</code></pre>"},{"location":"reference/json-api/#serialization","title":"Serialization","text":"<p>Useful for setting up test data or mocking responses.</p> <pre><code>// Wrap item in { \"data\": ... }\nlet json = toJsonApiData(myArticle)\n\n// Wrap items in { \"data\": [...] }\nlet json = toJsonApiCollection(myArticles)\n</code></pre>"},{"location":"reference/json/","title":"JSON Testing","text":"<p>FX.Spec provides a fluent API for testing JSON content with path-based navigation, structural matching, and type-safe assertions.</p>"},{"location":"reference/json/#overview","title":"Overview","text":"<p>The <code>FX.Spec.Json</code> package allows you to assert on JSON structures using dot notation without creating temporary types for every test.</p> <pre><code>open FX.Spec.Json\n\nlet json = \"\"\"\n{\n  \"user\": {\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"roles\": [\"admin\", \"editor\"]\n  }\n}\n\"\"\"\n\nit \"validates user json\" (fun () -&gt;\n    expectJson(json).toHaveProperty(\"user.name\", \"John Doe\")\n    expectJson(json).toHaveProperty(\"user.roles[0]\", \"admin\")\n)\n</code></pre>"},{"location":"reference/json/#installation","title":"Installation","text":"<p>Add the JSON package to your test project:</p> <pre><code>dotnet add package FX.Spec.Json\n</code></pre>"},{"location":"reference/json/#core-matchers","title":"Core Matchers","text":""},{"location":"reference/json/#expectjsonjson-string","title":"<code>expectJson(json: string)</code>","text":"<p>Creates an expectation wrapper for a JSON string string.</p>"},{"location":"reference/json/#property-assertions","title":"Property Assertions","text":""},{"location":"reference/json/#tohavepropertypath-string","title":"<code>toHaveProperty(path: string)</code>","text":"<p>Asserts that a property exists at the specified path, regardless of its value.</p> <pre><code>expectJson(json).toHaveProperty(\"meta.pagination\")\nexpectJson(json).toHaveProperty(\"data[0].id\")\n</code></pre>"},{"location":"reference/json/#tohavepropertytpath-string-expected-t","title":"<code>toHaveProperty&lt;'T&gt;(path: string, expected: 'T)</code>","text":"<p>Asserts that the property at the path exists and matches the expected value. The value is deserialized to type <code>'T</code> before comparison.</p> <pre><code>// Primitives\nexpectJson(json).toHaveProperty(\"count\", 42)\nexpectJson(json).toHaveProperty(\"isActive\", true)\nexpectJson(json).toHaveProperty(\"status\", \"active\")\n\n// Complex objects\nexpectJson(json).toHaveProperty(\"config\", {| timeout = 1000 |})\n</code></pre>"},{"location":"reference/json/#path-navigation","title":"Path Navigation","text":"<p>Paths support standard dot notation and array indexing:</p> <ul> <li><code>field</code> - Top-level property</li> <li><code>parent.child</code> - Nested property</li> <li><code>items[0]</code> - Array index</li> <li><code>data.users[1].profile.email</code> - Deeply nested path</li> </ul>"},{"location":"reference/json/#structural-matching","title":"Structural Matching","text":""},{"location":"reference/json/#tomatchpartialexpected-t","title":"<code>toMatchPartial(expected: 'T)</code>","text":"<p>Asserts that the JSON object matches the shape and values of the expected object. This is a \"partial match\" meaning: 1.  All properties in <code>expected</code> must exist in the JSON. 2.  Values must match. 3.  Extra properties in the JSON are ignored.</p> <p>This is perfect for testing large API responses where you only care about specific fields.</p> <pre><code>let json = \"\"\"\n{\n  \"id\": 123,\n  \"name\": \"John\",\n  \"email\": \"john@example.com\",\n  \"metadata\": { \"created\": \"2023-01-01\", \"ip\": \"127.0.0.1\" }\n}\n\"\"\"\n\n// Verify only the fields we care about\nexpectJson(json).toMatchPartial({| \n    id = 123\n    name = \"John\" \n|})\n</code></pre>"},{"location":"reference/json/#array-matchers","title":"Array Matchers","text":""},{"location":"reference/json/#expectjsonarrayjson-string-path-string","title":"<code>expectJsonArray(json: string, path: string)</code>","text":"<p>Creates a specialized expectation for asserting on JSON arrays.</p> <ul> <li><code>json</code>: The full JSON string</li> <li><code>path</code>: Path to the array (use <code>\"\"</code> for root array)</li> </ul> <pre><code>let json = \"\"\"{\"users\": [{\"id\": 1}, {\"id\": 2}]}\"\"\"\nlet users = expectJsonArray(json)(\"users\")\n</code></pre>"},{"location":"reference/json/#array-assertions","title":"Array Assertions","text":""},{"location":"reference/json/#tohavelengthcount-int","title":"<code>toHaveLength(count: int)</code>","text":"<p>Asserts the exact length of the array.</p> <pre><code>expectJsonArray(json)(\"items\").toHaveLength(5)\n</code></pre>"},{"location":"reference/json/#toallhavepropertyname-string","title":"<code>toAllHaveProperty(name: string)</code>","text":"<p>Asserts that every object in the array contains the specified property.</p> <pre><code>// Ensure all users have an ID\nexpectJsonArray(json)(\"users\").toAllHaveProperty(\"id\")\n</code></pre>"},{"location":"reference/json/#tocontainitem-t","title":"<code>toContain(item: 'T)</code>","text":"<p>Asserts that the array contains at least one item matching the expected value.</p> <pre><code>expectJsonArray(json)(\"tags\").toContain(\"urgent\")\n</code></pre>"},{"location":"reference/json/#toallsatisfypredicate-t-bool","title":"<code>toAllSatisfy(predicate: 'T -&gt; bool)</code>","text":"<p>Asserts that all items in the array satisfy the provided predicate function.</p> <pre><code>// Ensure all scores are positive\nexpectJsonArray(json)(\"scores\").toAllSatisfy(fun (score: int) -&gt; score &gt; 0)\n</code></pre>"},{"location":"reference/json/#helper-functions","title":"Helper Functions","text":"<p>The <code>JsonHelpers</code> module provides utilities for working with JSON, automatically configured with F# support (e.g., for Options and Unions).</p> <pre><code>open FX.Spec.Json\n\n// Parse JSON to a type\nlet user = parseJson&lt;User&gt;(jsonString)\n\n// Serialize value to JSON\nlet json = toJson(user)\n</code></pre>"},{"location":"reference/runner/","title":"Test Runner","text":"<p>The FX.Spec test runner discovers and executes tests from compiled assemblies.</p>"},{"location":"reference/runner/#basic-usage","title":"Basic Usage","text":"<pre><code>dotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- &lt;assembly-path&gt; [options]\n</code></pre> <p>Or use the convenience script:</p> <pre><code>./run-tests.sh [options]\n</code></pre>"},{"location":"reference/runner/#command-line-options","title":"Command-Line Options","text":""},{"location":"reference/runner/#assembly-path","title":"Assembly Path","text":"<p>Required. Path to the compiled test assembly (<code>.dll</code> file).</p> <pre><code>dotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- tests/MyTests.dll\n</code></pre>"},{"location":"reference/runner/#-filter-f","title":"<code>--filter</code>, <code>-f</code>","text":"<p>Filter tests by description (case-sensitive substring match).</p> <p>Usage:</p> <pre><code>--filter &lt;pattern&gt;\n-f &lt;pattern&gt;\n</code></pre> <p>Examples:</p> <pre><code># Run only tests with \"Calculator\" in the description\n./run-tests.sh --filter \"Calculator\"\n\n# Run only tests with \"User\" in the description\n./run-tests.sh -f \"User\"\n\n# Filter works on full test path (describe &gt; context &gt; it)\n./run-tests.sh --filter \"when adding numbers\"\n</code></pre> <p>How it works:</p> <ul> <li>Matches against the full test path: <code>\"SpecBuilder &gt; simple examples &gt; creates a single Example node\"</code></li> <li>Case-sensitive</li> <li>Substring match (not regex)</li> <li>Filters both groups and individual tests</li> </ul>"},{"location":"reference/runner/#-format","title":"<code>--format</code>","text":"<p>Choose output format.</p> <p>Usage:</p> <pre><code>--format &lt;format&gt;\n</code></pre> <p>Formats:</p> <ul> <li><code>documentation</code> (default) - Rich Spectre.Console output with colors, tables, and panels</li> <li><code>doc</code> - Alias for <code>documentation</code></li> <li><code>simple</code> - Plain text output</li> </ul> <p>Examples:</p> <pre><code># Use documentation format (default)\n./run-tests.sh --format documentation\n\n# Use simple format\n./run-tests.sh --format simple\n\n# Short alias\n./run-tests.sh --format doc\n</code></pre> <p>Documentation Format:</p> <pre><code>SpecBuilder\n  simple examples\n    \u2713 creates a single Example node (2ms)\n    \u2713 creates multiple nodes (1ms)\n  nested describe blocks\n    \u2713 creates nested Group structures (0ms)\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Total \u2502 Passed \u2502 Failed \u2502 Skipped \u2502 Duration \u2502\n\u2502   52  \u2502   52   \u2502   0    \u2502    0    \u2502  0.15s   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Error Output with Stack Traces:</p> <p>When tests fail due to exceptions in your code, FX.Spec provides rich, actionable error information:</p> <pre><code>  \u2717 processes user data   (2ms)\n\n    Calculator &gt; processes user data\n\n    DivideByZeroException: Attempted to divide by zero.\n\n    Stack trace:\n      at Calculator.divide(Int32 x, Int32 y)\n         in Calculator.fs:42 (Calculator)\n      at Calculator.processUserData(User user)\n         in Calculator.fs:67 (Calculator)\n</code></pre> <p>Features: -  Clear exception type and message -  Filtered stack traces showing only YOUR code (framework internals removed) - \ud83d\udd17 Clickable file links (Cmd/Ctrl+Click in supported terminals to jump to the error) - \ud83d\udccd Precise file names and line numbers -  Color-coded for visual clarity</p> <p>Simple Format:</p> <pre><code>SpecBuilder &gt; simple examples &gt; creates a single Example node: PASS\nSpecBuilder &gt; simple examples &gt; creates multiple nodes: PASS\nSpecBuilder &gt; nested describe blocks &gt; creates nested Group structures: PASS\n\n52 examples, 0 failures\n</code></pre>"},{"location":"reference/runner/#-verbose-v","title":"<code>--verbose</code>, <code>-v</code>","text":"<p>Enable verbose output (shows stack traces on errors).</p> <p>Usage:</p> <pre><code>--verbose\n-v\n</code></pre> <p>Example:</p> <pre><code>./run-tests.sh --verbose\n./run-tests.sh -v\n</code></pre>"},{"location":"reference/runner/#-help-h","title":"<code>--help</code>, <code>-h</code>","text":"<p>Show help message and exit.</p> <p>Usage:</p> <pre><code>--help\n-h\n</code></pre>"},{"location":"reference/runner/#exit-codes","title":"Exit Codes","text":"<p>The runner returns different exit codes based on test results:</p> Exit Code Meaning <code>0</code> All tests passed <code>1</code> One or more tests failed <code>1</code> Fatal error (assembly not found, etc.) <p>CI/CD Integration:</p> <pre><code>#!/bin/bash\ndotnet build tests/MyProject.Tests/MyProject.Tests.fsproj\ndotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- \\\n  tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n\nif [ $? -eq 0 ]; then\n    echo \" All tests passed\"\nelse\n    echo \" Tests failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"reference/runner/#examples","title":"Examples","text":""},{"location":"reference/runner/#run-all-tests","title":"Run All Tests","text":"<pre><code># Build and run\ndotnet build tests/FX.Spec.Core.Tests/FX.Spec.Core.Tests.fsproj\ndotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- \\\n  tests/FX.Spec.Core.Tests/bin/Debug/net9.0/FX.Spec.Core.Tests.dll\n\n# Or use the script\n./run-tests.sh\n</code></pre>"},{"location":"reference/runner/#run-filtered-tests","title":"Run Filtered Tests","text":"<pre><code># Run only Calculator tests\n./run-tests.sh --filter \"Calculator\"\n\n# Run only tests in a specific context\n./run-tests.sh --filter \"when adding numbers\"\n\n# Run tests from a specific describe block\n./run-tests.sh --filter \"SpecBuilder\"\n</code></pre>"},{"location":"reference/runner/#run-with-different-formats","title":"Run with Different Formats","text":"<pre><code># Documentation format (default, colorful)\n./run-tests.sh --format documentation\n\n# Simple format (plain text, good for CI)\n./run-tests.sh --format simple\n</code></pre>"},{"location":"reference/runner/#combine-options","title":"Combine Options","text":"<pre><code># Filter + format\n./run-tests.sh --filter \"Calculator\" --format simple\n\n# Filter + verbose\n./run-tests.sh -f \"User\" -v\n\n# All options\n./run-tests.sh --filter \"Database\" --format documentation --verbose\n</code></pre>"},{"location":"reference/runner/#test-discovery","title":"Test Discovery","text":"<p>The runner discovers tests using reflection:</p> <ol> <li>Loads the assembly from the provided path</li> <li>Scans all types for static members marked with <code>[&lt;Tests&gt;]</code></li> <li>Collects TestNode lists from these members</li> <li>Applies focused filtering if any <code>fit</code> or <code>fdescribe</code> tests exist</li> <li>Applies user filter if <code>--filter</code> option is provided</li> </ol>"},{"location":"reference/runner/#requirements-for-test-discovery","title":"Requirements for Test Discovery","text":"<p>Your test module must:</p> <ol> <li>Have a static member (let-binding or property)</li> <li>Be marked with <code>[&lt;Tests&gt;]</code> attribute</li> <li>Return <code>TestNode list</code></li> <li>Be in a compiled assembly</li> </ol> <p>Example:</p> <pre><code>module MyTests\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]  // \u2190 Required for discovery\nlet mySpecs =\n    spec {\n        yield describe \"Feature\" [\n            it \"works\" (fun () -&gt;\n                expect true |&gt; should beTrue\n            )\n        ]\n    }\n</code></pre>"},{"location":"reference/runner/#focused-tests","title":"Focused Tests","text":"<p>When using <code>fit</code> or <code>fdescribe</code>, the runner automatically filters to run only focused tests:</p> <pre><code>[&lt;Tests&gt;]\nlet specs =\n    spec {\n        yield describe \"Suite\" [\n            fit \"only this runs\" (fun () -&gt;  // \u2190 Focused\n                expect true |&gt; should beTrue\n            )\n\n            it \"this is skipped\" (fun () -&gt;\n                expect false |&gt; should beTrue\n            )\n        ]\n    }\n</code></pre> <p>Output:</p> <pre><code>Suite\n  \u2713 only this runs (1ms)\n  \u2298 this is skipped (skipped - not focused)\n\n1 example, 0 failures, 1 skipped\n</code></pre> <p>Remove focused tests before committing</p> <p>Focused tests are for development only. Remove <code>fit</code>/<code>fdescribe</code> before committing code.</p>"},{"location":"reference/runner/#pending-tests","title":"Pending Tests","text":"<p>Tests marked with <code>xit</code> or <code>pending</code> are skipped:</p> <pre><code>[&lt;Tests&gt;]\nlet specs =\n    spec {\n        yield describe \"Suite\" [\n            it \"this runs\" (fun () -&gt;\n                expect true |&gt; should beTrue\n            )\n\n            xit \"this is skipped\" (fun () -&gt;\n                expect false |&gt; should beTrue\n            )\n\n            pending \"not implemented yet\" (fun () -&gt;\n                failwith \"TODO\"\n            )\n        ]\n    }\n</code></pre> <p>Output:</p> <pre><code>Suite\n  \u2713 this runs (0ms)\n  \u2298 this is skipped (pending)\n  \u2298 not implemented yet (pending)\n\n1 example, 0 failures, 2 skipped\n</code></pre>"},{"location":"reference/runner/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"reference/runner/#github-actions","title":"GitHub Actions","text":"<pre><code>name: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v3\n        with:\n          dotnet-version: '9.0.x'\n\n      - name: Build\n        run: dotnet build\n\n      - name: Run Tests\n        run: |\n          dotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- \\\n            tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll \\\n            --format simple\n</code></pre>"},{"location":"reference/runner/#gitlab-ci","title":"GitLab CI","text":"<pre><code>test:\n  image: mcr.microsoft.com/dotnet/sdk:9.0\n  script:\n    - dotnet build\n    - dotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj --\n        tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n        --format simple\n</code></pre>"},{"location":"reference/runner/#azure-pipelines","title":"Azure Pipelines","text":"<pre><code>steps:\n- task: DotNetCoreCLI@2\n  displayName: 'Build Tests'\n  inputs:\n    command: 'build'\n    projects: 'tests/**/*.fsproj'\n\n- script: |\n    dotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- \\\n      tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll \\\n      --format simple\n  displayName: 'Run Tests'\n</code></pre>"},{"location":"reference/runner/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/runner/#no-tests-found-in-assembly","title":"\"No tests found in assembly\"","text":"<p>Cause: No members marked with <code>[&lt;Tests&gt;]</code> attribute.</p> <p>Solution:</p> <pre><code>//  Correct\n[&lt;Tests&gt;]\nlet mySpecs = spec { ... }\n\n//  Wrong - missing attribute\nlet mySpecs = spec { ... }\n</code></pre>"},{"location":"reference/runner/#assembly-not-found","title":"\"Assembly not found\"","text":"<p>Cause: Incorrect path to assembly or assembly not built.</p> <p>Solution:</p> <pre><code># Build first\ndotnet build tests/MyProject.Tests/MyProject.Tests.fsproj\n\n# Then run with correct path\ndotnet run --project src/FX.Spec.Runner/FX.Spec.Runner.fsproj -- \\\n  tests/MyProject.Tests/bin/Debug/net9.0/MyProject.Tests.dll\n</code></pre>"},{"location":"reference/runner/#no-tests-match-the-filter","title":"\"No tests match the filter\"","text":"<p>Cause: Filter pattern doesn't match any test descriptions.</p> <p>Solution:</p> <ul> <li>Check filter is case-sensitive</li> <li>Use partial matches: <code>--filter \"Calc\"</code> instead of <code>--filter \"Calculator tests\"</code></li> <li>Remove filter to see all test names</li> </ul>"},{"location":"reference/runner/#see-also","title":"See Also","text":"<ul> <li>DSL API Reference - Complete DSL documentation</li> <li>Quick Start Guide - Getting started</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"reference/matchers/collections/","title":"Collection Matchers","text":"<p>Matchers for lists, arrays, sequences, and other collections.</p>"},{"location":"reference/matchers/collections/#membership","title":"Membership","text":""},{"location":"reference/matchers/collections/#contain","title":"contain","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection contains the expected item.</p> <p>Usage:</p> <pre><code>expectSeq(collection).toContain(item)\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([1; 2; 3]).toContain(2)\nexpectSeq([|\"a\"; \"b\"; \"c\"|]).toContain(\"b\")\nexpectSeq((seq { 1..10 })).toContain(5)\n\n// With custom types\ntype Person = { Name: string }\nlet people = [{ Name = \"Alice\" }; { Name = \"Bob\" }]\nexpectSeq(people).toContain({ Name = \"Alice\" })\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toContain(5)\n// =&gt; Expected collection to contain 5, but it did not. Collection: [1; 2; 3]\n</code></pre>"},{"location":"reference/matchers/collections/#containall","title":"containAll","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection contains all expected items (in any order).</p> <p>Usage:</p> <pre><code>expectSeq(collection).toContainAll(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([1; 2; 3; 4; 5]).toContainAll([2; 4])\nexpectSeq([1; 2; 3; 4; 5]).toContainAll([5; 1; 3])  // Order doesn't matter\nexpectSeq([\"a\"; \"b\"; \"c\"; \"d\"]).toContainAll([\"c\"; \"a\"])\n\n// Empty expected list always passes\nexpectSeq([1; 2; 3]).toContainAll([])\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toContainAll([2; 5; 7])\n// =&gt; Expected collection to contain all of [2; 5; 7], but missing: [5; 7]\n</code></pre>"},{"location":"reference/matchers/collections/#size","title":"Size","text":""},{"location":"reference/matchers/collections/#beempty","title":"beEmpty","text":"<p>Type: <code>Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection is empty.</p> <p>Usage:</p> <pre><code>expectSeq(collection).toBeEmpty()\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([]).toBeEmpty()\nexpect [||] |&gt; should beEmpty\nexpectSeq(Seq.empty).toBeEmpty()\nexpectSeq((List&lt;int&gt;())).toBeEmpty()\n\n// After operations\nlet filtered = [1; 2; 3] |&gt; List.filter (fun x -&gt; x &gt; 10)\nexpectSeq(filtered).toBeEmpty()\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toBeEmpty()\n// =&gt; Expected empty collection, but found 3 items\n</code></pre>"},{"location":"reference/matchers/collections/#havelength","title":"haveLength","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has the expected length.</p> <p>Usage:</p> <pre><code>expectSeq(collection).toHaveLength(count)\n</code></pre> <p>Examples:</p> <pre><code>expectSeq([1; 2; 3]).toHaveLength(3)\nexpect [|\"a\"; \"b\"|] |&gt; should (haveLength 2)\nexpectSeq(\"hello\").toHaveLength(5)  // Strings are sequences of chars\n\n// With operations\nlet doubled = [1; 2; 3] |&gt; List.map (fun x -&gt; x * 2)\nexpectSeq(doubled).toHaveLength(3)\n</code></pre> <p>Failure Message:</p> <pre><code>expectSeq([1; 2; 3]).toHaveLength(5)\n// =&gt; Expected collection to have length 5, but found length 3\n</code></pre> <p>Notes:</p> <ul> <li>Validates that expected length is non-negative</li> <li>Works with any <code>seq&lt;'a&gt;</code></li> <li>For strings, use <code>haveStringLength</code> for better error messages</li> </ul>"},{"location":"reference/matchers/collections/#havecountatleast","title":"haveCountAtLeast","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has at least the expected count.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (haveCountAtLeast minimum)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (haveCountAtLeast 3)  // Passes (5 &gt;= 3)\nexpect [1; 2] |&gt; should (haveCountAtLeast 2)  // Passes (2 &gt;= 2)\nexpect [1] |&gt; should (haveCountAtLeast 5)  // Fails (1 &lt; 5)\n\n// Useful for pagination\nlet page = database.Query().Take(10)\nexpect page |&gt; should (haveCountAtLeast 1)  // At least one result\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2] |&gt; should (haveCountAtLeast 5)\n// =&gt; Expected collection to have at least 5 items, but found 2\n</code></pre>"},{"location":"reference/matchers/collections/#havecountatmost","title":"haveCountAtMost","text":"<p>Type: <code>int -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection has at most the expected count.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (haveCountAtMost maximum)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2] |&gt; should (haveCountAtMost 5)  // Passes (2 &lt;= 5)\nexpect [1; 2; 3] |&gt; should (haveCountAtMost 3)  // Passes (3 &lt;= 3)\nexpect [1; 2; 3; 4; 5] |&gt; should (haveCountAtMost 3)  // Fails (5 &gt; 3)\n\n// Useful for limiting results\nlet recent = events |&gt; List.take 100\nexpect recent |&gt; should (haveCountAtMost 100)\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (haveCountAtMost 3)\n// =&gt; Expected collection to have at most 3 items, but found 5\n</code></pre>"},{"location":"reference/matchers/collections/#sequences","title":"Sequences","text":""},{"location":"reference/matchers/collections/#equalseq","title":"equalSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection equals the expected sequence (same order, same values).</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (equalSeq expected)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3] |&gt; should (equalSeq [1; 2; 3])\nexpect [|\"a\"; \"b\"|] |&gt; should (equalSeq [\"a\"; \"b\"])  // Arrays and lists can be compared\n\n// Order matters!\nexpect [1; 2; 3] |&gt; shouldNot (equalSeq [3; 2; 1])\nexpect [1; 2; 3] |&gt; shouldNot (equalSeq [1; 3; 2])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (equalSeq [1; 2; 4])\n// =&gt; Expected sequence [1; 2; 4], but found [1; 2; 3]\n</code></pre> <p>Notes:</p> <ul> <li>Order matters (unlike <code>containAll</code>)</li> <li>Use <code>equal</code> for structural equality (works with lists, arrays, etc.)</li> <li>Use <code>equalSeq</code> when comparing different collection types</li> </ul>"},{"location":"reference/matchers/collections/#startwithseq","title":"startWithSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection starts with the expected sequence.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (startWithSeq prefix)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (startWithSeq [1; 2])\nexpect [1; 2; 3; 4; 5] |&gt; should (startWithSeq [1; 2; 3])\nexpect [1; 2; 3; 4; 5] |&gt; should (startWithSeq [])  // Empty prefix always matches\n\n// Fails\nexpect [1; 2; 3; 4; 5] |&gt; shouldNot (startWithSeq [2; 3])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (startWithSeq [2; 3])\n// =&gt; Expected sequence to start with [2; 3], but found [1; 2]\n</code></pre>"},{"location":"reference/matchers/collections/#endwithseq","title":"endWithSeq","text":"<p>Type: <code>'a seq -&gt; Matcher&lt;'a seq&gt;</code></p> <p>Matches if the collection ends with the expected sequence.</p> <p>Usage:</p> <pre><code>expect collection |&gt; should (endWithSeq suffix)\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (endWithSeq [4; 5])\nexpect [1; 2; 3; 4; 5] |&gt; should (endWithSeq [3; 4; 5])\nexpect [1; 2; 3; 4; 5] |&gt; should (endWithSeq [])  // Empty suffix always matches\n\n// Fails\nexpect [1; 2; 3; 4; 5] |&gt; shouldNot (endWithSeq [3; 4])\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (endWithSeq [2; 4])\n// =&gt; Expected sequence to end with [2; 4], but found [2; 3]\n</code></pre>"},{"location":"reference/matchers/collections/#predicates","title":"Predicates","text":""},{"location":"reference/matchers/collections/#allsatisfy","title":"allSatisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a seq&gt;)</code></p> <p>Matches if all items in the collection satisfy the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test each item</li> <li><code>description</code> - Human-readable description</li> </ul> <p>Usage:</p> <pre><code>expect collection |&gt; should (allSatisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>expect [2; 4; 6; 8] |&gt; should (allSatisfy (fun x -&gt; x % 2 = 0) \"be even\")\nexpect [\"hello\"; \"world\"] |&gt; should (allSatisfy (fun s -&gt; s.Length &gt; 0) \"be non-empty\")\n\n// With domain logic\ntype User = { Name: string; Age: int }\nlet users = [\n    { Name = \"Alice\"; Age = 25 }\n    { Name = \"Bob\"; Age = 30 }\n]\nexpect users |&gt; should (allSatisfy (fun u -&gt; u.Age &gt;= 18) \"be adults\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect [2; 3; 4; 5] |&gt; should (allSatisfy (fun x -&gt; x % 2 = 0) \"be even\")\n// =&gt; Expected all items to satisfy 'be even', but these did not: [3; 5]\n</code></pre> <p>Notes:</p> <ul> <li>Shows up to 5 failing items in error message</li> <li>Empty collection always passes (vacuous truth)</li> <li>Use descriptive descriptions for clear error messages</li> </ul>"},{"location":"reference/matchers/collections/#anysatisfy","title":"anySatisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a seq&gt;)</code></p> <p>Matches if at least one item in the collection satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test each item</li> <li><code>description</code> - Human-readable description</li> </ul> <p>Usage:</p> <pre><code>expect collection |&gt; should (anySatisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>expect [1; 2; 3; 4; 5] |&gt; should (anySatisfy (fun x -&gt; x &gt; 3) \"be greater than 3\")\nexpect [\"hello\"; \"world\"; \"!\"] |&gt; should (anySatisfy (fun s -&gt; s.Length = 1) \"be a single character\")\n\n// Searching\ntype Product = { Name: string; Price: decimal; InStock: bool }\nlet products = [\n    { Name = \"Laptop\"; Price = 999.99m; InStock = true }\n    { Name = \"Mouse\"; Price = 29.99m; InStock = false }\n]\nexpect products |&gt; should (anySatisfy (fun p -&gt; p.InStock) \"be in stock\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect [1; 2; 3] |&gt; should (anySatisfy (fun x -&gt; x &gt; 10) \"be greater than 10\")\n// =&gt; Expected at least one item to satisfy 'be greater than 10', but none did. Collection: [1; 2; 3]\n</code></pre> <p>Notes:</p> <ul> <li>Fails on empty collection (no items to satisfy)</li> <li>Short-circuits on first match (efficient for large collections)</li> <li>Shows collection contents in error message (up to 10 items)</li> </ul>"},{"location":"reference/matchers/collections/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/collections/#testing-a-shopping-cart","title":"Testing a Shopping Cart","text":"<pre><code>module ShoppingCartSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\ntype CartItem = { ProductId: int; Quantity: int; Price: decimal }\ntype Cart = { Items: CartItem list }\n\n[&lt;Tests&gt;]\nlet shoppingCartSpecs =\n    spec {\n        describe \"ShoppingCart\" [\n            describe \"addItem\" [\n                it \"adds item to empty cart\" (fun () -&gt;\n                    let cart = Cart.empty\n                    let updated = cart.AddItem({ ProductId = 1; Quantity = 2; Price = 10.00m })\n\n                    expectSeq(updated.Items).toHaveLength(1)\n                    expectSeq(updated.Items).toContain({ ProductId = 1; Quantity = 2; Price = 10.00m })\n                )\n\n                it \"increases quantity for existing item\" (fun () -&gt;\n                    let cart = { Items = [{ ProductId = 1; Quantity = 1; Price = 10.00m }] }\n                    let updated = cart.AddItem({ ProductId = 1; Quantity = 2; Price = 10.00m })\n\n                    expectSeq(updated.Items).toHaveLength(1)\n                    expect updated.Items.[0].Quantity |&gt; should (equal 3)\n                )\n            ]\n\n            describe \"removeItem\" [\n                it \"removes item from cart\" (fun () -&gt;\n                    let cart = {\n                        Items = [\n                            { ProductId = 1; Quantity = 1; Price = 10.00m }\n                            { ProductId = 2; Quantity = 1; Price = 20.00m }\n                        ]\n                    }\n                    let updated = cart.RemoveItem(1)\n\n                    expectSeq(updated.Items).toHaveLength(1)\n                    expect updated.Items |&gt; should (anySatisfy (fun item -&gt; item.ProductId = 2) \"contain product 2\")\n                    expect updated.Items |&gt; shouldNot (anySatisfy (fun item -&gt; item.ProductId = 1) \"contain product 1\")\n                )\n            ]\n\n            describe \"total\" [\n                it \"calculates total price\" (fun () -&gt;\n                    let cart = {\n                        Items = [\n                            { ProductId = 1; Quantity = 2; Price = 10.00m }  // $20\n                            { ProductId = 2; Quantity = 1; Price = 30.00m }  // $30\n                        ]\n                    }\n                    let total = cart.Total()\n\n                    expect total |&gt; should (equal 50.00m)\n                )\n\n                it \"returns zero for empty cart\" (fun () -&gt;\n                    let cart = Cart.empty\n                    expect cart.Total() |&gt; should (equal 0.00m)\n                    expectSeq(cart.Items).toBeEmpty()\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/collections/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality and type matchers</li> <li>String Matchers - String-specific matchers</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Quick Start - Get started with FX.Spec</li> </ul>"},{"location":"reference/matchers/core/","title":"Core Expectations","text":"<p>Basic equality checks, booleans, Option, Result, and common assertions.</p>"},{"location":"reference/matchers/core/#expectation-functions","title":"Expectation Functions","text":"<p>FX.Spec provides type-specific expectation functions that return fluent wrappers with relevant assertion methods.</p>"},{"location":"reference/matchers/core/#expect","title":"expect","text":"<p>Type: <code>'a -&gt; Expectation&lt;'a&gt;</code></p> <p>Creates a generic expectation for any type.</p> <p>Usage:</p> <pre><code>expect(actual).toEqual(expected)\nexpect(actual).notToEqual(unexpected)\n</code></pre> <p>Example:</p> <pre><code>expect(2 + 2).toEqual(4)\nexpect(\"hello\").notToEqual(\"world\")\nexpect([1; 2; 3]).toEqual([1; 2; 3])\n</code></pre> <p>Available Methods: - <code>.toEqual(expected)</code> - Asserts equality using F#'s structural equality - <code>.notToEqual(unexpected)</code> - Asserts inequality</p>"},{"location":"reference/matchers/core/#expectbool","title":"expectBool","text":"<p>Type: <code>bool -&gt; BoolExpectation</code></p> <p>Creates an expectation for boolean values.</p> <p>Usage:</p> <pre><code>expectBool(actual).toBeTrue()\nexpectBool(actual).toBeFalse()\n</code></pre> <p>Examples:</p> <pre><code>expectBool(true).toBeTrue()\nexpectBool(false).toBeFalse()\nexpectBool(10 &gt; 5).toBeTrue()\nexpectBool(\"\".Length = 0).toBeTrue()\n</code></pre> <p>Available Methods: - <code>.toBeTrue()</code> - Asserts the value is true - <code>.toBeFalse()</code> - Asserts the value is false</p>"},{"location":"reference/matchers/core/#expectoption","title":"expectOption","text":"<p>Type: <code>'a option -&gt; OptionExpectation&lt;'a&gt;</code></p> <p>Creates an expectation for Option values.</p> <p>Usage:</p> <pre><code>expectOption(actual).toBeSome(expected)\nexpectOption(actual).toBeNone()\n</code></pre> <p>Examples:</p> <pre><code>expectOption(Some 42).toBeSome(42)\nexpectOption(None).toBeNone()\n\nlet result = tryParse \"123\"\nexpectOption(result).toBeSome(123)\n\nlet notFound = Map.tryFind \"key\" emptyMap\nexpectOption(notFound).toBeNone()\n</code></pre> <p>Available Methods: - <code>.toBeSome(expected)</code> - Asserts the Option is Some with the expected value - <code>.toBeNone()</code> - Asserts the Option is None</p>"},{"location":"reference/matchers/core/#expectresult","title":"expectResult","text":"<p>Type: <code>Result&lt;'a, 'b&gt; -&gt; ResultExpectation&lt;'a, 'b&gt;</code></p> <p>Creates an expectation for Result values.</p> <p>Usage:</p> <pre><code>expectResult(actual).toBeOk(expected)\nexpectResult(actual).toBeError(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectResult(Ok \"success\").toBeOk(\"success\")\nexpectResult(Error \"failed\").toBeError(\"failed\")\n\nlet parseResult = Int32.TryParse(\"42\")\nexpectResult(parseResult).toBeOk(42)\n\nlet divisionResult = divide 10 0\nexpectResult(divisionResult).toBeError(\"Division by zero\")\n</code></pre> <p>Available Methods: - <code>.toBeOk(expected)</code> - Asserts the Result is Ok with the expected value - <code>.toBeError(expected)</code> - Asserts the Result is Error with the expected error</p>"},{"location":"reference/matchers/core/#equality-assertions","title":"Equality Assertions","text":"<p>The <code>expect()</code> function provides basic equality checking:</p> <p>Examples:</p> <pre><code>// Primitives\nexpect(42).toEqual(42)\nexpect(\"hello\").toEqual(\"hello\")\nexpect(true).toEqual(true)\n\n// Collections (structural equality)\nexpect([1; 2; 3]).toEqual([1; 2; 3])\nexpect({| Name = \"Alice\"; Age = 30 |}).toEqual({| Name = \"Alice\"; Age = 30 |})\n\n// Records and DUs\ntype Person = { Name: string; Age: int }\nlet person1 = { Name = \"Alice\"; Age = 30 }\nlet person2 = { Name = \"Alice\"; Age = 30 }\nexpect(person1).toEqual(person2)  // Passes\n\n// Negative assertions\nexpect(5).notToEqual(10)\nexpect(\"hello\").notToEqual(\"world\")\n</code></pre> <p>Notes:</p> <ul> <li>Uses F# <code>=</code> operator (structural equality)</li> <li>Works with any type that supports equality</li> <li>Provides clear diff output on failure</li> </ul> <p>let result = validateAge(-1) expect result |&gt; should (beError \"Age must be positive\") <pre><code>**Failure Messages:**\n\n```fsharp\n// If actual is Ok\nexpect (Ok 42) |&gt; should (beError \"failed\")\n// =&gt; Expected Error \"failed\", but found Ok 42\n\n// If actual is Error with different value\nexpect (Error \"error1\") |&gt; should (beError \"error2\")\n// =&gt; Expected Error \"error2\", but found Error \"error1\"\n</code></pre></p>"},{"location":"reference/matchers/core/#type-checking","title":"Type Checking","text":""},{"location":"reference/matchers/core/#beoftype","title":"beOfType","text":"<p>Type: <code>Matcher&lt;obj&gt;</code></p> <p>Matches if the actual value is of the specified type.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should (beOfType&lt;TargetType&gt;)\n</code></pre> <p>Examples:</p> <pre><code>expect (box \"hello\") |&gt; should (beOfType&lt;string&gt;)\nexpect (box 42) |&gt; should (beOfType&lt;int&gt;)\nexpect (box [1; 2; 3]) |&gt; should (beOfType&lt;int list&gt;)\n\n// With inheritance\ntype Animal = { Name: string }\ntype Dog = { Name: string; Breed: string }\n\nlet animal: obj = box { Name = \"Buddy\"; Breed = \"Labrador\" }\nexpect animal |&gt; should (beOfType&lt;Dog&gt;)\n</code></pre> <p>Failure Message:</p> <pre><code>expect (box 42) |&gt; should (beOfType&lt;string&gt;)\n// =&gt; Expected type string, but found type Int32\n</code></pre>"},{"location":"reference/matchers/core/#reference-equality","title":"Reference Equality","text":""},{"location":"reference/matchers/core/#besameas","title":"beSameAs","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt;</code></p> <p>Matches if the actual value is the same reference as the expected value.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should (beSameAs expected)\n</code></pre> <p>Examples:</p> <pre><code>let list1 = [1; 2; 3]\nlet list2 = list1\nlet list3 = [1; 2; 3]\n\nexpect list2 |&gt; should (beSameAs list1)  // Passes (same reference)\nexpect list3 |&gt; shouldNot (beSameAs list1)  // Passes (different reference, same value)\n\n// Singletons\nlet singleton = SingletonService.Instance\nexpect (SingletonService.Instance) |&gt; should (beSameAs singleton)\n</code></pre> <p>Notes:</p> <ul> <li>Uses <code>obj.ReferenceEquals</code></li> <li>Different from <code>equal</code> which uses structural equality</li> <li>Useful for testing singletons, caching, or memoization</li> </ul>"},{"location":"reference/matchers/core/#custom-predicates","title":"Custom Predicates","text":""},{"location":"reference/matchers/core/#satisfy","title":"satisfy","text":"<p>Type: <code>(('a -&gt; bool) -&gt; string -&gt; Matcher&lt;'a&gt;)</code></p> <p>Matches if the actual value satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test the value</li> <li><code>description</code> - Human-readable description of the predicate</li> </ul> <p>Usage:</p> <pre><code>expect actual |&gt; should (satisfy predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>// Simple predicate\nexpect 10 |&gt; should (satisfy (fun x -&gt; x &gt; 5) \"be greater than 5\")\n\n// Complex predicate\nexpect \"hello\" |&gt; should (satisfy\n    (fun s -&gt; s.Length &gt; 3 &amp;&amp; s.StartsWith(\"h\"))\n    \"be longer than 3 chars and start with 'h'\"\n)\n\n// Domain validation\ntype Email = Email of string\nlet isValidEmail (Email email) =\n    email.Contains(\"@\") &amp;&amp; email.Contains(\".\")\n\nexpect (Email \"test@example.com\") |&gt; should (satisfy isValidEmail \"be a valid email\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect 3 |&gt; should (satisfy (fun x -&gt; x &gt; 5) \"be greater than 5\")\n// =&gt; Expected value to satisfy 'be greater than 5', but 3 did not\n</code></pre> <p>Notes:</p> <ul> <li>Use for custom validation logic</li> <li>Description is shown in failure messages</li> <li>Consider creating a dedicated matcher for commonly used predicates</li> </ul>"},{"location":"reference/matchers/core/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/core/#testing-a-user-registration-function","title":"Testing a User Registration Function","text":"<pre><code>module UserRegistrationSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\ntype ValidationError =\n    | EmailInvalid\n    | PasswordTooShort\n    | UsernameTaken\n\ntype User = { Id: int; Email: string; Username: string }\n\n[&lt;Tests&gt;]\nlet userRegistrationSpecs =\n    spec {\n        describe \"UserService.Register\" [\n            context \"when valid data is provided\" [\n                it \"returns Ok with new user\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"alice@example.com\", \"password123\")\n\n                    match result with\n                    | Ok user -&gt;\n                        expect user.Username |&gt; should (equal \"alice\")\n                        expect user.Email |&gt; should (equal \"alice@example.com\")\n                        expect user.Id |&gt; should (beGreaterThan 0)\n                    | Error _ -&gt;\n                        failwith \"Expected Ok but got Error\"\n                )\n            ]\n\n            context \"when email is invalid\" [\n                it \"returns Error EmailInvalid\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"not-an-email\", \"password123\")\n                    expect result |&gt; should (beError EmailInvalid)\n                )\n            ]\n\n            context \"when password is too short\" [\n                it \"returns Error PasswordTooShort\" (fun () -&gt;\n                    let result = UserService.register(\"alice\", \"alice@example.com\", \"123\")\n                    expect result |&gt; should (beError PasswordTooShort)\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/core/#see-also","title":"See Also","text":"<ul> <li>Collection Matchers - Matchers for lists, arrays, and sequences</li> <li>String Matchers - String-specific matchers</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Exception Matchers - Exception testing</li> <li>Quick Start - Get started with FX.Spec</li> </ul>"},{"location":"reference/matchers/exceptions/","title":"Exception Matchers","text":"<p>Matchers for testing exception throwing behavior.</p>"},{"location":"reference/matchers/exceptions/#basic-exception-testing","title":"Basic Exception Testing","text":""},{"location":"reference/matchers/exceptions/#raiseexception","title":"raiseException","text":"<p>Type: <code>Matcher&lt;unit -&gt; unit&gt; when 'T :&gt; exn</code></p> <p>Matches if the function raises an exception of the specified type.</p> <p>Usage:</p> <pre><code>expectThrows&lt;ExceptionType&gt;(action)\n</code></pre> <p>Examples:</p> <pre><code>// Basic exception\nexpectThrows&lt;System.Exception&gt;(fun () -&gt; failwith \"error\")\n\n// Specific exception type\nexpectThrows&lt;System.ArgumentException&gt;(fun () -&gt; invalidArg \"param\" \"error\")\n\n// Division by zero\nexpectThrows&lt;System.DivideByZeroException&gt;(fun () -&gt; 1 / 0 |&gt; ignore)\n\n// Custom exceptions\ntype ValidationException() = inherit exn()\nexpect (fun () -&gt; raise (ValidationException())) |&gt; should raiseException&lt;ValidationException&gt;\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception thrown\nexpectThrows&lt;Exception&gt;(fun () -&gt; 1 + 1)\n// =&gt; Expected an exception of type Exception to be thrown, but nothing was thrown\n\n// Wrong exception type\nexpectThrows&lt;InvalidOperationException&gt;(fun () -&gt; invalidArg \"x\" \"error\")\n// =&gt; Expected an exception of type InvalidOperationException, but an exception of type ArgumentException was thrown: error\n</code></pre> <p>Notes:</p> <ul> <li>Use generic type parameter to specify expected exception type</li> <li>Catches exact type and derived types</li> <li>Use most specific exception type possible for clarity</li> </ul>"},{"location":"reference/matchers/exceptions/#message-matching","title":"Message Matching","text":""},{"location":"reference/matchers/exceptions/#raiseexceptionwithmessage","title":"raiseExceptionWithMessage","text":"<p>Type: <code>string -&gt; Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function raises an exception with the specified message (exact match).</p> <p>Usage:</p> <pre><code>expectThrowsWithMessage(action, \"expected message\")\n</code></pre> <p>Examples:</p> <pre><code>expectThrowsWithMessage(fun () -&gt; failwith \"error\", \"error\")\nexpectThrowsWithMessage(fun () -&gt; invalidArg \"x\" \"must be positive\", \"must be positive (Parameter 'x')\")\n\n// Custom error messages\nlet validateAge age =\n    if age &lt; 0 then\n        invalidArg (nameof age) \"Age cannot be negative\"\n\nexpectThrowsWithMessage(fun () -&gt; validateAge -5, \"Age cannot be negative (Parameter 'age')\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception\nexpectThrowsWithMessage(fun () -&gt; 1 + 1, \"error\")\n// =&gt; Expected an exception with message 'error' to be thrown, but nothing was thrown\n\n// Different message\nexpectThrowsWithMessage(fun () -&gt; failwith \"wrong\", \"error\")\n// =&gt; Expected exception message 'error', but found 'wrong'\n</code></pre> <p>Notes:</p> <ul> <li>Message must match exactly (case-sensitive)</li> <li>For partial matching, use <code>raiseExceptionContaining</code></li> <li>Be aware of .NET exception message formatting (e.g., ArgumentException adds parameter name)</li> </ul>"},{"location":"reference/matchers/exceptions/#raiseexceptioncontaining","title":"raiseExceptionContaining","text":"<p>Type: <code>string -&gt; Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function raises an exception containing the specified substring.</p> <p>Usage:</p> <pre><code>expect action |&gt; should (raiseExceptionContaining \"substring\")\n</code></pre> <p>Examples:</p> <pre><code>expect (fun () -&gt; failwith \"file not found\") |&gt; should (raiseExceptionContaining \"not found\")\nexpect (fun () -&gt; failwith \"error: invalid input\") |&gt; should (raiseExceptionContaining \"error:\")\n\n// Partial message matching\nlet validateEmail email =\n    if not (email.Contains(\"@\")) then\n        invalidOp \"Email must contain @\"\n\nexpect (fun () -&gt; validateEmail \"invalid\") |&gt; should (raiseExceptionContaining \"@\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// No exception\nexpect (fun () -&gt; 1 + 1) |&gt; should (raiseExceptionContaining \"error\")\n// =&gt; Expected an exception containing 'error' to be thrown, but nothing was thrown\n\n// Substring not found\nexpect (fun () -&gt; failwith \"wrong\") |&gt; should (raiseExceptionContaining \"error\")\n// =&gt; Expected exception message to contain 'error', but found 'wrong'\n</code></pre> <p>Notes:</p> <ul> <li>Case-sensitive substring matching</li> <li>More flexible than exact message matching</li> <li>Good for testing error messages that include dynamic content (IDs, timestamps, etc.)</li> </ul>"},{"location":"reference/matchers/exceptions/#advanced-exception-testing","title":"Advanced Exception Testing","text":""},{"location":"reference/matchers/exceptions/#raiseexceptionmatching","title":"raiseExceptionMatching","text":"<p>Type: <code>('T -&gt; bool) -&gt; string -&gt; Matcher&lt;unit -&gt; unit&gt; when 'T :&gt; exn</code></p> <p>Matches if the function raises an exception of the specified type that satisfies the predicate.</p> <p>Parameters:</p> <ul> <li><code>predicate</code> - Function to test the exception</li> <li><code>description</code> - Human-readable description of the predicate</li> </ul> <p>Usage:</p> <pre><code>expect action |&gt; should (raiseExceptionMatching&lt;ExceptionType&gt; predicate \"description\")\n</code></pre> <p>Examples:</p> <pre><code>// Check exception property\ntype CustomException(code: int) =\n    inherit exn()\n    member _.ErrorCode = code\n\nexpect (fun () -&gt; raise (CustomException(404))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode = 404)\n        \"have error code 404\")\n\n// ArgumentException with specific parameter name\nexpect (fun () -&gt; invalidArg \"userId\" \"error\") |&gt; to'\n    (raiseExceptionMatching&lt;ArgumentException&gt;\n        (fun ex -&gt; ex.ParamName = \"userId\")\n        \"have parameter name 'userId'\")\n\n// Multiple conditions\nexpect (fun () -&gt; raise (CustomException(500))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode &gt;= 500 &amp;&amp; ex.ErrorCode &lt; 600)\n        \"have 5xx error code\")\n</code></pre> <p>Failure Messages:</p> <pre><code>// Exception doesn't match predicate\nexpect (fun () -&gt; raise (CustomException(200))) |&gt; to'\n    (raiseExceptionMatching&lt;CustomException&gt;\n        (fun ex -&gt; ex.ErrorCode = 404)\n        \"have error code 404\")\n// =&gt; Expected exception to match 'have error code 404', but it did not: [exception message]\n\n// Wrong exception type\nexpect (fun () -&gt; failwith \"error\") |&gt; to'\n    (raiseExceptionMatching&lt;ArgumentException&gt;\n        (fun ex -&gt; ex.ParamName = \"x\")\n        \"have parameter name 'x'\")\n// =&gt; Expected an exception of type ArgumentException, but an exception of type Exception was thrown\n</code></pre> <p>Notes:</p> <ul> <li>Combines type checking and predicate matching</li> <li>Description appears in error messages</li> <li>Use for complex exception validation</li> <li>Predicate receives strongly-typed exception</li> </ul>"},{"location":"reference/matchers/exceptions/#negative-testing","title":"Negative Testing","text":""},{"location":"reference/matchers/exceptions/#notraiseexception","title":"notRaiseException","text":"<p>Type: <code>Matcher&lt;unit -&gt; unit&gt;</code></p> <p>Matches if the function does not raise any exception.</p> <p>Usage:</p> <pre><code>expect action |&gt; should notRaiseException\n</code></pre> <p>Examples:</p> <pre><code>expect (fun () -&gt; 1 + 1) |&gt; should notRaiseException\nexpect (fun () -&gt; printfn \"hello\") |&gt; should notRaiseException\n\n// Safe operations\nlet safeDivide x y =\n    if y = 0 then 0\n    else x / y\n\nexpect (fun () -&gt; safeDivide 10 0 |&gt; ignore) |&gt; should notRaiseException\n</code></pre> <p>Failure Message:</p> <pre><code>expect (fun () -&gt; failwith \"error\") |&gt; should notRaiseException\n// =&gt; Expected no exception to be thrown, but Exception was thrown: error\n\nexpect (fun () -&gt; 1 / 0 |&gt; ignore) |&gt; should notRaiseException\n// =&gt; Expected no exception to be thrown, but DivideByZeroException was thrown: Attempted to divide by zero.\n</code></pre> <p>Notes:</p> <ul> <li>Useful for testing error handling code</li> <li>Can also use <code>notTo' raiseException&lt;exn&gt;</code></li> <li>Shows exception type and message in failure</li> </ul>"},{"location":"reference/matchers/exceptions/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/exceptions/#testing-input-validation","title":"Testing Input Validation","text":"<pre><code>module ValidationSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\nopen System\n\ntype ValidationError =\n    | Required of field: string\n    | InvalidFormat of field: string\n    | OutOfRange of field: string * min: int * max: int\n\nexception ValidationException of ValidationError\n\nmodule Validator =\n    let validateAge age =\n        if age &lt; 0 then\n            invalidArg (nameof age) \"Age cannot be negative\"\n        elif age &gt; 150 then\n            invalidArg (nameof age) \"Age must be less than 150\"\n        else\n            age\n\n    let validateEmail email =\n        if String.IsNullOrWhiteSpace(email) then\n            raise (ValidationException(Required \"email\"))\n        elif not (email.Contains(\"@\")) then\n            raise (ValidationException(InvalidFormat \"email\"))\n        else\n            email\n\n[&lt;Tests&gt;]\nlet validationSpecs =\n    spec {\n        describe \"Validator\" [\n            describe \"validateAge\" [\n                context \"when age is valid\" [\n                    it \"returns age without exception\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge 25 |&gt; ignore) |&gt; should notRaiseException\n                    )\n                ]\n\n                context \"when age is negative\" [\n                    it \"raises ArgumentException\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            raiseException&lt;ArgumentException&gt;\n                    )\n\n                    it \"has descriptive error message\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            (raiseExceptionContaining \"cannot be negative\")\n                    )\n\n                    it \"includes parameter name\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge -5 |&gt; ignore) |&gt; to'\n                            (raiseExceptionMatching&lt;ArgumentException&gt;\n                                (fun ex -&gt; ex.ParamName = \"age\")\n                                \"have parameter name 'age'\")\n                    )\n                ]\n\n                context \"when age is too large\" [\n                    it \"raises ArgumentException with message\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateAge 200 |&gt; ignore) |&gt; to'\n                            (raiseExceptionContaining \"less than 150\")\n                    )\n                ]\n            ]\n\n            describe \"validateEmail\" [\n                context \"when email is null or empty\" [\n                    it \"raises ValidationException with Required error\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"\" |&gt; ignore) |&gt; to'\n                            (raiseExceptionMatching&lt;ValidationException&gt;\n                                (fun ex -&gt;\n                                    match ex.Data0 with\n                                    | Required field -&gt; field = \"email\"\n                                    | _ -&gt; false)\n                                \"have Required error for email field\")\n                    )\n                ]\n\n                context \"when email format is invalid\" [\n                    it \"raises ValidationException with InvalidFormat error\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"notanemail\" |&gt; ignore) |&gt; to'\n                            raiseException&lt;ValidationException&gt;\n                    )\n                ]\n\n                context \"when email is valid\" [\n                    it \"does not raise exception\" (fun () -&gt;\n                        expect (fun () -&gt; Validator.validateEmail \"test@example.com\" |&gt; ignore) |&gt; to'\n                            notRaiseException\n                    )\n                ]\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/exceptions/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>module ErrorHandlingSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\nopen System\nopen System.IO\n\nmodule FileService =\n    let readFile path =\n        if not (File.Exists(path)) then\n            raise (FileNotFoundException($\"File not found: {path}\"))\n        File.ReadAllText(path)\n\n    let safeReadFile path =\n        try\n            Ok (readFile path)\n        with\n        | :? FileNotFoundException as ex -&gt; Error ex.Message\n        | ex -&gt; Error $\"Unexpected error: {ex.Message}\"\n\n[&lt;Tests&gt;]\nlet errorHandlingSpecs =\n    spec {\n        describe \"FileService\" [\n            describe \"readFile\" [\n                it \"raises FileNotFoundException for missing file\" (fun () -&gt;\n                    expect (fun () -&gt; FileService.readFile \"nonexistent.txt\" |&gt; ignore) |&gt; to'\n                        raiseException&lt;FileNotFoundException&gt;\n                )\n\n                it \"includes filename in exception message\" (fun () -&gt;\n                    let path = \"missing.txt\"\n                    expect (fun () -&gt; FileService.readFile path |&gt; ignore) |&gt; to'\n                        (raiseExceptionContaining path)\n                )\n            ]\n\n            describe \"safeReadFile\" [\n                it \"returns Error for missing file\" (fun () -&gt;\n                    let result = FileService.safeReadFile \"nonexistent.txt\"\n                    expect result |&gt; should (satisfy Result.isError \"be Error\")\n                )\n\n                it \"does not raise exception\" (fun () -&gt;\n                    expect (fun () -&gt; FileService.safeReadFile \"nonexistent.txt\" |&gt; ignore) |&gt; to'\n                        notRaiseException\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/exceptions/#best-practices","title":"Best Practices","text":""},{"location":"reference/matchers/exceptions/#be-specific","title":"Be Specific","text":"<pre><code>// Good - specific exception type\nexpectThrows&lt;ArgumentNullException&gt;(action)\n\n// Less good - generic exception type\nexpectThrows&lt;Exception&gt;(action)\n</code></pre>"},{"location":"reference/matchers/exceptions/#test-exception-messages","title":"Test Exception Messages","text":"<pre><code>// Good - validates error communication\nexpect action |&gt; should (raiseExceptionContaining \"must be positive\")\n\n// Less good - only checks exception type\nexpectThrows&lt;ArgumentException&gt;(action)\n</code></pre>"},{"location":"reference/matchers/exceptions/#use-lambdas-for-lazy-evaluation","title":"Use Lambdas for Lazy Evaluation","text":"<pre><code>// Good - lazy evaluation\nexpect (fun () -&gt; riskyOperation()) |&gt; should raiseException&lt;Exception&gt;\n\n// Wrong - evaluates immediately, exception thrown before matcher\nexpect riskyOperation() |&gt; should raiseException&lt;Exception&gt;  // Compilation error\n</code></pre>"},{"location":"reference/matchers/exceptions/#prefer-result-types-for-errors","title":"Prefer Result Types for Errors","text":"<pre><code>// Consider using Result types instead of exceptions for expected errors\ntype ValidationResult = Result&lt;ValidatedData, ValidationError&gt;\n\nlet validate data : ValidationResult =\n    if isValid data then\n        Ok (ValidatedData data)\n    else\n        Error (ValidationError \"Invalid data\")\n\n// Test with Result matchers\nexpect (validate invalidData) |&gt; should (beError (ValidationError \"Invalid data\"))\n</code></pre>"},{"location":"reference/matchers/exceptions/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic matchers including Result matchers</li> <li>Quick Start - Get started with FX.Spec</li> <li>DSL API - Complete DSL reference</li> </ul>"},{"location":"reference/matchers/numeric/","title":"Numeric Matchers","text":"<p>Numeric comparisons and range checks for numbers.</p>"},{"location":"reference/matchers/numeric/#comparisons","title":"Comparisons","text":""},{"location":"reference/matchers/numeric/#begreaterthan","title":"beGreaterThan","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is greater than the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeGreaterThan(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(10).toBeGreaterThan(5)\nexpectNum(3.14).toBeGreaterThan(3.0)\nexpectNum(100L).toBeGreaterThan(50L)\n\n// After calculations\nlet score = calculateScore()\nexpectNum(score).toBeGreaterThan(0)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeGreaterThan(10)\n// =&gt; Expected value to be greater than 10, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#begreaterthanorequal","title":"beGreaterThanOrEqual","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is greater than or equal to the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeGreaterThanOrEqual(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(10).toBeGreaterThanOrEqual(10)  // Equal case\nexpectNum(10).toBeGreaterThanOrEqual(5)   // Greater case\nexpectNum(5.0).toBeGreaterThanOrEqual(5.0)\n\n// Minimum validation\nlet age = user.Age\nexpectNum(age).toBeGreaterThanOrEqual(18)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeGreaterThanOrEqual(10)\n// =&gt; Expected value to be greater than or equal to 10, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#belessthan","title":"beLessThan","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is less than the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeLessThan(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBeLessThan(10)\nexpectNum(2.5).toBeLessThan(3.0)\nexpectNum(-10).toBeLessThan(0)\n\n// Maximum validation\nlet count = list.Length\nexpectNum(count).toBeLessThan(100)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(15).toBeLessThan(10)\n// =&gt; Expected value to be less than 10, but found 15\n</code></pre>"},{"location":"reference/matchers/numeric/#belessthanorequal","title":"beLessThanOrEqual","text":"<p>Type: <code>'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is less than or equal to the expected value.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeLessThanOrEqual(expected)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBeLessThanOrEqual(5)   // Equal case\nexpectNum(5).toBeLessThanOrEqual(10)  // Less case\nexpectNum(3.14).toBeLessThanOrEqual(4.0)\n\n// Maximum limit\nlet responseTime = measureResponseTime()\nexpectNum(responseTime).toBeLessThanOrEqual(1000)  // Max 1000ms\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(15).toBeLessThanOrEqual(10)\n// =&gt; Expected value to be less than or equal to 10, but found 15\n</code></pre>"},{"location":"reference/matchers/numeric/#ranges","title":"Ranges","text":""},{"location":"reference/matchers/numeric/#bebetween","title":"beBetween","text":"<p>Type: <code>'a -&gt; 'a -&gt; Matcher&lt;'a&gt; when 'a : comparison</code></p> <p>Matches if the actual value is between min and max (inclusive).</p> <p>Parameters:</p> <ul> <li><code>min</code> - Minimum value (inclusive)</li> <li><code>max</code> - Maximum value (inclusive)</li> </ul> <p>Usage:</p> <pre><code>expectNum(actual).toBeBetween(min, max)\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBeBetween(1, 10)    // Within range\nexpectNum(1).toBeBetween(1, 10)    // Minimum (inclusive)\nexpectNum(10).toBeBetween(1, 10)   // Maximum (inclusive)\n\n// Age validation\nlet age = user.Age\nexpectNum(age).toBeBetween(18, 65)\n\n// Percentage\nlet score = getScore()\nexpectNum(score).toBeBetween(0.0, 100.0)\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(15).toBeBetween(1, 10)\n// =&gt; Expected value to be between 1 and 10, but found 15\n</code></pre> <p>Notes:</p> <ul> <li>Both bounds are inclusive</li> <li>Validates that <code>min &lt;= max</code> at creation time</li> <li>Works with any comparable type (int, float, DateTime, etc.)</li> </ul>"},{"location":"reference/matchers/numeric/#floating-point","title":"Floating Point","text":""},{"location":"reference/matchers/numeric/#becloseto","title":"beCloseTo","text":"<p>Type: <code>float -&gt; float -&gt; Matcher&lt;float&gt;</code></p> <p>Matches if the actual floating-point value is close to the expected value within a tolerance.</p> <p>Parameters:</p> <ul> <li><code>expected</code> - Expected value</li> <li><code>tolerance</code> - Maximum allowed difference</li> </ul> <p>Usage:</p> <pre><code>expectFloat(actual).toBeCloseTo(expected, tolerance)\n</code></pre> <p>Examples:</p> <pre><code>expectFloat(3.14159).toBeCloseTo(3.14, 0.01)     // Within tolerance\nexpectFloat(3.14159).toBeCloseTo(3.14159, 0.0)   // Exact match\n\n// Calculation precision\nlet result = Math.PI * 2.0\nexpectFloat(result).toBeCloseTo(6.283, 0.001)\n\n// Financial calculations\nlet total = calculateTotal()\nexpectFloat(total).toBeCloseTo(99.99, 0.01)\n</code></pre> <p>Failure Message:</p> <pre><code>expectFloat(3.5).toBeCloseTo(3.14, 0.1)\n// =&gt; Expected value to be close to 3.14 (\u00b10.1), but found 3.5 (diff: 0.36)\n</code></pre> <p>Notes:</p> <ul> <li>Tolerance must be non-negative</li> <li>Does not accept NaN or Infinity</li> <li>Use for comparing floating-point results where exact equality is unreliable</li> <li>Default to smallest reasonable tolerance</li> </ul>"},{"location":"reference/matchers/numeric/#sign-checks","title":"Sign Checks","text":""},{"location":"reference/matchers/numeric/#bepositive","title":"bePositive","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : comparison and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is positive (&gt; 0).</p> <p>Usage:</p> <pre><code>expectNum(actual).toBePositive()\n</code></pre> <p>Examples:</p> <pre><code>expectNum(5).toBePositive()\nexpectNum(0.1).toBePositive()\nexpectNum(100L).toBePositive()\n\n// After calculations\nlet profit = revenue - expenses\nexpectNum(profit).toBePositive()\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(-5).toBePositive()\n// =&gt; Expected positive value, but found -5\n\nexpectNum(0).toBePositive()\n// =&gt; Expected positive value, but found 0\n</code></pre> <p>Notes:</p> <ul> <li>Zero is not positive (use <code>beGreaterThanOrEqual 0</code> to include zero)</li> <li>Works with any numeric type that has a <code>Zero</code> member</li> </ul>"},{"location":"reference/matchers/numeric/#benegative","title":"beNegative","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : comparison and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is negative (&lt; 0).</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeNegative()\n</code></pre> <p>Examples:</p> <pre><code>expectNum(-5).toBeNegative()\nexpectNum(-0.1).toBeNegative()\nexpectNum(-100L).toBeNegative()\n\n// Testing debt\nlet balance = account.Balance\nif balance &lt; 0 then\n    expectNum(balance).toBeNegative()\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeNegative()\n// =&gt; Expected negative value, but found 5\n\nexpectNum(0).toBeNegative()\n// =&gt; Expected negative value, but found 0\n</code></pre>"},{"location":"reference/matchers/numeric/#bezero","title":"beZero","text":"<p>Type: <code>Matcher&lt;'a&gt; when 'a : equality and 'a : (static member Zero : 'a)</code></p> <p>Matches if the actual value is zero.</p> <p>Usage:</p> <pre><code>expectNum(actual).toBeZero()\n</code></pre> <p>Examples:</p> <pre><code>expectNum(0).toBeZero()\nexpectNum(0.0).toBeZero()\nexpectNum(0L).toBeZero()\n\n// After operations\nlet remainder = 10 % 2\nexpectNum(remainder).toBeZero()\n</code></pre> <p>Failure Message:</p> <pre><code>expectNum(5).toBeZero()\n// =&gt; Expected zero, but found 5\n</code></pre>"},{"location":"reference/matchers/numeric/#integer-properties","title":"Integer Properties","text":""},{"location":"reference/matchers/numeric/#beeven","title":"beEven","text":"<p>Type: <code>Matcher&lt;int&gt;</code></p> <p>Matches if the actual integer is even.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should beEven\n</code></pre> <p>Examples:</p> <pre><code>expect 2 |&gt; should beEven\nexpect 0 |&gt; should beEven\nexpect -4 |&gt; should beEven\n\n// Testing parity\nlet count = list.Length\nif shouldBeEven(count) then\n    expect count |&gt; should beEven\n</code></pre> <p>Failure Message:</p> <pre><code>expect 3 |&gt; should beEven\n// =&gt; Expected even number, but found 3\n</code></pre>"},{"location":"reference/matchers/numeric/#beodd","title":"beOdd","text":"<p>Type: <code>Matcher&lt;int&gt;</code></p> <p>Matches if the actual integer is odd.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should beOdd\n</code></pre> <p>Examples:</p> <pre><code>expect 1 |&gt; should beOdd\nexpect 3 |&gt; should beOdd\nexpect -5 |&gt; should beOdd\n\n// Testing alternating pattern\nlet index = getCurrentIndex()\nif shouldBeOnOddIndex(index) then\n    expect index |&gt; should beOdd\n</code></pre> <p>Failure Message:</p> <pre><code>expect 4 |&gt; should beOdd\n// =&gt; Expected odd number, but found 4\n</code></pre>"},{"location":"reference/matchers/numeric/#bedivisibleby","title":"beDivisibleBy","text":"<p>Type: <code>int -&gt; Matcher&lt;int&gt;</code></p> <p>Matches if the actual value is divisible by the expected divisor.</p> <p>Usage:</p> <pre><code>expect actual |&gt; should (beDivisibleBy divisor)\n</code></pre> <p>Examples:</p> <pre><code>expect 15 |&gt; should (beDivisibleBy 5)\nexpect 12 |&gt; should (beDivisibleBy 3)\nexpect 100 |&gt; should (beDivisibleBy 10)\n\n// Page size validation\nlet itemCount = items.Length\nexpect itemCount |&gt; should (beDivisibleBy pageSize)\n\n// Even numbers are divisible by 2\nexpect 8 |&gt; should (beDivisibleBy 2)\n</code></pre> <p>Failure Message:</p> <pre><code>expect 7 |&gt; should (beDivisibleBy 3)\n// =&gt; Expected 7 to be divisible by 3, but it is not\n</code></pre> <p>Notes:</p> <ul> <li>Divisor cannot be zero (throws <code>ArgumentException</code>)</li> <li>Works with negative numbers</li> <li><code>beDivisibleBy 2</code> is equivalent to <code>beEven</code></li> </ul>"},{"location":"reference/matchers/numeric/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/numeric/#testing-a-math-library","title":"Testing a Math Library","text":"<pre><code>module MathLibrarySpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\nopen System\n\n[&lt;Tests&gt;]\nlet mathLibrarySpecs =\n    spec {\n        describe \"MathHelpers\" [\n            describe \"average\" [\n                it \"calculates average of numbers\" (fun () -&gt;\n                    let result = MathHelpers.average [1.0; 2.0; 3.0; 4.0; 5.0]\n                    expect result |&gt; should (equal 3.0)\n                    expectNum(result).toBeGreaterThan(0.0)\n                )\n\n                it \"handles floating-point precision\" (fun () -&gt;\n                    let result = MathHelpers.average [1.0/3.0; 2.0/3.0; 3.0/3.0]\n                    expectFloat(result).toBeCloseTo(0.666, 0.001)\n                )\n            ]\n\n            describe \"factorial\" [\n                it \"calculates factorial of positive number\" (fun () -&gt;\n                    let result = MathHelpers.factorial 5\n                    expect result |&gt; should (equal 120)\n                    expectNum(result).toBePositive()\n                )\n\n                it \"returns 1 for zero\" (fun () -&gt;\n                    let result = MathHelpers.factorial 0\n                    expect result |&gt; should (equal 1)\n                )\n            ]\n\n            describe \"isPrime\" [\n                it \"identifies prime numbers\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 2) |&gt; should beTrue\n                    expect (MathHelpers.isPrime 7) |&gt; should beTrue\n                    expect (MathHelpers.isPrime 13) |&gt; should beTrue\n                )\n\n                it \"rejects composite numbers\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 4) |&gt; should beFalse\n                    expect (MathHelpers.isPrime 9) |&gt; should beFalse\n                )\n\n                it \"rejects numbers less than 2\" (fun () -&gt;\n                    expect (MathHelpers.isPrime 1) |&gt; should beFalse\n                    expect (MathHelpers.isPrime 0) |&gt; should beFalse\n                    expect (MathHelpers.isPrime -5) |&gt; should beFalse\n                )\n            ]\n\n            describe \"clamp\" [\n                it \"keeps value within range\" (fun () -&gt;\n                    let result = MathHelpers.clamp 5 1 10\n                    expect result |&gt; should (equal 5)\n                    expectNum(result).toBeBetween(1, 10)\n                )\n\n                it \"clamps to minimum\" (fun () -&gt;\n                    let result = MathHelpers.clamp -5 1 10\n                    expect result |&gt; should (equal 1)\n                    expectNum(result).toBeGreaterThanOrEqual(1)\n                )\n\n                it \"clamps to maximum\" (fun () -&gt;\n                    let result = MathHelpers.clamp 15 1 10\n                    expect result |&gt; should (equal 10)\n                    expectNum(result).toBeLessThanOrEqual(10)\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/numeric/#testing-financial-calculations","title":"Testing Financial Calculations","text":"<pre><code>module FinancialSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet financialSpecs =\n    spec {\n        describe \"Financial Calculations\" [\n            describe \"calculateInterest\" [\n                it \"calculates simple interest\" (fun () -&gt;\n                    let principal = 1000.0\n                    let rate = 0.05  // 5%\n                    let time = 2.0   // 2 years\n\n                    let interest = Financial.calculateSimpleInterest principal rate time\n                    expectFloat(interest).toBeCloseTo(100.0, 0.01)\n                    expectNum(interest).toBePositive()\n                )\n\n                it \"handles edge case of zero rate\" (fun () -&gt;\n                    let interest = Financial.calculateSimpleInterest 1000.0 0.0 2.0\n                    expectNum(interest).toBeZero()\n                )\n            ]\n\n            describe \"calculateTax\" [\n                it \"calculates tax for income bracket\" (fun () -&gt;\n                    let income = 50000.0\n                    let tax = Financial.calculateTax income\n\n                    expectNum(tax).toBePositive()\n                    expectNum(tax).toBeLessThan(income)\n                    expectFloat(tax).toBeCloseTo(7500.0, 100.0)  // Approximate\n                )\n\n                it \"returns zero tax for income below threshold\" (fun () -&gt;\n                    let income = 5000.0\n                    let tax = Financial.calculateTax income\n                    expectNum(tax).toBeZero()\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/numeric/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality matchers</li> <li>Collection Matchers - Collection matchers</li> <li>String Matchers - String matchers</li> <li>Quick Start - Get started with FX.Spec</li> </ul>"},{"location":"reference/matchers/result/","title":"Result Matchers","text":"<p>FX.Spec provides comprehensive matchers for testing F#'s <code>Result&lt;'T, 'E&gt;</code> type, which is the idiomatic way to handle errors in functional F# code.</p>"},{"location":"reference/matchers/result/#overview","title":"Overview","text":"<p>The <code>Result&lt;'T, 'E&gt;</code> type represents either success (<code>Ok 'T</code>) or failure (<code>Error 'E</code>). FxSpec's Result matchers allow you to assert on both the state and the value of Result types.</p> <pre><code>open FX.Spec.Matchers\n\n// State-only matchers\nexpectResult(result).toBeOk()     // Just check it succeeded\nexpectResult(result).toBeError()  // Just check it failed\n\n// Value-specific matchers\nexpectResult(result).toBeOk(42)           // Check success with specific value\nexpectResult(result).toBeError(\"failed\")  // Check error with specific message\n</code></pre>"},{"location":"reference/matchers/result/#result-matchers_1","title":"Result Matchers","text":""},{"location":"reference/matchers/result/#expectresultresult","title":"expectResult(result)","text":"<p>Creates a Result expectation wrapper that provides Result-specific assertion methods.</p> <pre><code>let result: Result&lt;int, string&gt; = Ok 42\nexpectResult(result).toBeOk(42)\n</code></pre>"},{"location":"reference/matchers/result/#state-only-matchers","title":"State-Only Matchers","text":"<p>These matchers only check whether the Result is <code>Ok</code> or <code>Error</code>, without caring about the specific value.</p>"},{"location":"reference/matchers/result/#tobeok","title":"toBeOk()","text":"<p>Asserts that the Result is <code>Ok</code> with any value.</p> <p>Use Cases: - Checking operation success without caring about the specific return value - Validating that no errors occurred - Testing scenarios where the exact value is unpredictable</p> <pre><code>describe \"Authentication\" [\n    it \"successfully authenticates valid user\" (fun () -&gt;\n        let result = authenticate(validToken)\n        expectResult(result).toBeOk()  // Don't care about the specific user data\n    )\n\n    it \"grants access to authorized user\" (fun () -&gt;\n        let result = authorizeUser(userId, permission)\n        expectResult(result).toBeOk()  // Just check authorization succeeded\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#tobeerror","title":"toBeError()","text":"<p>Asserts that the Result is <code>Error</code> with any error value.</p> <p>Use Cases: - Checking that validation failed without specifying the exact error - Testing error handling paths - Verifying that security checks rejected invalid input</p> <pre><code>describe \"Validation\" [\n    it \"rejects invalid email format\" (fun () -&gt;\n        let result = validateEmail(\"not-an-email\")\n        expectResult(result).toBeError()  // Don't care about specific error message\n    )\n\n    it \"fails when database is unavailable\" (fun () -&gt;\n        let result = connectToDatabase(invalidConnectionString)\n        expectResult(result).toBeError()  // Just verify it failed\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#value-specific-matchers","title":"Value-Specific Matchers","text":"<p>These matchers check both the Result state and the specific value contained within.</p>"},{"location":"reference/matchers/result/#tobeokexpected-t","title":"toBeOk(expected: 'T)","text":"<p>Asserts that the Result is <code>Ok</code> with a specific value.</p> <pre><code>describe \"Calculator\" [\n    it \"adds numbers correctly\" (fun () -&gt;\n        let result = calculate \"2 + 2\"\n        expectResult(result).toBeOk(4)\n    )\n\n    it \"returns correct user data\" (fun () -&gt;\n        let result = findUser(123)\n        expectResult(result).toBeOk({ Id = 123; Name = \"John\" })\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#tobeerrorexpected-e","title":"toBeError(expected: 'E)","text":"<p>Asserts that the Result is <code>Error</code> with a specific error value.</p> <pre><code>describe \"Error Handling\" [\n    it \"returns specific validation error\" (fun () -&gt;\n        let result = validateAge(-5)\n        expectResult(result).toBeError(\"Age must be positive\")\n    )\n\n    type ValidationError = { Field: string; Message: string }\n\n    it \"returns structured error\" (fun () -&gt;\n        let result = validateUser(invalidUser)\n        expectResult(result).toBeError({ \n            Field = \"Email\"\n            Message = \"Invalid email format\" \n        })\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#common-patterns","title":"Common Patterns","text":""},{"location":"reference/matchers/result/#web-api-error-handling","title":"Web API Error Handling","text":"<p>Result types are commonly used in web APIs for handling validation, authentication, and business logic errors:</p> <pre><code>describe \"User Registration API\" [\n    it \"succeeds with valid data\" (fun () -&gt;\n        let result = registerUser(validUser)\n        expectResult(result).toBeOk()  // Just verify registration succeeded\n    )\n\n    it \"fails with duplicate email\" (fun () -&gt;\n        let result = registerUser(existingEmailUser)\n        expectResult(result).toBeError()  // Verify it fails\n    )\n\n    it \"returns specific validation error for missing fields\" (fun () -&gt;\n        let result = registerUser(incompleteUser)\n        expectResult(result).toBeError(\"Email is required\")\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#database-operations","title":"Database Operations","text":"<pre><code>type DbError = NotFound | ConnectionError | Timeout\n\ndescribe \"Database Repository\" [\n    it \"successfully retrieves existing record\" (fun () -&gt;\n        let result = repository.Get(validId)\n        expectResult(result).toBeOk()  // Don't need to verify entire record\n    )\n\n    it \"returns NotFound for missing record\" (fun () -&gt;\n        let result = repository.Get(missingId)\n        expectResult(result).toBeError(NotFound)\n    )\n\n    it \"handles connection errors\" (fun () -&gt;\n        disconnectDatabase()\n        let result = repository.Get(anyId)\n        expectResult(result).toBeError(ConnectionError)\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#authorization-and-security","title":"Authorization and Security","text":"<pre><code>type AuthError = Unauthorized | Forbidden | TokenExpired\n\ndescribe \"Authorization Service\" [\n    it \"grants access to authorized user\" (fun () -&gt;\n        let result = authorize(validToken, resource)\n        expectResult(result).toBeOk()  // Access granted\n    )\n\n    it \"denies access to unauthorized user\" (fun () -&gt;\n        let result = authorize(invalidToken, resource)\n        expectResult(result).toBeError()  // Access denied\n    )\n\n    it \"returns specific error for expired token\" (fun () -&gt;\n        let result = authorize(expiredToken, resource)\n        expectResult(result).toBeError(TokenExpired)\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#async-result-patterns","title":"Async Result Patterns","text":"<p>Result types work seamlessly with async workflows:</p> <pre><code>describe \"Async Operations\" [\n    itAsync \"fetches data successfully\" (async {\n        let! result = fetchDataAsync(validId)\n        expectResult(result).toBeOk()\n    })\n\n    itAsync \"handles async errors\" (async {\n        let! result = fetchDataAsync(invalidId)\n        expectResult(result).toBeError()\n    })\n\n    itAsync \"validates async operation result\" (async {\n        let! result = processPaymentAsync(payment)\n        expectResult(result).toBeOk({ \n            TransactionId = \"txn_123\"\n            Status = \"Completed\" \n        })\n    })\n]\n</code></pre>"},{"location":"reference/matchers/result/#railway-oriented-programming","title":"Railway-Oriented Programming","text":"<p>Result types enable railway-oriented programming (ROP) patterns:</p> <pre><code>describe \"Pipeline Processing\" [\n    it \"succeeds when all steps pass\" (fun () -&gt;\n        let result = \n            validateInput(data)\n            |&gt; Result.bind processData\n            |&gt; Result.bind saveToDatabase\n            |&gt; Result.map formatOutput\n\n        expectResult(result).toBeOk()\n    )\n\n    it \"fails at validation step\" (fun () -&gt;\n        let result = \n            validateInput(invalidData)\n            |&gt; Result.bind processData  // Won't execute\n            |&gt; Result.bind saveToDatabase  // Won't execute\n\n        expectResult(result).toBeError()\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#discriminated-union-errors","title":"Discriminated Union Errors","text":"<p>F# discriminated unions make excellent error types:</p> <pre><code>type ValidationError =\n    | EmptyField of field: string\n    | InvalidFormat of field: string * message: string\n    | OutOfRange of field: string * min: int * max: int\n\ndescribe \"Validation with DU Errors\" [\n    it \"detects empty required field\" (fun () -&gt;\n        let result = validateName(\"\")\n        expectResult(result).toBeError(EmptyField \"Name\")\n    )\n\n    it \"detects invalid email format\" (fun () -&gt;\n        let result = validateEmail(\"not-valid\")\n        expectResult(result).toBeError(\n            InvalidFormat(\"Email\", \"Must contain @\")\n        )\n    )\n\n    it \"detects out of range value\" (fun () -&gt;\n        let result = validateAge(150)\n        expectResult(result).toBeError(\n            OutOfRange(\"Age\", 0, 120)\n        )\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#error-messages","title":"Error Messages","text":"<p>FX.Spec provides clear error messages for Result assertions:</p>"},{"location":"reference/matchers/result/#tobeok-failure","title":"toBeOk() Failure","text":"<pre><code>Expected Ok, but found Error \"something went wrong\"\nExpected: Ok\nActual: Error \"something went wrong\"\n</code></pre>"},{"location":"reference/matchers/result/#tobeokvalue-failure","title":"toBeOk(value) Failure","text":"<pre><code>Expected Ok 42, but found Ok 100\nExpected: 42\nActual: 100\n</code></pre>"},{"location":"reference/matchers/result/#tobeerror-failure","title":"toBeError() Failure","text":"<pre><code>Expected Error, but found Ok 42\nExpected: Error\nActual: Ok 42\n</code></pre>"},{"location":"reference/matchers/result/#tobeerrorvalue-failure","title":"toBeError(value) Failure","text":"<pre><code>Expected Error \"Unauthorized\", but found Error \"Forbidden\"\nExpected: \"Unauthorized\"\nActual: \"Forbidden\"\n</code></pre>"},{"location":"reference/matchers/result/#best-practices","title":"Best Practices","text":""},{"location":"reference/matchers/result/#1-use-state-only-matchers-when-appropriate","title":"1. Use State-Only Matchers When Appropriate","text":"<p>When you don't need to verify the specific value, use state-only matchers:</p> <pre><code>// Good - just checking success\nexpectResult(result).toBeOk()\n\n// Unnecessary - don't care about the specific value\nexpectResult(result).toBeOk(someValue)  // If you don't need to verify value\n</code></pre>"},{"location":"reference/matchers/result/#2-use-value-specific-matchers-for-critical-values","title":"2. Use Value-Specific Matchers for Critical Values","text":"<p>When the exact value matters, verify it:</p> <pre><code>// Good - verifying specific error\nexpectResult(result).toBeError(NotFound)\n\n// Risky - might miss wrong error type\nexpectResult(result).toBeError()\n</code></pre>"},{"location":"reference/matchers/result/#3-combine-with-other-matchers","title":"3. Combine with Other Matchers","text":"<p>Result matchers work well with other FX.Spec features:</p> <pre><code>describe \"Complex Validation\" [\n    it \"validates and processes data\" (fun () -&gt;\n        let result = validateAndProcess(data)\n\n        // First check it succeeded\n        expectResult(result).toBeOk()\n\n        // Then verify the result value\n        match result with\n        | Ok value -&gt; expectNum(value.Score).toBeGreaterThan(0)\n        | Error _ -&gt; failwith \"Unexpected error\"\n    )\n]\n</code></pre>"},{"location":"reference/matchers/result/#4-test-both-success-and-failure-paths","title":"4. Test Both Success and Failure Paths","text":"<p>Always test both happy path and error scenarios:</p> <pre><code>describe \"User Service\" [\n    context \"with valid input\" [\n        it \"creates user successfully\" (fun () -&gt;\n            let result = createUser(validData)\n            expectResult(result).toBeOk()\n        )\n    ]\n\n    context \"with invalid input\" [\n        it \"rejects empty name\" (fun () -&gt;\n            let result = createUser({ validData with Name = \"\" })\n            expectResult(result).toBeError()\n        )\n\n        it \"rejects invalid email\" (fun () -&gt;\n            let result = createUser({ validData with Email = \"invalid\" })\n            expectResult(result).toBeError()\n        )\n    ]\n]\n</code></pre>"},{"location":"reference/matchers/result/#type-signatures","title":"Type Signatures","text":"<pre><code>// Create Result expectation\nexpectResult : Result&lt;'T, 'E&gt; -&gt; ResultExpectation&lt;'T, 'E&gt;\n    when 'T : equality and 'E : equality\n\n// State-only matchers\ntoBeOk : unit -&gt; unit\ntoBeError : unit -&gt; unit\n\n// Value-specific matchers\ntoBeOk : expected:'T -&gt; unit\ntoBeError : expected:'E -&gt; unit\n</code></pre>"},{"location":"reference/matchers/result/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core Matchers - Basic equality and type matchers</li> <li>Async Support - Using <code>itAsync</code> with Result types</li> <li>HTTP Testing - HTTP responses often use Result patterns</li> <li>Quick Start - Getting started with FX.Spec</li> </ul>"},{"location":"reference/matchers/result/#see-also","title":"See Also","text":"<ul> <li>Railway Oriented Programming - Scott Wlaschin's ROP pattern</li> <li>F# Result Type - Official F# documentation</li> </ul>"},{"location":"reference/matchers/strings/","title":"String Matchers","text":"<p>String-specific matchers for prefixes, suffixes, patterns, and more.</p>"},{"location":"reference/matchers/strings/#prefixes-suffixes","title":"Prefixes &amp; Suffixes","text":""},{"location":"reference/matchers/strings/#startwith","title":"startWith","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string starts with the expected prefix.</p> <p>Usage:</p> <pre><code>expectStr(string).toStartWith(prefix)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello world\").toStartWith(\"hello\")\nexpectStr(\"FxSpec\").toStartWith(\"Fx\")\nexpectStr(\"https://example.com\").toStartWith(\"https://\")\n\n// Case-sensitive\nexpectStr(\"Hello\").notToStartWith(\"hello\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello world\").toStartWith(\"goodbye\")\n// =&gt; Expected string to start with 'goodbye', but found 'hello world'\n</code></pre> <p>Notes:</p> <ul> <li>Case-sensitive by default</li> <li>Returns error for null strings</li> <li>For case-insensitive matching, use custom logic or convert to lowercase first</li> </ul>"},{"location":"reference/matchers/strings/#endwith","title":"endWith","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string ends with the expected suffix.</p> <p>Usage:</p> <pre><code>expectStr(string).toEndWith(suffix)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello world\").toEndWith(\"world\")\nexpectStr(\"test.txt\").toEndWith(\".txt\")\nexpectStr(\"FxSpec\").toEndWith(\"Spec\")\n\n// File extensions\nlet filename = \"document.pdf\"\nexpectStr(filename).toEndWith(\".pdf\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello world\").toEndWith(\".txt\")\n// =&gt; Expected string to end with '.txt', but found 'hello world'\n</code></pre>"},{"location":"reference/matchers/strings/#substrings","title":"Substrings","text":""},{"location":"reference/matchers/strings/#containsubstring","title":"containSubstring","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string contains the expected substring.</p> <p>Usage:</p> <pre><code>expectStr(string).toContainSubstring(substring)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello world\").toContainSubstring(\"lo wo\")\nexpectStr(\"FX.Spec is great\").toContainSubstring(\"Spec\")\nexpectStr(\"error: file not found\").toContainSubstring(\"error:\")\n\n// Search in logs\nlet logMessage = \"2025-01-01 10:00:00 INFO User logged in\"\nexpectStr(logMessage).toContainSubstring(\"INFO\")\nexpectStr(logMessage).toContainSubstring(\"logged in\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello world\").toContainSubstring(\"goodbye\")\n// =&gt; Expected string to contain 'goodbye', but found 'hello world'\n</code></pre>"},{"location":"reference/matchers/strings/#patterns","title":"Patterns","text":""},{"location":"reference/matchers/strings/#matchregex","title":"matchRegex","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string matches the regular expression pattern.</p> <p>Usage:</p> <pre><code>expectStr(string).toMatchRegex(pattern)\n</code></pre> <p>Examples:</p> <pre><code>// Email validation\nexpectStr(\"test@example.com\").toMatchRegex(@\"^\\w+@\\w+\\.\\w+$\")\n\n// Phone numbers\nexpectStr(\"555-1234\").toMatchRegex(@\"^\\d{3}-\\d{4}$\")\n\n// Dates\nexpectStr(\"2025-01-01\").toMatchRegex(@\"^\\d{4}-\\d{2}-\\d{2}$\")\n\n// Contains digits\nexpectStr(\"hello123\").toMatchRegex(@\"\\d+\")\n\n// Starts with uppercase\nexpectStr(\"Hello\").toMatchRegex(@\"^[A-Z]\")\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello\").toMatchRegex(@\"^\\d+$\")\n// =&gt; Expected string to match pattern '^\\d+$', but found 'hello'\n</code></pre> <p>Notes:</p> <ul> <li>Uses .NET <code>Regex.IsMatch</code></li> <li>Patterns are case-sensitive by default</li> <li>Use <code>(?i)</code> flag for case-insensitive matching: <code>matchRegex @\"(?i)hello\"</code></li> </ul>"},{"location":"reference/matchers/strings/#empty-checks","title":"Empty Checks","text":""},{"location":"reference/matchers/strings/#beemptystring","title":"beEmptyString","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is empty (<code>\"\"</code>).</p> <p>Usage:</p> <pre><code>expectStr(string).toBeEmpty()\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"\").toBeEmpty()\nexpectStr(String.Empty).toBeEmpty()\n\n// After operations\nlet trimmed = \"   \".Trim()\nexpectStr(trimmed).toBeEmpty()\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello\").toBeEmpty()\n// =&gt; Expected empty string, but found 'hello'\n\nexpectStr(null).toBeEmpty()\n// =&gt; Expected empty string, but found null\n</code></pre>"},{"location":"reference/matchers/strings/#benullorempty","title":"beNullOrEmpty","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is null or empty.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beNullOrEmpty\n</code></pre> <p>Examples:</p> <pre><code>expect null |&gt; should beNullOrEmpty\nexpect \"\" |&gt; should beNullOrEmpty\nexpect String.Empty |&gt; should beNullOrEmpty\n\n// Validation\nlet userInput = getUserInput()\nif String.IsNullOrEmpty(userInput) then\n    expect userInput |&gt; should beNullOrEmpty\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; should beNullOrEmpty\n// =&gt; Expected null or empty string, but found 'hello'\n</code></pre>"},{"location":"reference/matchers/strings/#benullorwhitespace","title":"beNullOrWhitespace","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string is null, empty, or contains only whitespace.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beNullOrWhitespace\n</code></pre> <p>Examples:</p> <pre><code>expect null |&gt; should beNullOrWhitespace\nexpect \"\" |&gt; should beNullOrWhitespace\nexpect \"   \" |&gt; should beNullOrWhitespace\nexpect \"\\t\\n\" |&gt; should beNullOrWhitespace\n\n// User input validation\nlet comment = getCommentText()\nif String.IsNullOrWhiteSpace(comment) then\n    expect comment |&gt; should beNullOrWhitespace\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello\" |&gt; should beNullOrWhitespace\n// =&gt; Expected null, empty, or whitespace string, but found 'hello'\n</code></pre>"},{"location":"reference/matchers/strings/#length","title":"Length","text":""},{"location":"reference/matchers/strings/#havestringlength","title":"haveStringLength","text":"<p>Type: <code>int -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string has the expected length.</p> <p>Usage:</p> <pre><code>expectStr(string).toHaveLength(length)\n</code></pre> <p>Examples:</p> <pre><code>expectStr(\"hello\").toHaveLength(5)\nexpectStr(\"\").toHaveLength(0)\nexpectStr(\"FxSpec\").toHaveLength(6)\n\n// Password validation\nlet password = \"secret123\"\nexpectStr(password).toHaveLength(9)\n</code></pre> <p>Failure Message:</p> <pre><code>expectStr(\"hello\").toHaveLength(10)\n// =&gt; Expected string of length 10, but found length 5 ('hello')\n\nexpectStr(null).toHaveLength(5)\n// =&gt; Expected string of length 5, but found null\n</code></pre>"},{"location":"reference/matchers/strings/#case-insensitive","title":"Case Insensitive","text":""},{"location":"reference/matchers/strings/#equalignorecase","title":"equalIgnoreCase","text":"<p>Type: <code>string -&gt; Matcher&lt;string&gt;</code></p> <p>Matches if the string equals the expected value (case-insensitive).</p> <p>Usage:</p> <pre><code>expect string |&gt; should (equalIgnoreCase expected)\n</code></pre> <p>Examples:</p> <pre><code>expect \"HELLO\" |&gt; should (equalIgnoreCase \"hello\")\nexpect \"FxSpec\" |&gt; should (equalIgnoreCase \"fxspec\")\nexpect \"TeSt\" |&gt; should (equalIgnoreCase \"test\")\n\n// Configuration keys\nlet configKey = \"DatabaseConnectionString\"\nexpect configKey |&gt; should (equalIgnoreCase \"databaseconnectionstring\")\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"HELLO\" |&gt; should (equalIgnoreCase \"goodbye\")\n// =&gt; Expected 'goodbye' (case-insensitive), but found 'HELLO'\n</code></pre> <p>Notes:</p> <ul> <li>Uses <code>StringComparison.OrdinalIgnoreCase</code></li> <li>Handles null correctly</li> <li>For exact case match, use <code>equal</code> from core matchers</li> </ul>"},{"location":"reference/matchers/strings/#character-types","title":"Character Types","text":""},{"location":"reference/matchers/strings/#bealphabetic","title":"beAlphabetic","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string contains only letters.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beAlphabetic\n</code></pre> <p>Examples:</p> <pre><code>expect \"hello\" |&gt; should beAlphabetic\nexpect \"FxSpec\" |&gt; should beAlphabetic\nexpect \"ABC\" |&gt; should beAlphabetic\n\n// Fails\nexpect \"hello123\" |&gt; shouldNot beAlphabetic  // Contains digits\nexpect \"hello world\" |&gt; shouldNot beAlphabetic  // Contains space\nexpect \"\" |&gt; shouldNot beAlphabetic  // Empty string\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"hello123\" |&gt; should beAlphabetic\n// =&gt; Expected alphabetic string, but found 'hello123'\n\nexpect \"\" |&gt; should beAlphabetic\n// =&gt; Expected alphabetic string, but found empty string\n</code></pre>"},{"location":"reference/matchers/strings/#benumeric","title":"beNumeric","text":"<p>Type: <code>Matcher&lt;string&gt;</code></p> <p>Matches if the string contains only digits.</p> <p>Usage:</p> <pre><code>expect string |&gt; should beNumeric\n</code></pre> <p>Examples:</p> <pre><code>expect \"12345\" |&gt; should beNumeric\nexpect \"0\" |&gt; should beNumeric\nexpect \"999\" |&gt; should beNumeric\n\n// Fails\nexpect \"123.45\" |&gt; shouldNot beNumeric  // Contains decimal point\nexpect \"12 34\" |&gt; shouldNot beNumeric  // Contains space\nexpect \"\" |&gt; shouldNot beNumeric  // Empty string\n</code></pre> <p>Failure Message:</p> <pre><code>expect \"12.34\" |&gt; should beNumeric\n// =&gt; Expected numeric string, but found '12.34'\n</code></pre> <p>Notes:</p> <ul> <li>Only accepts digits 0-9</li> <li>Does not accept decimal points, minus signs, or spaces</li> <li>For parsing numbers, use <code>Int32.TryParse</code> or similar</li> </ul>"},{"location":"reference/matchers/strings/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/matchers/strings/#testing-url-validation","title":"Testing URL Validation","text":"<pre><code>module UrlValidationSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet urlValidationSpecs =\n    spec {\n        describe \"URL Validator\" [\n            describe \"validateUrl\" [\n                context \"when URL is valid\" [\n                    it \"accepts https URLs\" (fun () -&gt;\n                        let url = \"https://example.com\"\n                        expectStr(url).toStartWith(\"https://\")\n                        expectStr(url).toMatchRegex(@\"^https?://[\\w\\-]+(\\.[\\w\\-]+)+[/#?]?.*$\")\n                    )\n\n                    it \"accepts http URLs\" (fun () -&gt;\n                        let url = \"http://example.com/path?query=value\"\n                        expectStr(url).toStartWith(\"http://\")\n                        expectStr(url).toContainSubstring(\"example.com\")\n                    )\n\n                    it \"accepts URLs with paths\" (fun () -&gt;\n                        let url = \"https://example.com/api/users\"\n                        expectStr(url).toContainSubstring(\"/api/users\")\n                        expectStr(url).toEndWith(\"/users\")\n                    )\n                ]\n\n                context \"when URL is invalid\" [\n                    it \"rejects empty strings\" (fun () -&gt;\n                        expectStr(\"\").toBeEmpty()\n                        expectStr(\"\").notToStartWith(\"http\")\n                    )\n\n                    it \"rejects non-URL strings\" (fun () -&gt;\n                        expectStr(\"not a url\").notToMatchRegex(@\"^https?://\")\n                    )\n                ]\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/strings/#testing-string-transformations","title":"Testing String Transformations","text":"<pre><code>module StringTransformationSpecs\n\nopen FX.Spec.Core\nopen FX.Spec.Matchers\n\n[&lt;Tests&gt;]\nlet stringTransformationSpecs =\n    spec {\n        describe \"StringHelpers\" [\n            describe \"slugify\" [\n                it \"converts to lowercase\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"Hello World\"\n                    expect result |&gt; should (equalIgnoreCase \"hello-world\")\n                    expect result |&gt; should (equal \"hello-world\")\n                )\n\n                it \"replaces spaces with hyphens\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"My Blog Post\"\n                    expect result |&gt; should (equal \"my-blog-post\")\n                    expectStr(result).notToContainSubstring(\" \")\n                )\n\n                it \"removes special characters\" (fun () -&gt;\n                    let result = StringHelpers.slugify \"Hello, World!\"\n                    expect result |&gt; should (equal \"hello-world\")\n                    expect result |&gt; should beAlphabetic  // False, contains hyphen\n                    expectStr(result).toMatchRegex(@\"^[a-z\\-]+$\")\n                )\n            ]\n\n            describe \"sanitize\" [\n                it \"trims whitespace\" (fun () -&gt;\n                    let result = StringHelpers.sanitize \"  hello  \"\n                    expect result |&gt; should (equal \"hello\")\n                    expectStr(result).notToStartWith(\" \")\n                    expectStr(result).notToEndWith(\" \")\n                )\n\n                it \"returns empty string for whitespace-only input\" (fun () -&gt;\n                    let result = StringHelpers.sanitize \"   \"\n                    expectStr(result).toBeEmpty()\n                )\n            ]\n        ]\n    }\n</code></pre>"},{"location":"reference/matchers/strings/#see-also","title":"See Also","text":"<ul> <li>Core Matchers - Basic equality matchers</li> <li>Collection Matchers - Collection matchers (strings are sequences of chars)</li> <li>Numeric Matchers - Numeric comparisons</li> <li>Quick Start - Get started with FX.Spec</li> </ul>"}]}